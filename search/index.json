[{"content":"在机器学习理论中，回归和分类是最经典的两个有监督学习问题，而聚类则是最经典的无监督学习方法。\n其中，线性回归模型是最简单的一个回归模型，我们以此为例进行介绍。\n线性回归的R语言实现 由于线性回归在传统的一元概率论与数理统计课程中已经介绍过了，所以这里直接介绍他的R语言实现。\n线性回归的R语言实现，核心函数是lm。\n而在概率论与数理统计的课程中应该也介绍过广义线性回归模型，例如$y=e^{ax+b}$次方，只需要两边取对数就又是线性回归了。\n这种广义线性回归模型在R语言中借助函数glm实现。\n例如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 创建数据 data \u0026lt;- data.frame( y = c(1, 2, 3, 4, 5), x = c(1, 2, 3, 4, 5) ) # 线性回归 model_lm \u0026lt;- lm(y ~ x, data) summary(model_lm) # 广义线性回归（这里是两边取对数后为线性回归） model_glm \u0026lt;- glm(y ~ x, family =poisson(), data) summary(model_glm) 在这里lm函数语法是\n1 model \u0026lt;- lm(formula, data, ...)\tformula: 一个公式对象，指定了因变量和自变量之间的关系。例如，y ~ x 表示 y 是因变量，x 是自变量。 data: 一个数据框，包含了模型中的变量。 ...: 其他参数，如 method 指定求解方法。 在本例中lm的summary是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Call: lm(formula = y ~ x, data = data) Residuals: 1 2 3 4 5 2.184e-16 -4.138e-16 1.514e-16 6.514e-17 -2.111e-17 Coefficients: Estimate Std. Error t value Pr(\u0026gt;|t|) (Intercept) -7.944e-16 3.007e-16 -2.642e+00 0.0775 . x 1.000e+00 9.065e-17 1.103e+16 \u0026lt;2e-16 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 2.867e-16 on 3 degrees of freedom Multiple R-squared: 1, Adjusted R-squared: 1 F-statistic: 1.217e+32 on 1 and 3 DF, p-value: \u0026lt; 2.2e-16 Call: 显示了用于拟合模型的 lm() 函数的调用。\nResiduals: 是每个数据拟合后的残差，可以看到他们接近于零，这说明模型完美地拟合了数据。\nCoefficients是系数的意思：\n(Intercept): 截距项。\nx: 自变量x的系数。\n表中的第一列是各系数的估计值。\n第二列是标准差。\n第三列是进行显著性检验时需要的t统计量的值。\n第四列是p-value\nResidual standard error: 残差的标准误差，如果非常小，就说明模型完美地拟合了数据。\nMultiple R-squared: 决定系数为 1，这意味着模型解释了所有变异。\nF-statistic: F统计量非常大，p值非常小，这表明模型整体上是显著的。\n而glm的summary内容和lm的是一样的。\n需要注意的是，glm在调用的时候要额外给出family表示你要对数据进行怎样的变换。\nR语言提供了很多family，例如\n1 2 3 4 5 6 7 8 binomial(link = \u0026#34;logit\u0026#34;) gaussian(link = \u0026#34;identity\u0026#34;) Gamma(link = \u0026#34;inverse\u0026#34;) inverse.gaussian(link = \u0026#34;1/mu^2\u0026#34;) poisson(link = \u0026#34;log\u0026#34;) quasi(link = \u0026#34;identity\u0026#34;, variance = \u0026#34;constant\u0026#34;) quasibinomial(link = \u0026#34;logit\u0026#34;) quasipoisson(link = \u0026#34;log\u0026#34;) 我无法逐一说明，感兴趣就自己上网查询。\n在这里，如果选择poisson就是我们前面举例子的那个情况，拟合$y=e^{ax+b}$次方。\n但是回归分析其实不能光看summary的报告，还得进行回归诊断。\n需要通过残差分析验证拟合后的残差是否合理，通过影响分析观察数据有没有异常点或强影响点，通过共线性诊断判断变量是否有较强的共线性。\n在R语言中进行残差分析只需要使用函数residuals(fit) rstandard(fit) rstudent(fit) （fit为函数lm()生成的对象）就可以计算模型的残差、标准化残差和学生化残差。\n然后可以绘制这样的残差分析图：\n上图中只有图a是正常的残差，具有随机性。\nb图是很明显的二次曲线，应该在拟合的时候引入交叉型或平方项。\n图c残差在左边靠的很近，右边离得很远呈现喇叭口样式，我们说这种模型主差齐性不成立，你可以试着给Y取个对数、倒数、开平方或者进行box-cox变换再拟合看看。\n图d的话就是观测值不独立。总之，只有图a才是最理想的残差图。\n如果要进行影响分析，也就是查看数据有没有异常点或者强影响点，可以计算数据的标准化残差，如果某个数据的标准化残差大于2小于3，则他是可疑点。但如果他的标准化残差比3大，按照正态分布的$3\\sigma$原则，他是异常点。\n当然，其实还可以用帽子矩阵计算杠杆值，如果杠杆值比较大就说明那个样本是强影响点，或者计算库克距离（其实统计学里除了马氏距离还有绝对值距离、闵可夫斯基距离、切比雪夫距离、兰氏距离等很多距离），如果样本的库克距离大于1则是异常点。不过这两个比较进阶高级，你大概率没听过他的理论，也就不再介绍了。在R语言中通过函数influence.measures(fit模型)就可以直接计算前面说的什么库克距离啊之类的统计量了。\n至于共线性诊断，主流的有3种方法，分布是特征值法、条件指数法、方差碰撞因子法。在此只介绍方差膨胀因子法。\n在R语言中，安装扩展包DAAG，然后使用函数vif（fit模型,计算精确到小数点后几位）就可以计算方差膨胀因子了。\n一般我们认为，如果方差碰撞因子＞10则模型有很强的共线性问题，这时候需要用自回归模型来拟合而不是线性模型。\n最后补充一嘴，线性回归还可以通过计算参数CP/AIC/BIC来衡量其优越程度，一般说来这三个参数越小越好。\n线性判别分析LDA 在机器学习中有很多能实现分类问题的算法，如神经网络（好好好上来就开大是吧）、决策树、朴素贝叶斯分类器、支持向量机等等。我们这里就介绍最最简单的距离判别和线性判别分析lda。\n所谓距离判别，简单地不能再简单了。\n就是一个新样本离哪个总体近就认为这个样本属于哪个总体。\n那什么是样本离总体的距离呢？\n就是样本离该总体的均值的距离。\n好，说完了。\n距离判别只需要你选定一个距离，例如马氏距离。\n然后你计算已知总体的均值。\n接下来，每来一个新的样本，你就计算这个样本到各个总体的均值的距离，然后哪个总体到这个样本的距离最小，这个样本就分类为哪个样本。\n线性判别分析LDA是一种fisher判别法，他先将数据进行线性变换，希望最大化两个或多个群体之间的距离。然后再进行判别。\n也就是说，当你收到两个群体的数据的时候，你首先计算他们的均值$y_1,y_2$，然后施加线性变换得到$z_1=a^Ty_1,z_2=a^Ty_2$。\n然后要找a，使得$z_1,z_2$的马氏距离最远。\n而方差未知情形的两正态总体的方差我们在上一期已经说过，就是$(\\frac{1}{n_1}+\\frac{1}{n_2})a^TS_{pl}a$\n因此我们要最大化的马氏距离的平方为$t^2(a)=\\frac{(a^T(y_1-y_2))^T(a^T(y_1-y_2))}{(\\frac{1}{n_1}+\\frac{1}{n_2})a^TS_{pl}a}$\n只需要使用柯西不等式$(a^Tb)^2\\le(a^TWa)(b^TWb)$即可求解，得到$a=S_{pl}^{-1}(y_1-y_2)$。\n其中a被称为判别函数系数，$z=a^Ty$则是fisher线性判别函数。\n但是以上是两群体的情况，如果是多群体就麻烦多了。\n这里只说最终结论。\n需要构造组间离差矩阵$B=\\sum_{k=1}^g(\\overline y_k-\\overline y)(\\overline y_k-\\overline y)^T$和组内离差矩阵$W=\\sum_{k=1}^g\\sum_{i=1}^{k_n}(y_{ki}-\\overline y_k)(y_{ki}-\\overline y_k)^T$\n然后求矩阵$W^{-1}B$的特征值和特征向量。其中最大的特征值对应的特征向量就是a。\n当求出a以后，就可以将所有的数据进行变换，从而得到一个一维的数据。\n所以从某种意义上看，fisher判别分析也实现了一种降维。\n而当数据变成这样的一维数据以后，我们再使用任意算法进行判别就会变得非常容易了，例如继续使用刚刚的距离判别法。\n在R语言中只需要使用MASS库的lda函数就可以很简单地实现fisher线性判别分析了，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 安装和加载MASS包 install.packages(\u0026#34;MASS\u0026#34;) library(MASS) # 创建示例数据 # 两组数据，每组各有三个特征 group1 \u0026lt;- cbind(x1 = rnorm(10, mean = 5, sd = 2), x2 = rnorm(10, mean = 5, sd = 2), x3 = rnorm(10, mean = 5, sd = 2)) group2 \u0026lt;- cbind(x1 = rnorm(10, mean = 10, sd = 2), x2 = rnorm(10, mean = 10, sd = 2), x3 = rnorm(10, mean = 10, sd = 2)) # 将数据组合在一起，并添加组标签 data \u0026lt;- rbind(group1, group2) group \u0026lt;- c(rep(\u0026#34;Group1\u0026#34;, 10), rep(\u0026#34;Group2\u0026#34;, 10)) # 使用lda()函数进行Fisher线性判别 lda_model \u0026lt;- lda(group ~ x1 + x2 + x3, data) # 查看模型摘要 summary(lda_model) # 使用模型进行预测 predictions \u0026lt;- predict(lda_model, data) # 查看预测结果 predictions$class 等级聚类/层次聚类/系统聚类 接下来是聚类的话题。\n聚类是一种无监督学习算法。\n他和前面说的判别分析的不同之处在于，判别分析需要你先喂一些数据，告诉模型哪些数据属于A类，哪些属于B类，而无监督学习不需要。\n这里要介绍的是一种最为简单的聚类方法，叫做层次聚类，也叫做系统聚类，还叫做等级聚类。\n他的核心就是，让人来聚类啊哈哈哈。\n说错了。\n他的思想就是我每次都将距离最近的两个样本合并，认为他们属于同一个类别。\n然后算法什么时候停止呢？等所有样本都被划分为一个类的时候停止，然后画出一张分析图，最后交由人工判别。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 # 创建示例数据 data \u0026lt;- matrix(rnorm(100, mean = 0, sd = 1), nrow = 10, ncol = 10) # 使用hclust()函数进行层次聚类 hclust_result \u0026lt;- hclust(dist(data), method = \u0026#34;complete\u0026#34;) # 绘制聚类树状图 plot(hclust_result, labels = 1:10, main = \u0026#34;层次聚类树状图\u0026#34;, xlab = \u0026#34;样本\u0026#34;, ylab = \u0026#34;距离\u0026#34;) # 根据树状图切割聚类 cutree(hclust_result, k = 3) 我们先用rnorm生成标准正态分布的随机数，把它放在10*10的矩阵里。\n然后调用hclust函数进行层次聚类，最后进行绘图，你会收获这样的聚类图。\n这个聚类图是从下往上读的，首先因为样本6和10距离最近，所以先将6和10合并为一个总体，此时得到右下角第一个合并，他的纵坐标是合并时的距离。\n接着，5号和7号进行了合并，然后是3号和（5,7）这个整体进行了合并。\n然后8号和9号合并，2号和（6,10）进行合并，1号和（2,6,10）进行合并。4号和（8,9）进行合并。\n然后（3,5,7）与（1,2,6,10）进行合并。\n最后（4,8,9）与（3,5,7,1,2,6,10）进行合并，到这里所有元素都归于一个类的，算法结束。\n通过这张图，接下来由我们人工进行聚类。\n例如我就想聚1类，那么就取最后一次合并的结果也就是1-10全部。\n如果想分两类，就取倒数第二次合并的结果也就是（4,8,9）一类，其余一类。\n想分三类就取倒数第三次的结果，以此类推。\n借助函数cutree(hclust_result, k = 3)可以直接得到分3类的结果，这样你就不用自己手工去数了。\n这就是层次聚类。\n但是在层次聚类的时候，结果可能会因为细节的不同而不同。\n例如我可能认为，所谓的距离是欧氏距离，也可能认为是马氏距离等等。\n我可能认为，一个样本到总体的距离是指样本到总体的均值的距离，样本到总体最近（或最远）的点的距离等等。\n我可能认为一个总体到另一个总体的距离是他们均值的距离，也可能认为是各个样本点距离的均值，等等。\n反正就是有这么多变化。\nk-means聚类 在R语言中实现k-means聚类非常简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 示例数据 X \u0026lt;- matrix(c(1, 2, 1, 4, 1, 0, 10, 2, 10, 4, 10, 0), nrow=6, byrow=TRUE) # 选择簇的数量 k \u0026lt;- 2 # 使用kmeans函数进行聚类 set.seed(0) # 设置随机数种子以确保结果的可重复性 kmeans_result \u0026lt;- kmeans(X, centers=k, nstart=10) # 输出聚类结果 print(kmeans_result$cluster) # 每个数据点所属的簇的标签 print(kmeans_result$centers) # 每个簇的中心点 而k-means本身也非常简单。\nk-means和层次聚类不同，他需要用户先指定要分为k个类。\n然后算法会随机选择k个初始聚类中心，接着将各个样本分类给距离他最近的距离中心。\n然后再把各聚类中心的均值作为新的聚类中心。\n依次重复，直到聚类中心不再移动。（收敛了）\n就这么几句话就说完了，而且没有什么计算。\n","date":"2024-12-26T14:06:47+08:00","permalink":"https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%903-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%9B%9E%E5%BD%92%E5%88%86%E7%B1%BB%E5%92%8C%E8%81%9A%E7%B1%BB/","title":"多元统计分析(3) 常见的机器学习算法 回归分类和聚类"},{"content":"上一期咱们介绍了多维随机变量的矩估计和极大似然估计以及他们的R语言实现。这一期理所应当的要介绍多元正态分布的假设检验。\n假设检验其实是能检验很多的，但是最经典的是对均值向量和方差的检验。而他们的检验全部依赖于统计距离。\n统计距离 我们知道多维随机变量实际上是一个向量，而向量我们是有长度/范数/模的概念的。\n在统计学里，我们常见的所谓距离被称为欧几里得距离，简称欧氏距离。\n也就是，对两个列向量X,Y，他们之间的欧几里得距离定义为$d(X,Y)=\\sqrt{(X-Y)^T(X-Y)}$，也就是X-Y的2-范数。\n这个欧氏距离就是我们现实中两点的距离，但是他在统计学中没有那么好用。\n这是因为欧氏距离没有考虑到数据本身的变化尺度不同，也没有考虑到变量之间的相关性，更没有克服量纲的影响。\n比如说随机变量只在（-1千克(kg),1kg）变化，那原来-1kg到1kg距离差是2kg，在欧氏距离下就是2。\n可是我现在如果用克(g)做单位，那-1kg到1kg的距离差就变成2000了，这显然是不合理的，甚至可以说是不可理喻的。\n也因此，我们在统计学中会使用由马哈拉诺比斯提出的马氏距离。\n其实说起来也非常简单，你不是要克服量纲的影响吗？\n给随机变量标准化一下不就行了？\n例如，两个随机变量X,Y，我们都进行标准化（也就是左乘协方差的根号的逆矩阵），然后再计算他们的欧氏距离。\n这里先说明一下，在一元情况下，方差D(X)是标准差$\\sigma$的平方也就是$\\sigma^2$，而现在我们已知的是方差，因此标准差$\\sigma=\\sqrt{D(X)}$。\n但是对于多元情况，D（X）是一个矩阵，但是你给矩阵开根号是什么意思呢？\n我们在上一个系列——数值计算方法中提过矩阵的平方根分解：\n由Cholesky分解还可以进一步得到平方分解。\n对于正定矩阵A它可以分解为$LDL^T$\n但是D也可以进一步拆分啊。\n再构造一个对角阵$D\u0026rsquo;=diag(\\sqrt{d_{11}},\\sqrt{d_{22}},\u0026hellip;,\\sqrt{d_{nn}})$\n那么D就可以看作是$D\u0026rsquo;D\u0026rsquo;^T$\n所以$A=LDL^T=LD\u0026rsquo;D\u0026rsquo;^TL^T=(LD\u0026rsquo;)(LD\u0026rsquo;)^T$\n如果我设$L\u0026rsquo;=LD\u0026rsquo;$则$A=L\u0026rsquo;L\u0026rsquo;^T$\n此时我们说$L\u0026rsquo;=\\sqrt A$\n这就是A的平方根分解。\n我们这里指的就是这样的矩阵开根号。\n好了，现在来计算一下马氏距离的计算公式。\n因为要先进行标准化，所以先得到X,Y的协方差矩阵$\\Sigma$。\n然后我们来计算马氏距离的平方$D^2(X,Y)=|\\sqrt{\\Sigma}^{-1}X-\\sqrt{\\Sigma}^{-1}Y|_2^2=(\\sqrt{\\Sigma}^{-1}X-\\sqrt{\\Sigma}^{-1}Y)^T(\\sqrt{\\Sigma}^{-1}X-\\sqrt{\\Sigma}^{-1}Y)$\n所以$D^2(X,Y)=(X-Y)^T(\\sqrt{\\Sigma}^{-1})^T\\sqrt{\\Sigma}^{-1}(X-Y)$\n别忘了$\\Sigma$是对称矩阵哦。\n因此$D^2(X,Y)=(X-Y)^T\\Sigma^{-1}(X-Y)$\n所以$D(X,Y)=\\sqrt{(X-Y)^T\\Sigma^{-1}(X-Y)}$\n这就是马氏距离的计算公式了。而当X,Y的协方差矩阵为单位阵I的时候，马氏距离就退化为了欧氏距离。\n方差已知情形的均值检验 在一元情况，针对标题说的这种方差已知的均值检验我们用的是z检验法。\n也就是$H_0:\\mu=\\mu_0,H_1:\\mu\\neq\\mu_0$,方差$\\sigma^2$已知时，寻找枢轴统计量\n$$Z=\\frac{\\mu-\\mu_0}{\\sqrt{\\frac{\\sigma^2}{n}}}$$利用该枢轴变量服从标准正态分布来进行检验。\n你睁大眼睛看看，Z不就是$\\mu$和$\\mu_0$的马氏距离吗？\n可以想象，如果$\\mu=\\mu_0$，那么样本的均值应该和他声称的均值的距离很小才对，这就是方差已知情况的均值检验的原理。\n现在针对多元情况我们仍然是这么做的。\n检验枢轴统计量$\\overline X$与$\\mu_0$的马氏距离的平方是否很小。\n即检验$T^2=n(\\overline X-\\mu_0)^T\\Sigma^{-1}(\\overline X-\\mu_0)$是否很小。\n需要注意的是，前面我们说过，均值$\\overline X$服从的是均值为$\\mu$，方差为$\\frac{\\Sigma}{n}$的正态分布，所以在上面是式子里，那个分子上的n其实是从$\\overline X-\\mu_0$的方差的分母上翻上去的。\n但是，这个统计量服从什么分布呢？\n这个分布由霍特林和许宝禄分别由不同方法导出，不过现在国际上还是叫霍特林T²分布。\n一般地，如果X服从$N_p(\\mu,\\Sigma)$,S服从$W_p(n,\\Sigma)$且X与S独立而且n≥p，则统计量$T^2=nX^TS^{-1}X$服从非中心的霍特林$T^2$分布，记作$T^2(p,n,\\mu)$。当$\\mu=0$时，称为中心霍特林T²分布，记作$T^2(p,n)$。\n显然，这个定义和我们推导的式子可以说是一一对应，从而我们知道刚刚找到枢轴统计量服从$T^2(p,n-1)$分布。\n并且这个T²分布就是一维情况下t分布的推广。\n除此之外，$T^2(p,n)$还可以转化为F分布，这是因为统计量$\\frac{n-p+1}{np}T^2$服从$F(p,n-p+1)$分布。\n从而，协方差已知情况下，均值向量检验也可以用刚刚的定理转化为F检验。\n只需要构造枢轴统计量$\\frac{(n-1)-p+1}{(n-1)p}T^2=\\frac{(n-1)-p+1}{(n-1)p}n(\\overline X-\\mu_0)^T\\Sigma^{-1}(\\overline X-\\mu_0)$，他就服从F(p,n-p)了。\n但是实际上我们用的最多的都不是前面说的两者。\n这是因为，你仔细看看，$T^2=n(\\overline X-\\mu_0)^T\\Sigma^{-1}(\\overline X-\\mu_0)$这是二次型啊，它是服从自由度为p的卡方分布的啊。\n所以我们最常用的其实是卡方检验。\n方差未知的均值检验 那如果是方差未知的均值检验，我们又该怎么做呢？\n其实答案非常显而易见，就是用样本的协方差S估计随机变量的方差。\n例如我们使用霍特林T²检验就构造统计量\n$T^2=n(\\overline X-\\mu_0)^TS^{-1}(\\overline X-\\mu_0)$他就服从$T^2(p,n-1)$了。\n同样地，我们还是可以把他转成F分布，只需要构造枢轴统计量$\\frac{(n-1)-p+1}{(n-1)p}T^2=\\frac{(n-1)-p+1}{(n-1)p}n(\\overline X-\\mu_0)^TS^{-1}(\\overline X-\\mu_0)$，他就服从F(p,n-p)了。\n两样本的均值检验 如果是两样本的均值检验，我们是要按有没有共同已知的协方差阵分情况讨论的。\n待检验的原假设$H_0:\\mu_1-\\mu_2=0$，备择假设$H_1:\\mu_1-\\mu_2\\neq0$\n我已经特意写成了单样本的情况，显然这里只需要检验$\\overline X_1-\\overline X_2$与均值0的关系就可以了，这是一个单样本的均值检验。\n不过需要注意的是$X=\\overline X_1-\\overline X_2$的方差是$\\overline X_1,\\overline X_2$方差的和。\n现在直接将方差代入单样本的霍特林T²检验，形式上你就会得到$T^2=\\frac{(\\overline X_1-\\overline X_2)^T(\\overline X_1-\\overline X_2)}{\\frac{\\Sigma}{n_1}+\\frac{\\Sigma}{n_2}}$\n但我们知道，矩阵怎么会有除法呢？所以要整理一下变成真正的矩阵运算的样子，\n构造$T^2=\\frac{n_1n_2}{n_1+n_2}(\\overline X_1-\\overline X_2)^T\\Sigma^{-1}(\\overline X_1-\\overline X_2)$\n当然，他也服从霍特林T²分布，也服从自由度为p的卡方分布，也可以转化为F分布。\n如果是有共同未知的协方差矩阵的两样本，那和一元情况一样我们用$S_{pl}=\\frac{(n_1-1)S_1+(n_2-1)S_2}{n_1+n_2-2}$替代随机变量的方差即可。\n至于其他情形，要么推导和前面的方法一致要么就过于复杂，在此不再介绍。\n最后提一下，我们在以前学习一元检验的时候就知道，单因素方差分析其实就是多正态总体的均值向量检验。\n而在多元情况下，我们需要使用威尔克斯分布才行。\n如果X服从$W_p(n_1,\\Sigma),n_1\\ge p$,Y服从$W_p(n_2,\\Sigma),\\Sigma\\gt0$，且X,Y独立，则$\\Lambda=\\frac{|X|}{|X+Y|}$服从威尔克斯分布，记作$\\Lambda(p,n_1,n_2)$。\n如果要把威尔克斯分布转为F分布，需要先转为霍特林T²分布再转为F分布，至于这么转。。。\n也比较复杂，需要一张关系表才能表示清楚，反正不是随随便便哪个人能碰的啊哈哈。（彻底陷入疯癫）\n除此之外，巴特莱特（Bartlett）还提出了用卡方分布来近似威尔克斯分布的办法，Rao则研究出了用F分布近似的办法。但都挺麻烦的。。。\n至于你要对多元情况进行方差分析，你得构造似然比统计量，这个已经远远超出大部分人的能力了，还是散了吧。\n协方差阵的检验的话，单正态总体就比较复杂了，构造的检验统计量里既要算e指数，又要搞什么矩阵开方，搞什么行列式云云的，完事最后还只能用极限分布是卡方分布来算，反正也麻烦得要死。。。\n多样本协方差阵的话，只会更加恐怖。（但是有方法）\n区间估计和假设检验的R语言实现 虽然上面扯得看起来很复杂，但是到R语言实现的时候反而很简单。\n我们只以单样本，方差未知时的均值t检验为例简介。因为真的简单到没边了。\n只需要借助函数t.test即可。\n先看帮助文档。\n具体做起来，代码很简单。\n1 2 x \u0026lt;- c(490, 506, 508, 502, 498, 511, 510, 515, 512) # 创建一个包含9个数据的向量x t.test(x, mu = 500) # 对x进行单样本t检验，检验其均值是否等于500 啊，就没了。\nt.test(x, y = NULL, alternative = c(\u0026quot;two.sided\u0026quot;, \u0026quot;less\u0026quot;, \u0026quot;greater\u0026quot;), mu = 0, sigma.x = NULL, sigma.y = NULL, conf.level = 0.95, ...)\n如果简单地说，t.test的语法是这样的。\n这里：\nx：第一个样本数据。 y：第二个样本数据，如果是单样本t检验，则不需要提供。 alternative：备择假设，可以是\u0026quot;two.sided\u0026quot;（双尾检验，默认值）、“less”（左尾检验）或\u0026quot;greater\u0026quot;（右尾检验）。 mu：已知总体均值，默认为0。 sigma.x和sigma.y：已知样本的标准差，如果未提供，则从数据中估计。 conf.level：置信水平，默认为0.95。 当然，实际是t.test比这个强大多了，你想看全部的功能还是参考上面的文档吧。\n我们运行一下，然后解析一下运行结果。\n运行结果上看：\nOne Sample t-test：表示进行的是单样本t检验。 data: x：说明检验的数据是变量x。 t = 2.1979：t检验的枢轴统计量值。 df = 8：枢轴统计量的自由度。 p-value = 0.05919：p值，用于判断统计显著性。通常，如果p值小于0.05，我们认为结果在统计上是显著的。 alternative hypothesis: true mean is not equal to 500：备择假设，你只要翻译一下这句英文就可以了，这里是真实均值不等于500。 95 percent confidence interval:：95%置信区间。 499.7158 511.8398：置信区间的具体范围。 sample estimates:：样本估计值。 mean of x：x的样本均值。 505.7778：x的样本均值具体值。 从这里我们可以看到，t.test同时给出了假设检验需要的p-value和区间估计，所以这一个函数一次性就干了两件事，这也是为什么上一期我没有介绍区间估计的原因。\n方差分析的R语言实现 如果要用R语言实现方差分析也很简单，核心是使用aov函数和gl函数。\ngl函数是用来生成水平的，或者说生成数据。\ngl函数的基本语法如下：\n1 gl(k, n, length.out, labels, ordered = FALSE) k：水平的数量，即因子的不同类别数。 n：每个水平的重复次数。 length.out：结果向量的长度，如果提供，则n会被忽略。 labels：水平的标签，如果未提供，则默认为1到k的整数。 ordered：逻辑值，指示生成的因子是否为有序因子，默认为FALSE。 gl函数返回一个因子向量，其中包含指定数量和重复次数的水平。\n例如：\ngl(3,4)表示有3个水平，每个水平出现4次，然后labels没输入所以是默认值，也就是1,2,3。\n因此他会返回1111 2222 3333这样的因子向量。\n而方差分析最核心的函数是aov。\naov的基本语法是\n1 aov(formula, data, projections = FALSE, qr = TRUE, contrasts = NULL, ...) formula：是指定了模型的结构的公式。例如，y ~ A + B表示y是因变量，A和B是自变量（因素），如果要考虑交互作用的话可以写y~A*B或者y~A+B+A:B data：一个数据框，包含用于分析的数据。 projections：逻辑值，指示是否计算投影矩阵。 qr：逻辑值，指示是否使用QR分解。 contrasts：一个列表，指定因素的水平对比方式。 ...：其他可选参数。 然后aov函数会返回一个对象里面包含结果，但是我们想查看的话通常要结束summary函数。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建一个数值向量X，包含20个观测值 X \u0026lt;- c(25.6, 22.2, 28.0, 29.8, 24.4, 30.0, 29.0, 27.5, 25.0, 27.7, 23.0, 32.2, 28.8, 28.0, 31.5, 25.9, 20.6, 21.2, 22.0, 21.2) # 使用gl函数创建一个因子向量A，表示5个水平，每个水平重复4次 A \u0026lt;- gl(5, 4) # 使用aov函数进行方差分析，模型为X对A的单一因素方差分析 res \u0026lt;- aov(X ~ A) # 使用summary函数查看方差分析的结果 summary(res) 而summary后的报告也非常容易阅读，其实就是一元方差分析中介绍的方差统计表。\nDf：自由度（Degrees of Freedom） A：因素A的自由度，为水平数减1，即5-1=4。 Residuals：残差的自由度，为15。 Sum Sq：平方和（Sum of Squares） A：因素A的平方和，表示由于因素A的不同水平引起的变异。 Residuals：残差的平方和，表示除因素A外其他因素引起的变异。 Mean Sq：均方（Mean Square） A：因素A的均方，为平方和除以自由度，即132.0/4=32.99。 Residuals：残差的均方，为平方和除以自由度，即114.9/15=7.66。 F value：F值，为因素A的均方除以残差的均方，即32.99/7.66=4.306。F值用于检验因素A的显著性。 Pr(\u0026gt;F)：p值，表示在零假设（因素A对结果没有影响）为真时，观察到当前或更极端结果的概率。本例中p值为0.0162，小于0.05，表明因素A对结果有显著影响。 相关分析的R语言实现 这个话题本来不应该出现在这里的，但是这部分实在太短，没地方放。\n在R语言中内置了很多相关系数，例如pearson、kendall、spearman相关系数（没错，统计学里其实有很多相关系数），他们都是用函数cor(x,y,method = \u0026quot;kendall\u0026quot;)给出的。\n这里x,y是待分析的两组数据，method=后面传的是具体的相关系数的名称。\n至于相关分析的检验，其实和前面的没有任何区别，要借助cor.test函数。\n1 2 # 使用cor.test函数检验x和y的Kendall相关系数 cor.test(x, y, method = \u0026#34;kendall\u0026#34;) 你会得到这样的结果\n1 2 3 4 5 6 7 8 ## Kendall\u0026#39;s rank correlation tau ## ## data: x and y ## T = 102, p-value = 1.016e-09 ## alternative hypothesis: true tau is not equal to 0 ## sample estimates: ## tau ## 0.9428571 Kendall's rank correlation tau：表示进行的是Kendall相关系数检验。 data: x and y：说明检验的数据是变量x和y。 T = 102：Kendall检验的T统计量值，它是用于计算相关系数的统计量。 p-value = 1.016e-09：p值，如果这个p值小于0.05，表明x和y之间存在非常显著的相关性。 alternative hypothesis: true tau is not equal to 0：备择假设，表示真实的Kendall相关系数（tau）不等于0，即x和y之间存在相关性。 sample estimates:：样本估计值。 tau：Kendall相关系数的估计值，范围为-1到1。接近1或-1表示强相关性，接近0表示无相关性。本例中tau值为0.9428571，表明x和y之间存在很强的正相关性。 啊就这么索然无味。\n","date":"2024-12-26T11:54:29+08:00","permalink":"https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%902-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","title":"多元统计分析(2) 假设检验"},{"content":"上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。\n在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。\n本系列就专门针对这种多元以上的情况进行分析。\n第一个部分就是对《概率论与数理统计》的拓展，在这门课里最常见的统计方法就是参数估计以及各种假设检验，还有什么方差分析啊云云。\n第一期就从参数估计开始。\n那要唠参数估计的话首先就得有参数吧。\n这个的话直接把一元的扩展出来就可以了。\n多元统计的参量 在多元情况呢，随机变量的维数就不是简单的一维了，所以我们不能用数字来表示随机变量而是要把随机变量化为随机向量。\n一般地，n维随机变量就要用一个n维向量表示即$X=\\begin{pmatrix} x_1 \\ x_2 \\ \u0026hellip;\\x_n \\end{pmatrix}$。\n而我们对某一个随机向量进行m次观测后就会得到m个向量值，我们可以把他拼成一个n行m列的矩阵，称为样本的资料矩阵。\n对于多元随机变量，我们还是用累计分布函数、密度函数等式子来表达其概率分布，并且也只是在定义上进行简单的推广。\n例如，\n对随机变量$X=\\begin{pmatrix} x_1 \\ x_2 \\ \u0026hellip;\\x_n \\end{pmatrix}$，他的累积分布函数就是$F(X)=P(\\vec{x}\\le X)$\n而密度函数f(X)的定义只是把1维随机变量密度函数中的定积分变成n重积分而已。\n而在二维随机变量的时候有所谓的边缘分布，在n维的情况也是一样的。\n我们讨论多元统计，只需要着重于不同点就可以了，相同点只需要以此类推即可。\n至于多元统计的参量，也还是什么均值啊，方差啊之类的。\n对n维随机变量$X=\\begin{pmatrix} x_1 \\ x_2 \\ \u0026hellip;\\x_n \\end{pmatrix}$所谓的均值$E(X)=\\begin{pmatrix} E(x_1) \\ E(x_2) \\ \u0026hellip;\\E(x_n) \\end{pmatrix}$\n方差啊什么的定义则完全没变，只是变成了矩阵运算。\n$D(X)=E[(X-E(X))(X-E(X))^T]$\n协方差\n$cov(X)=E[(X-E(X))(Y-E(Y))^T]$\n需要注意的是，现在方差与协方差是一个矩阵，并且实际上在这样的定义下，方差阵和协方差阵的（i，j）就是对应的一个或两个分量的方差/协方差。\n性质的话，仍然和一维随机变量一致，但是要注意的是，现在要用对等的矩阵表达。\n例如，期望的线性性质$E(AX+BY)=AE(X)+BE(Y)$\n$cov(X,X)=D(X)$\n$COV(AX,BY)=Acov(X,Y)B^T$\n但是样本的期望阵有一个新的性质！\n我们设$\\mu=E(X),\\Sigma=D(X)$而A是常数矩阵\n则有$E(X^TAX)=tr(A\\Sigma)+\\mu^TA\\mu$\n这个性质因为是一维所不具备的所以需要特别注意。\n他的证明倒是非常简单，在两边的x上加上然后减掉$\\mu$就可以了。\n$E(X^TAX)=E((X-\\mu+\\mu)^TA(X-\\mu+\\mu))$\n然后展开里面的乘法。\n原式$=E((X-\\mu)^TA(X-\\mu)+(X-\\mu)^TA\\mu+\\mu^TA(X-\\mu)+\\mu^TA\\mu)$\n中间两项的和是0，而两边的就是结论了，这样就证完了。\n有的时候啊，为了偷懒，我可能还是会用这里定义的$\\Sigma$这一个符号来表示某一个变量的方差$\\mu$来表示均值，需要注意。\n有了协方差，我们知道，协方差矩阵可以看做内积结构，从而可以通过两个向量在协方差这个内积结构下定义（线性）相关系数。\n但是对于多元的情况，我们是比较难写出计算相关系数的矩阵形式的。\n但是我们仍然可以仿照前面的定义，要求变量X,Y相关系数矩阵R的（i，j）元是$X_i,Y_j$的相关系数，从而拼出一个相关系数矩阵。\n虽然我们没有写出相关系数矩阵的矩阵表达，但这样的相关系数矩阵仍然具备一维相关系数的良好性质。\n例如，一个经过标准化（减去均值向量再除以方差即乘以方差的逆）后的数据的协方差矩阵就是原数据的相关系数矩阵。\n前面都是针对随机向量的统计量，那针对经过实验得到的样本，我们还是用同样的方法扩展样本的统计量。\n比如样本的均值/方差/协方差/相关系数/离差矩阵等，他们的（i，j）元仍然是对应两个一元变量的均值/方差/协方差/相关系数/离差矩阵。\n多元正态分布 有了这些统计量，接下来自然是介绍随机变量的分布。在这里，我们只取一个最典型的正态分布的多元情况。\n至于一元的什么卡方分布啊、t分布啊之类的，你在后面就会知道他们的多元版本了。\n这里介绍多元正态分布，只是因为只有多元正态分布的密度函数比较简洁，而且在后续也会使用到。\n我们以均值向量为$\\mu$,方差为$\\sigma$的p维正态分布$N_p(\\mu,\\sigma)$为例，他的密度函数是\n$$f(\\vec x)=\\frac{e^{-\\frac{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)}{2}}}{{(2\\pi)}^{\\frac{p}{2}}|\\Sigma|^\\frac{1}{2}}$$注意：$|\\Sigma|$中的两个竖线是行列式！！！\n额，这已经是多元分布里密度函数比较简洁漂亮的了。。。。\n并且多元正态分布的性质非常好，不仅延续了一元正态分布独立等价于不相关、线性变换后仍是正态分布等性质，并且多元正态分布的边缘分布以及条件分布都是多元正态分布。\n而且你从多元正态分布里取任意几个分量，把他们拼成一个新的随机向量（这叫随机变量的剖分），他也是正态分布。\n这里还要注意一下，既然多元正态分布经过线性变换后还是正态分布，那么正态分布的均值它不就是把原来的几个变换施以线性变换后得来的统计量吗？\n所以如果X服从$N_p(\\mu,\\Sigma)$，则$E(X)$服从$N_p(\\mu,\\frac{1}{n}\\Sigma)$。\n更进一步，样本离差阵$S=\\sum_{i=1}^n(X_i-E(X))(X_i-E(X))^T$里，括号里的$X_i-E(X)$就也服从正态分布，从而S就可以表达为$S=\\sum_{i=1}^nZ_iZ_i^T$，其中Z服从正态分布。这式子你不觉得和卡方分布很像吗？我们如果将$ZZ^T$看做一种“Z的平方”，那这就是p维正态分布的平方和了。（数学上应该是倒过来，实际上一维情况下的所谓正态分布的平方和，应当是$ZZ^T$的特殊情况）\n是的，1928年威沙特就提出了卡方分布的升级版——威沙特分布。\n如果$X_{(a)}=(X_{a1},X_{a2},\u0026hellip;,X_{ap})^T$服从$N_p(\\mu_a,\\Sigma)$且相互独立，那么由$X(a)$拼成的随机矩阵\n$$W_{p\\times p}=\\sum_{a=1}^nX_{(a)}X_{(a)}^T$$就服从非中心威沙特分布$W_p(n,\\Sigma,Z)$，其中$Z=\\sum_{a=1}^n\\mu_a\\mu_a^T$，$\\mu_a$被称为非中心参数。\n特比的，当$\\mu_a=0$时，这个非中心威沙特分布就退化成了中心威沙特分布，记作$W_p(n,\\Sigma)$。\n这个威沙特分布的密度函数非常“简洁”啊，我就不打了，打起来太麻烦了，反正你看了也记不住。\n总之，这个威沙特分布是卡方分布在p维正态分布情况下的推广，所以他也兼容了卡方分布的性质，例如\n威沙特分布的和还是威沙特分布，进一步威沙特分布的二次型还是威沙特分布。\n当然，我们这里引入威沙特分布是为了给样本离差阵找个家，样本离差阵应当服从$W_p(n-1,\\Sigma)$，至于这里自由度为什么是n-1我想一维情况就应该已经说过了才对。是因为离差阵里有均值，而由均值和n-1个$X_i$就能推出剩下的那一个$X_i$了。\n另外，参考其他文献可以知道p维正态分布的均值和样本离差阵独立。\n这些的证明都超级麻烦的，在这里就没法证明了。\n如果你想要使用其他分布的密度函数等信息，其实没必要手算。\n实际上，对于多元统计分析，由于我们的数据都是多元的而且多元分布的密度函数啊计算啊都比较复杂，所以我们其实也不会去手算这些东西的，他本来就应当使用计算机了。\n在统计学里，常用的统计软件是SPSS和R以及Python。\nSPSS使用非常简单，只需要点点点就可以了，我觉得没有太多的好说的地方。\nPython的话，虽然现在也非常火热，但是讲的人很多不缺我一个。\nR语言的话在统计上使用率其实不低，但是讲的人比较少，所以来唠唠这个吧，挑战一下。\nR语言是一款专门为统计而生的软件或者也算是编程语言。\n正因为他是为统计而生的，所以他内置了很多统计学需要使用的工具。\n例如在我们这里，如果你想得到一个分布的密度函数（density function），累积分布函数（distribution function，抱歉这个我实在找不到p这个字母），随机（ random ）数，下$\\alpha$分位数（ quantile function ），只需要使用d/p/r/q+对应分布名称就可以得到了。\n例如在R语言中使用?dnorm命令可以查看dnorm的帮助文档。\n你将看到这四个函数。\nd是密度函数的意思，p是累积分布函数，q是下$\\alpha$分位点，r是随机数。而norm是正态分布的意思。\ndnorm的第一个参数的密度函数的自变量，mean是正态分布的均值（默认为0），sd是标准差（默认为1），参数log或log.p是要不要给概率取对数的意思，默认是不取对数的。\npnorm是累积分布函数，第一个参数q是分布函数的自变量。lower.tail是指要不要“反转”。我们知道分布函数是从-∞积分到x，如果你把lower.tail改成FALSE（或者F），那R语言给你的分布函数就是从x积分到+∞。\nqnorm其实是分位点，他的第一个参数p是自变量，lower.tail如果是默认的TRUE（或者T）那么R语言会给你下$\\alpha$分位点，反之给你上$\\alpha$分位点。\nrnorm则是随机数，n表示你要几个随机数。\n在R语言中内置了超级多分布，我随便举几个例子（并不完整，想看完整的请查阅文档）\n分布名称 R语言函数（密度函数） R语言函数（分布函数） R语言函数（分位数函数） R语言函数（随机数生成） 正态分布 dnorm pnorm qnorm rnorm 二项分布 dbinom pbinom qbinom rbinom 泊松分布 dpois ppois qpois rpois 指数分布 dexp pexp qexp rexp 卡方分布 dchisq pchisq qchisq rchisq F分布 df pf qf rf t分布 dt pt qt rt Beta分布 dbeta pbeta qbeta rbeta Gamma分布 dgamma pgamma qgamma rgamma Weibull分布 dweibull pweibull qweibull rweibull Logistic分布 dlogis plogis qlogis rlogis 对数正态分布 dlnorm plnorm qlnorm rlnorm 威沙特分布 dwish pwish qwish rwish 但是对于某些分布，R语言可能确实没有自带的。\n这时你可以通过命令install.packages(包名)安装第三方扩展库。\n也可以自己书写或采样。\n例如我曾经在B站介绍了逆变换采样法。网址：https://www.bilibili.com/opus/823005107895402761\n今天多送你一个。\n格式点离散化方法 通过格式点离散化方法利用随机变量的密度函数p(x)抽样。\n方法非常简单，分为4步。\n在密度函数p(x)的有效取值范围取N个等距节点 计算$p(x_i)$ 正则化$p(x_i)$，即给每一个$p(x_i)$除以$\\sum_{i=1}^np(x_i)$ 将正则化后的函数看做离散型随机变量的分布律，再有放回地抽样n个数 这样得到的n个数就是n个服从概率密度为p(x)的随机数了。\n我们以标准正态分布为例进行R语言实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 设置节点数量 N \u0026lt;- 1000 # 生成节点，这里以标准正态分布为例，取值范围大致在[-5, 5] nodes \u0026lt;- seq(-5, 5, length.out = N) # 计算每个节点的概率密度 densities \u0026lt;- dnorm(nodes) # 正则化概率密度 normalized_densities \u0026lt;- densities / sum(densities) # 抽样，生成随机数 n_samples \u0026lt;- 1000 samples \u0026lt;- sample(nodes, n_samples, prob = normalized_densities, replace = TRUE) # 使用rnorm函数生成随机数进行比较 rnorm_samples \u0026lt;- rnorm(n_samples) # 绘制直方图进行比较 par(mfrow = c(1, 2)) # 设置绘图区域为1行2列 # 绘制格式点离散化方法的样本直方图 hist(samples, breaks = 30, main = \u0026#34;格式点离散化方法样本\u0026#34;, xlab = \u0026#34;值\u0026#34;, col = \u0026#34;blue\u0026#34;, freq = FALSE) curve(dnorm(x), add = TRUE, col = \u0026#34;red\u0026#34;, lwd = 2) # 绘制rnorm函数生成的样本直方图 hist(rnorm_samples, breaks = 30, main = \u0026#34;rnorm函数样本\u0026#34;, xlab = \u0026#34;值\u0026#34;, col = \u0026#34;blue\u0026#34;, freq = FALSE) curve(dnorm(x), add = TRUE, col = \u0026#34;red\u0026#34;, lwd = 2) 我们来解析一下上面的代码。\n其实也都加了注释了的。\n在R语言中等号=和箭头\u0026lt;-都可以用来赋值。我们这里先把1000赋值给了N，然后seq(-5, 5, length.out = N)表示在-5到+5生成N个等距节点。\n再用densities \u0026lt;- dnorm(nodes)生成节点处的密度函数取值。\nsum(densities)计算了密度函数取值的和。\nnormalized_densities \u0026lt;- densities / sum(densities)就将正则化后的结果赋给了变量normalized_densities。\n接下来我们看最重点的samples \u0026lt;- sample(nodes, n_samples, prob = normalized_densities, replace = TRUE)。\n观察sample的文档。\n可以看到，sample是用于采样的函数。\nsamples \u0026lt;- sample(nodes, n_samples, prob = normalized_densities, replace = TRUE)中nodes是从哪里采样，在格式点离散化方法中是从等距节点中采样。第二个参数n_samples是要取几个采样点。prob是各采样点出现的概率。replace=TRUE表示要进行有放回采样。\n后面的代码只是绘图并且与R语言自带的rnorm进行比较罢了。\n这是最后的绘图，可以看到我们用格式点离散化方法得到的随机数和R语言自带的rnorm非常接近，其频率直方图也和标准正态分布的密度函数（红线）很接近。\n矩估计 好了好了，有了一个具体的分布，我们重要可以开始正题了。\n还记得标题吗？\n标题是参数估计。\n我们从最简单的矩估计开始。\n矩估计的统计依据是大数定律。\n简单说就是样本的矩依概率收敛于样本的矩。\n这么说肯定听不懂啊哈哈。\n一个随机变量X的q阶矩，指的是$E(X^q)$。\n而更多的时候我们会对随机变量进行中心化（也就是减去均值），从而得到中心矩$E((X-E(x))^q)$。\n显然，随机变量的1阶矩就是均值，而2阶中心矩就是方差，这刚好就是他们的定义嘛。\n所以我们最常用的就是这两个。\n例如，你要估计样本均值为$\\mu$，样本方差为S的p维正态分布的均值和方差，按照矩估计的原理直接就得到了，随机变量的均值=样本的均值=$\\mu$，随机变量的方差=样本的二阶中心矩=样本的方差=S。\n这就是矩估计了。\n极大似然估计 下一个常见的估计方法是极大似然估计。\n极大似然估计的统计思想是，一件事情如果发生了我应该往哪里估呢？应该往概率最大的地方估。\n例如，X服从$N_p(\\mu,\\Sigma)$，你通过观测得到他的样本资料矩阵为X=($X_1$,$X_2$,\u0026hellip;,$X_n$)。\n那么为什么你观察到的资料阵是X呢？\n因为这个事件（第一次观测$X=X_1$，然后$X=X_2,X=X_3,\u0026hellip;$）出现的概率最大嘛。\n而各个观测是独立的，所以上述事件发生的概率就是各概率的乘积即上述事件发生的概率是$L=\\prod_{i=1}^nP(X=X_i)$。\n那我们要估计的参数$\\mu,\\Sigma$就是使得L最大的参数。\n在这里L被称为似然函数，但是实际上似然函数是一堆连乘处理起来很麻烦，所以我们常用的是对数似然函数，也就是两边取自然对数得到\n$$\\ln(L)=\\sum_{i=1}^n\\ln(P=(X=X_i))$$现在我们以多元正态分布$N_p(\\mu,\\Sigma)$进行演算。\n先求似然函数，$L=\\prod_{i=1}^nP(X=X_i)=\\prod_{i=1}^n\\frac{e^{-\\frac{1}{2}(X_i-\\mu)^T\\Sigma^{-1}(X_i-\\mu)}}{(2\\pi)^{\\frac{p}{2}}|\\Sigma|^{\\frac{1}{2}}}$\n然后开始计算，分母都是常数，连乘n次就变成n次方。\n分子是e指数，指数相乘底数不变指数相加。\n$L=\\frac{e^{-\\frac{1}{2}\\sum_{i=1}^n(X_i-\\mu)^T\\Sigma^{-1}(X_i-\\mu)}}{(2\\pi)^{\\frac{np}{2}}|\\Sigma|^{\\frac{n}{2}}}$\n然后计算对数似然函数$\\ln(L)=-\\frac{1}{2}\\sum_{i=1}^n(X_i-\\mu)^T\\Sigma^{-1}(X_i-\\mu)-\\frac{np}{2}\\ln(2\\pi)-\\frac{n}{2}\\ln|\\Sigma|$\n接着只需要求参数$\\mu,\\Sigma$使得ln(L)最大就可以了。\n那只需要验证KKT点即可，对于这种无约束极值就是找偏导数为0的点即驻点。\n但是问题来了，这里的参数都是矩阵欸，你会对矩阵求导吗？\n矩阵和向量的导数 所以现在还得倒过来补补基础了。\n最基础的情况是一个多元函数对向量的导数。\n然而，这里有两种写法。一种被称为分母布局，一种被称为分子布局，两种差一个转置。\n对于多元函数$f(x_1,x_2,\u0026hellip;,x_n)$和n维向量$X=(x_1,x_2,x_3,\u0026hellip;,x_n)^T$，\n分母布局的结果是$\\frac{\\partial f}{\\partial X}=(\\frac{\\partial f}{\\partial x_1},\\frac{\\partial f}{\\partial x_2},\\frac{\\partial f}{\\partial x_3},\u0026hellip;,\\frac{\\partial f}{\\partial x_n})^T$\n这也就是所谓的f的梯度$\\nabla f(X)$。\n也就是多元函数的一阶导和梯度等同。\n分子布局就是他的转置，以后我也不再说明，因为我都会使用分母布局。\n而如果f也是一个向量，那情况会麻烦一些。\n我们设$F=(f_1(X),f_2(X),\u0026hellip;,f_m(X))^T=(f_1(x_1,x_2,\u0026hellip;,x_n),f_2(x_1,\u0026hellip;,x_n),\u0026hellip;,f_m(x_1,\u0026hellip;,x_n))^T$\n那么理想的情况是：\n$\\frac{\\partial F}{\\partial X}=(\\frac{\\partial f_1}{\\partial X},..,\\frac{\\partial f_n}{\\partial X})^T$\n然而，这时候$\\frac{\\partial f_1}{\\partial X}$却是一个列向量，上面这玩意根本就不是个矩阵，炸裂！\n所以这时候我们会再进行一个转置，即\n$\\frac{\\partial F}{\\partial X}=((\\frac{\\partial f_1}{\\partial X})^T,..,(\\frac{\\partial f_n}{\\partial X})^T)^T$\n然后再写开，这样就得到了一个矩阵：\n$\\frac{\\partial F}{\\partial X} = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} \u0026amp; \\frac{\\partial f_1}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_1}{\\partial x_n} \\ \\frac{\\partial f_2}{\\partial x_1} \u0026amp; \\frac{\\partial f_2}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_2}{\\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial f_m}{\\partial x_1} \u0026amp; \\frac{\\partial f_m}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_m}{\\partial x_n} \\end{pmatrix}$\n而这个矩阵呢，有一个名字叫做雅可比矩阵，有时记作J。（注意，你看到的文献也许和这个差一个转置，这是因为他采用的是分子布局）\n在多元统计的公式里，多元向量函数的一阶导和雅可比矩阵等同。\n而与多元向量函数的二阶导等同的是黑塞矩阵，但是多元向量函数F（X）的黑塞矩阵是三维的$H = \\begin{pmatrix} \\frac{\\partial^2 f_1}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f_1}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f_1}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_1}{\\partial x_n^2} \\end{pmatrix}, \\begin{pmatrix} \\frac{\\partial^2 f_2}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f_2}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f_2}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_2}{\\partial x_n^2} \\end{pmatrix}, \\ldots, \\begin{pmatrix} \\frac{\\partial^2 f_m}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f_m}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f_m}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f_m}{\\partial x_n^2} \\end{pmatrix}$\n非常炸裂。\n所以你只需要知道普通的多元函数f(X)的黑塞矩阵就可以了。\n$H = \\begin{pmatrix} \\frac{\\partial^2 f}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_n^2} \\end{pmatrix}$\nH的（i，j）元就是对应的二阶混合偏导嘛，也不难的。\n我们也可以来推导看看，他为什么和f(X)的二阶导等同。\n我们设$f=f(X)=f(x_1,x_2,\u0026hellip;,x_n)$\n那么，前面我们说过：\n$\\frac{\\partial f}{\\partial X}=(\\frac{\\partial f}{\\partial x_1},\\frac{\\partial f}{\\partial x_2},\\frac{\\partial f}{\\partial x_3},\u0026hellip;,\\frac{\\partial f}{\\partial x_n})^T$这是一个列向量。\n接着我们再进行一次求导，这就是对列向量进行求导，得到：\n$\\frac{\\partial ^2f}{\\partial X^2}=(\\frac{\\partial }{\\partial X}(\\frac{\\partial f}{\\partial x_1})^T,..,\\frac{\\partial f_n}{\\partial X}(\\frac{\\partial f}{\\partial x_n})^T)^T$\n也就是\n$\\begin{pmatrix} \\frac{\\partial^2 f}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_n^2} \\end{pmatrix}=H$\n所以\n$\\frac{\\partial ^2f}{\\partial X^2}=\\begin{pmatrix} \\frac{\\partial^2 f}{\\partial x_1^2} \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\ \\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_2^2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial^2 f}{\\partial x_n \\partial x_1} \u0026amp; \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2 f}{\\partial x_n^2} \\end{pmatrix}=H$\n这也是为什么我们说，对普通的一元函数来说，它的黑塞矩阵和二阶导等同。\n如果接下来，你要对f求三阶导，那就是对黑塞矩阵求导，自然你会得到一个三维矩阵，也非常炸裂，就不多说了。\n雅可比矩阵和黑塞矩阵在这个系列中只会出现在理论推导里，而实际运算的时候不会涉及到。\n在实际计算的时候我们更多地会遇见下面几个公式，可以自己用上面的定义推导一下，都不难。\n$\\frac{\\partial (AX)}{\\partial X}=A^T$（如果是分子布局则不用转置）\n$\\frac{X^TAX}{\\partial X}=AX+A^TX$，特别的当A为对称阵的时候我们知道$X^TAX$为二次型，此时$\\frac{X^TAX}{\\partial X}=AX+A^TX=2AX$\n$\\frac{\\partial (X^TAX)}{\\partial A}=X^TX$\n$\\frac{\\ln|A|}{\\partial A}=A^{-1}$\n至于求导法则，都是兼容的。\n但是有一个要注意的，就是链式法则。\n在一元情况下我们说$\\frac{dy}{dx}=\\frac{dy}{du}\\frac{du}{dx}$，这个式子看着特别漂亮，似乎可以把du约掉一样，但是在多元的时候情况就不一样了。\n$\\frac{\\partial y}{\\partial x}=\\frac{\\partial u}{\\partial x}\\frac{\\partial y}{\\partial u}$\n这看起来只是把式子右边两个导数换了一下位置，其实不是这样的。\n在多元情况下，你也看到了，求导的结果是一个矩阵，矩阵乘法是不满足交换律的。实际上链式法则就应该是我们下面给出的这个形式而不是一元的那个漂亮的形式。那个形式反而是用一元情况下数的交换律交换出来的。这也是为什么前面反复强调，求导这里你不能把$\\frac{dy}{dx}$简单地看做微分dy除以微分dx，这只是形式上的结果而已。同样你也不能认为链式法则里我们只是在分式上约掉了du，这也只是一元链式法则在形式上的结果而已。\n多元正态分布的极大似然估计 好了，现在我们继续推导多元正态分布的极大似然估计吧。\n前面我们已经推导到，多元正态分布的极大似然估计只需要找到$\\mu,\\Sigma$使得下面这个对数似然函数最大即可。\n$\\ln(L)=-\\frac{1}{2}\\sum_{i=1}^n(X_i-\\mu)^T\\Sigma^{-1}(X_i-\\mu)-\\frac{np}{2}\\ln(2\\pi)-\\frac{n}{2}\\ln|\\Sigma|$\n那么我们要做的是求对数似然函数的驻点，就是要解方程$\\frac{\\partial \\ln(L)}{\\partial \\mu}=0$和$\\frac{\\partial \\ln(L)}{\\partial \\Sigma}=0$\n我们先来算$\\frac{\\partial \\ln(L)}{\\partial \\mu}$，和$\\mu$有关的只有$-\\frac{1}{2}\\sum_{i=1}^n(X_i-\\mu)^T\\Sigma^{-1}(X_i-\\mu)$这一项，而这一项里求和号可以和求导交换位置，求和号内部则是一个二次型的导数，利用前面的公式$\\frac{X^TAX}{\\partial X}=AX+A^TX=2AX$即可。\n所以$\\frac{\\partial \\ln(L)}{\\partial \\mu}=-\\frac{\\partial \\ln(L)}{\\partial (X_i-\\mu)}=\\sum_{i=1}^n\\Sigma^{-1}(X_i-\\mu)=0$\n同理$\\frac{\\partial \\ln(L)}{\\partial \\Sigma}=\\frac{1}{2}\\sum_{i=1}^n(X_i-\\mu)(X_i-\\mu)^T(\\Sigma^{-1})^2-\\frac{n}{2}\\Sigma^{-1}=0$\n然后解方程就可以了，解得$\\mu=\\frac{1}{n}\\sum_{i=1}^nX_i=E(X),\\Sigma=\\frac{1}{n}\\sum_{i=1}^n(X_i-E(X))(X_i-E(X))^T=\\frac{1}{n}S$\n上面的解里，第一个等式是直接求解的结果，第二个等式则是将结果用我们前面说的样本的统计量替换了。\n我们可以看到，多元正态分布均值的极大似然估计就是样本均值向量，而方差则是$\\frac{1}{n}$乘以样本离差阵。\n需要注意的是，我们前面定义的样本协方差阵是$\\frac{1}{n-1}S$而不是这里的$\\frac{1}{n}S$（当然也有教材直接把$\\frac{1}{n}$定义为样本协方差阵的）。\n但是我们更要注意的是，只有$\\frac{1}{n-1}S$才是方差的无偏估计，这里我们用极大似然估计推导出来的$\\frac{1}{n}S$只是方差的一致估计（即当n趋于无穷大时结果和无偏估计一致）。\n牛顿法求数值解 在上面的过程中我们可以看到，无论是用矩估计还是极大似然估计，其核心都是求解方程组，然而大多数多元分布的密度函数都超级复杂，从而你根本解不动方程。我们在上个系列（数值计算方法中）已经介绍过如何用迭代法求解一维非线性方程组的数值解了，在这里简单地推广一下。\n一维情况下方程f(x)=0有牛顿迭代格式$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$，而到了多元情况我们会得到n个方程即\n$f_1(X)=0,f_2(X)=0,\u0026hellip;,f_n(X)=0$\n我们知道，可以用同一个向量$F(X)=0$表达，这时的情况就和一元的f(x)=0在形式上差不多了。\n迭代格式的话也是一样的，也就是直观上不严谨地说$X_{k+1}=X_k-\\frac{F(X_k)}{F\u0026rsquo;(X_k)}$。\n但是前面我们已经说过，对向量函数对另一个向量X的所谓导数$\\frac{\\partial F}{\\partial X} = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} \u0026amp; \\frac{\\partial f_1}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_1}{\\partial x_n} \\ \\frac{\\partial f_2}{\\partial x_1} \u0026amp; \\frac{\\partial f_2}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_2}{\\partial x_n} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ \\frac{\\partial f_m}{\\partial x_1} \u0026amp; \\frac{\\partial f_m}{\\partial x_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial f_m}{\\partial x_n} \\end{pmatrix}$是雅可比矩阵J(X)。\n那么就炸裂了，式子里所谓的除以F（X)的“导数”到底是左乘J的逆还是右乘？\n答案是左乘。\n$X_{k+1}=X_{k}-J^{-1}(X_k)F(X_k)$\n而如果是极大似然估计，我们最终是要求导函数的零点，也就是F（X）本身就是一阶导了，那么再代入迭代格式就是要用所谓的一阶导替代f（x）用所谓的二阶导替代f\u0026rsquo;（x）。\n我们知道，一元情况的一阶导和雅可比矩阵等同，一元情况的二阶导和黑塞矩阵等同。\n所以如果我想直接用牛顿法求普通的多元函数f(X)的极值点的话，前面我们说过对多元函数f(X)和一阶导等同的是梯度$\\nabla f(X)$，和二阶导等同的是黑塞矩阵H（X）。\n从而求普通多元函数f(X)的极值点，就是解方程$\\nabla f(X)=0$\n再用牛顿法求数值解就得用迭代格式：\n$X_{k+1}=X_k-H^{-1}(X_k)\\nabla f(X)$\nR语言实现 可以看到，无论是矩估计还是极大似然估计，其本身并没有难点，最后的落脚点都是如何求解一个非线性方程的数值解。\n这时候你可以MATLAB启动，也可以继续用R语言。\n$$ \\begin{cases} x_1^2 + x_2^2 - 5 = 0, \\\\ (x_1 + 1)x_2 - (3x_1 + 1) = 0. \\end{cases} $$要用牛顿迭代法实现，就得先求其一阶导也就是雅可比矩阵。\n$$J(x) = \\begin{pmatrix} 2x_1 \u0026 2x_2 \\\\ x_2 - 3 \u0026 x_1 + 1 \\end{pmatrix}$$然后就可以写代码了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 定义一个函数fun，用于计算非线性方程组的函数值和雅可比矩阵 fun \u0026lt;- function(x){ # 计算非线性方程组的函数值 f \u0026lt;- c(x[1]^2 + x[2]^2 - 5, # 第一个方程 (x[1] + 1) * x[2] - (3 * x[1] + 1)) # 第二个方程 # 计算非线性方程组的雅可比矩阵 J \u0026lt;- matrix(c(2 * x[1], 2 * x[2], # 第一行的梯度 x[2] - 3, x[1] + 1), # 第二行的梯度 nrow = 2, byrow = TRUE) # 确定矩阵的行数，并按行填充 # 返回函数值和雅可比矩阵的列表 list(f = f, J = J) } # 定义一个函数newton，用于实现牛顿法求解非线性方程组 newton \u0026lt;- function(fun, x, eps = 1e-5, max.iter = 100){ # fun是待求解的非线性方程组，x是初始点，eps是判断迭代收敛的条件，这里认为两次迭代的根的差小于1e-5为收敛 # max.iter为最大迭代次数，如果超过这个迭代次数都没有收敛则认为牛顿法求解失败。 iter \u0026lt;- 0 # 初始化迭代次数 flag \u0026lt;- 0 # 初始化收敛标志为不收敛0 # 开始迭代，直到达到最大迭代次数 while(iter \u0026lt; max.iter){ x1 \u0026lt;- x # 保存当前迭代点 obj \u0026lt;- fun(x) # 计算当前点的函数值和Jacobi矩阵 # 更新x值，使用当前的函数值和Jacobi矩阵 x \u0026lt;- x - solve(obj$J, obj$f) # 检查是否收敛，即新x值与旧x值的2范数是否小于阈值eps if(norm(x1 - x, \u0026#34;2\u0026#34;) \u0026lt; eps){ flag \u0026lt;- 1 # 设置收敛标志为收敛1 break # 如果收敛，则跳出循环 } iter \u0026lt;- iter + 1 # 增加迭代次数 } # 返回结果列表，包括根、迭代次数、收敛标志和最终的函数值 list(root = x, iter = iter, index = index, val = fun(x)$f) } # 使用牛顿法求解非线性方程组，初始点为c(0,1) newton(fun, c(0,1)) 上面的代码注释已经很详细了。\n你需要注意的是，在这里雅可比矩阵是我们手动求解的。\n然后x \u0026lt;- x - solve(obj$J, obj$f)，这里的solve函数其实是用来解线性方程组AX=B的。\n我们知道AX=B的解就是$A^{-1}B$，所以这里可以用solve来求$J^{-1}F$。\nnorm(x1 - x, \u0026quot;2\u0026quot;)这里的norm用于求解矩阵或向量的范数，后面的2表明求解的是2-范数。范数的概念已经在上一个系列（数值计算方法）说明了，这里就不再废话了。\n虽然用上面的方法可以求解非线性方程组的根，但是每次都这么计算一通非常麻烦。\n我们可以调用R语言自带的包直接求解。\n针对一元非线性方程，直接使用uniroot函数即可求解。\n1 2 3 4 f\u0026lt;-function(x) { x^3-x-1 } uniroot(f,c(1,2)) 运行结果的话是这样的。\n这里函数f是$x^3-x-1$，就表明我们要求解$x^3-x-1=0$的根。\n我们向uniroot传入的第二个参数是零点可能存在的区间[1,2]。\n然后我们得到的结果是一个列表，包含以下元素：\nroot: 这是函数 f 的根，即在区间 [1, 2] 内使得 f(x) = 0 的 x 值。在这个例子中，根的值是 1.324718。 f.root: 这是函数 f 在找到的根处的函数值。理论上，这个值应该接近于零，因为根就是函数值为零的点。在这个例子中，函数值是 -5.634261e-07，这是一个非常接近于零的数，表明找到了一个很好的近似根。 iter: 这是 uniroot 函数找到根所需的迭代次数。在这个例子中，进行了7次迭代。 init.it: 这是初始迭代次数，但在您的结果中显示为 NA，这可能是因为 uniroot 函数没有提供这个信息。 estim.prec: 这是估计的精度，即函数值在根处的绝对误差的上界。在这个例子中，估计精度是 6.103516e-05，这意味着函数值在根处的误差不会超过这个值。 总结来说，uniroot 函数在区间 [1, 2] 内找到了函数 f(x) = x^3 - x - 1 的一个根，大约在 x = 1.324718，并且在这个点处函数值非常接近于零，表明找到了一个有效的根。\n(感谢智谱chatglm的回答，帮我省了几秒钟的打字时间，要是他能学会解数学题就好了啊哈哈，那我直接天天用ai发文啊哈哈哈哈哈哈哈）\n如果你想求解多元非线性方程组，那只能借助第三方库了。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 安装rootSolve库，如果尚未安装的话 if (!require(rootSolve, quietly = TRUE)) { install.packages(\u0026#34;rootSolve\u0026#34;) } # 加载rootSolve库 library(rootSolve) # 定义一个函数fun2，用于计算非线性方程组的函数值 fun2 \u0026lt;- function(x) { # 方程组由两个方程组成 c(x[1]^2 + x[2]^2 - 5, # 第一个方程：x1^2 + x2^2 = 5 (x[1] + 1) * x[2] - (3 * x[1] + 1)) # 第二个方程：(x1 + 1) * x2 = 3 * x1 + 1 } # 使用multiroot函数求解非线性方程组，初始点为c(0,1) multiroot(fun2, c(0, 1)) # 结果解释： # $root # [1] 1 2 # 这表示找到的方程组的根是 x1 = 1, x2 = 2 # $f.root # [1] 5.713896e-07 1.923389e-07 # 这表示在找到的根处，方程组的函数值非常接近于零，分别是 5.713896e-07 和 1.923389e-07 # $iter # [1] 6 # 这表示找到根所需的迭代次数是6次 # $estim.precis # [1] 3.818642e-07 # 这表示估计的精度，即函数值在根处的绝对误差的上界是 3.818642e-07 AI直接生成了这么完备的解释，我也只能闭嘴了。\n但是我们其实还可以更懒。\n上面的代码只对矩估计比较方便，但是对极大似然估计，我们还得自己来求解一阶导，非常麻烦。\n所以我们应该直接使用R语言提供的优化问题的函数。\n一元情况直接调用R语言提供的optimize函数，不过他默认求的是最小值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 定义一个函数f，该函数计算cos(x^2) f \u0026lt;- function(x) { cos(x^2) } # 使用optimize函数寻找函数f在区间[0, 2]内的最小值 result_min \u0026lt;- optimize(f, lower = 0, upper = 2) # 结果解释： # $minimum # [1] 1.772453 # 这表示函数f在区间[0, 2]内的最小值点大约在x = 1.772453 # $objective # [1] -1 # 这表示在最小值点处，函数f的值为-1 # 使用optimize函数寻找函数f在区间[0, 2]内的最大值，设置maximum=TRUE result_max \u0026lt;- optimize(f, lower = 0, upper = 2, maximum = TRUE) # 结果解释： # $maximum # [1] 7.8628e-05 # 这表示函数f在区间[0, 2]内的最大值点大约在x = 7.8628e-05 # $objective # [1] 1 # 这表示在最大值点处，函数f的值为1 如果是找普通的多元函数的极小值就可以借助nlm函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 定义一个函数fr，该函数接受一个向量x，并计算一个关于x的代价函数 fr \u0026lt;- function(x) { x1 \u0026lt;- x[1] # 提取x的第一个元素 x2 \u0026lt;- x[2] # 提取x的第二个元素 # 计算并返回代价函数的值 100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } # 使用nlm函数找到函数fr的最小值，初始猜测为c(-1.2, 1) result \u0026lt;- nlm(fr, c(-1.2, 1)) # 结果解释： # $minimum # [1] 3.973766e-12 # 这表示函数fr在找到的最小值点处的函数值，非常接近于0，说明找到了一个很好的最小值点 # $estimate # [1] 0.999998 0.999996 # 这表示函数fr的最小值点估计，即x1约为0.999998，x2约为0.999996 # $gradient # [1] -6.539320e-07 3.336018e-07 # 这表示在最小值点处的梯度，梯度接近于0，说明该点可能是局部最小值点 # $code # [1] 1 # 这表示nlm函数的退出代码，1表示收敛 # $iterations # [1] 23 # 这表示找到最小值所需的迭代次数，这里进行了23次迭代 当然，你如果还是想用刚刚介绍的牛顿法手搓也是可以的。\n第一步还是定义要求解的函数\n1 2 3 4 5 6 7 # 定义fr函数，它接受一个向量x作为输入 fr \u0026lt;- function(x) { x1 \u0026lt;- x[1] # 提取x的第一个元素，赋值给x1 x2 \u0026lt;- x[2] # 提取x的第二个元素，赋值给x2 # 计算并返回fr函数的值 100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } 然后参考迭代格式：\n$X_{k+1}=X_k-H^{-1}(X_k)\\nabla f(X)$\n我们得先求f的梯度，你可以自己手动求解，也可以用我们在前一个系列数值计算方法里的数值微分方法求解。\n我们这里就用最简单的差分法求解了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 定义一个非常小的数delta，用于数值微分 delta \u0026lt;- 1e-5 # 定义初始点x0 x0 \u0026lt;- c(1.5, 1.5) # 使用差分法计算梯度向量的第一个分量（关于x1的偏导数） grd.x \u0026lt;- (fr(c(1.5 + delta, 1.5)) - fr(x0)) / delta # 使用差分法计算梯度向量的第二个分量（关于x2的偏导数） grd.y \u0026lt;- (fr(c(1.5, 1.5 + delta)) - fr(x0)) / delta # 将计算得到的梯度分量组合成一个向量 (grd \u0026lt;- c(grd.x, grd.y)) ## [1] 451.0105 -149.9990 同样地，你也可以使用第三方库直接计算梯度和黑塞矩阵。\n1 2 3 4 5 6 7 # 加载numDeriv包以使用其函数来计算梯度向量和黑塞矩阵 library(numDeriv) # 使用numDeriv包中的grad函数计算梯度向量 grad_val \u0026lt;- grad(fr, c(1.5, 1.5)) # 使用numDeriv包中的hessian函数计算黑塞矩阵 hess_val \u0026lt;- hessian(fr, c(1.5, 1.5)) 这些代码还是比较简单的。\n我们这里给一个利用numDeriv包求解梯度和黑塞矩阵再用牛顿法求解的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # 加载numDeriv包，用于计算梯度向量和黑塞矩阵 library(numDeriv) # 定义牛顿法函数 newton \u0026lt;- function(func, x0, eps=1e-5, n.max=100){ x \u0026lt;- x0 # 初始化x为初始猜测值x0 n \u0026lt;- 0 # 初始化迭代次数计数器 # 开始迭代过程 while( max(abs(grad(func, x))) \u0026gt; eps \u0026amp;\u0026amp; n \u0026lt; n.max ){ # 当梯度向量的最大绝对值大于阈值eps时继续迭代 # 计算梯度向量 g \u0026lt;- grad(func, x) # 计算黑塞矩阵 h \u0026lt;- hessian(func, x) # 更新x值，使用黑塞矩阵的逆乘以梯度向量 x \u0026lt;- x - solve(h, g) # 更新迭代次数 n \u0026lt;- n + 1 } # 如果达到最大迭代次数，则输出警告信息 if(n == n.max){ cat(\u0026#39;牛顿法求解失败\u0026#39;) } # 返回牛顿法的结果，包括根、迭代次数和函数在根处的值 list(root=x, iter=n, val=func(x)) } # 定义函数fr fr \u0026lt;- function(x){ x1 \u0026lt;- x[1] # 提取x的第一个元素 x2 \u0026lt;- x[2] # 提取x的第二个元素 # 计算并返回函数fr的值 100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } # 使用牛顿法求解函数fr的根，初始猜测为c(2, -2) result \u0026lt;- newton(func = fr, x0=c(2, -2)) ","date":"2024-12-22T16:31:40+08:00","permalink":"https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%901-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","title":"多元统计分析(1) 参数估计"},{"content":"上次讲了线性方程组求解的迭代法，这次理所应得地就是来聊聊直接求解了。\n约当消去法和高斯消去法 其实线性方程组咱们在线性代数/高等代数里都聊过的，我自己也出了专门的线性方程组求解的专利而且还重制了一版，各位观众应该是比较熟悉了的才对。(线性方程组专栏链接在这里)\n这两个方法其实就是我们之前就会的，什么用初等行变换把矩阵化成行阶梯型行最简型甚至相抵标准型之类的。\n就是回带的时间不一样而已，绝当消去法是直接一把梭，消元到行最简型然后直接就能观察出解了，而高斯消去法只消到行阶梯型然后回代解一元一次方程。\n所以这两个方法我觉得无需多言（啊，看见这四个字又想玩梗了）。\n本文的重点在于利用矩阵分解来求解方程组。\nLU分解 这一切的基石来源于LU分解。\n不过在这里我要澄清一个观念。\n在线性代数/高等代数里我们强调过，矩阵乘法的几何意义是矩阵对应的线性变换的乘法（也就是复合），所以在这种意义上，所谓的矩阵分解应该是把一个矩阵分解成若干个矩阵的乘积。\n而在上文中，我曾经说把一个矩阵A分解为上三角U、下三角L、对角阵D使得A=D-L-U，这不是我们这里说的矩阵分解。这里所谓的分解只是从代数的角度或者说凑数的角度看把一个矩阵拆分成三个矩阵的和，是没有几何意义的。\n好，我们现在澄清完了可以开始LU分解的内容了。\nLU分解也是一种直接求解的方法，他是这样想的。\n我们对AX=b的系数矩阵A进行预处理，把他分解成下三角矩阵L和上三角矩阵U的乘积。\n即找一个下三角矩阵L和上三角矩阵U使得A=LU\n然后AX=b就是LUX=b，也就是L(UX)=b。\n为什么要这么做呢？\n因为这样我们可以换元，令y=UX\n则Ly=b是轻易求解的，UX=y也是轻易求解的。\n例如\n$ A=\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 5 \u0026amp; 2 \\ 3 \u0026amp; 1 \u0026amp; 5 \\end{pmatrix},b=\\begin{pmatrix} 14 \\ 18 \\ 20 \\end{pmatrix} $\n我们可以进行LU分解\n$ A=\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 5 \u0026amp; 2 \\ 3 \u0026amp; 1 \u0026amp; 5 \\end{pmatrix}=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ 3 \u0026amp; -5 \u0026amp; 1 \\end{pmatrix}\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 0 \u0026amp; 1 \u0026amp; -4 \\ 0 \u0026amp; 0 \u0026amp; 24 \\end{pmatrix}$\n显然前面那个矩阵就是L，后面那个是U。\n我们先解Ly=b，从上往下看第一个方程$y_1=14$直接解出来了。\n第二个方程$2y_1+y_2=18$，很容易解出$y_2=-10$。\n然后是第三个方程$3y_1-5y_2+y_3=20$，解出$y_3=-72$。\n果然容易求解吧。\n然后求解UX=y\n也就是\n$\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 0 \u0026amp; 1 \u0026amp; -4 \\ 0 \u0026amp; 0 \u0026amp; 24 \\end{pmatrix}X=\\begin{pmatrix} 14 \\ -10 \\ -72 \\end{pmatrix}$\n从下往上看，第一个方程$24x_3=-72,x_3=3$，\n第二个方程$x_2-4x_3=-10,x_2=2$，\n第三方程$x_1+2x_2+3x_3=14,x_1=1$。\n现在就很轻易地解出了方程。\n但是问题来了，怎么进行LU分解呢？\n我们以分解$A=\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 2 \u0026amp; 2 \u0026amp; -2 \\ -2 \u0026amp; -3 \u0026amp; 13 \\end{pmatrix}$为例，先进行初等行变换。\n但是这里我们只能做把某一行的k倍加到另一行，从而把A化成上三角矩阵。\n$A=\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 2 \u0026amp; 2 \u0026amp; -2 \\ -2 \u0026amp; -3 \u0026amp; 13 \\end{pmatrix}$\n首先，第一行的一半加到第三行，然后第一行的-0.5倍加到第二行，然后你给4 2 -2这三个元素画圈。\n你会首先得到矩阵\n$\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 0 \u0026amp; 1 \u0026amp; -1 \\ 0 \u0026amp; -2 \u0026amp; 12 \\end{pmatrix}$\n然后再把第二行的2倍加到第三行，给1 -2画圈。\n得到\n$\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 0 \u0026amp; 1 \u0026amp; -1 \\ 0 \u0026amp; 0 \u0026amp; 10 \\end{pmatrix}$\n这个就是U了，当然最后记得给10画圈。\n那L呢？\n我们只做了初等行变换对吧，我们知道给矩阵做初等行变换等价于在左边左乘一系列初等矩阵，L就是这些初等矩阵的乘积。\n为了保证这些初等矩阵的乘积是下三角矩阵所以我们才要求你只能做把某一行的k倍加到另一行这一种变换。\n那么这个L要不要自己手动去整理一下找到我们乘了哪些初等矩阵然后再计算乘积呢？不用这么麻烦。\n前面不是让你画圈了吗？\n你把画圈的元素拼起来，得到\n$\\begin{pmatrix} 4 \u0026amp; 0 \u0026amp; 0 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ -2 \u0026amp; -2 \u0026amp; 10 \\end{pmatrix}$\n这个矩阵，还不是L啊哈哈。\n我们得到的L比这个还要强其实。\n我们的L是一个单位下三角！\n你要做的是，每一列乘以某个数把他变成单位下三角，也就是第一列除以4，第二列除以1，第三列除以10得到\n$\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ \\frac{1}{2} \u0026amp; 1 \u0026amp; 0 \\ -\\frac{1}{2} \u0026amp; -2 \u0026amp; 1 \\end{pmatrix}$\n这个才是L。\n我们这里分解出来的L是单位下三角，其实你也可以分解出单位上三角。\n换言之，LU分解是不唯一的。你也可以分解成两个普通的上下三角矩阵。\n所以为了保证分解的唯一性，我们会要求L或者U的其中一个是单位上下三角。\n如果L是单位下三角这样的分解叫Doolittle分解，U是单位上三角则这样的分解是Crout分解。\nCholoesky分解 除了LU分解之外还有办法。\n不过我们得给矩阵A加一些条件了。我们要求A是正定阵。\n如果A是正定矩阵我们会得到特殊的结论。\n先对A进行一次LU分解，A=LU\u0026rsquo;，接着如果我们对U\u0026rsquo;再次进行LU分解，你会得到$U’=DL^T$。\n所以正定矩阵A可以分解为$LDL^T$。\n这个就是Choloesky分解。\n其中D很特殊，D是一个对角阵，也就是说$U\u0026rsquo;$的LU分解分解出的下三角矩阵是一个对角阵而L是单位下三角矩阵。\n所以你应该意识到，两次LU分解进行的是不同的LU分解，第一次把L分解为单位下三角，也就是进行Doolittle分解，此时U‘是一般的上三角矩阵。\n然后对U\u0026rsquo;进行Crout分解，把分解出来的上三角化为单位上三角并且这个单位上三角刚好是$L^T$，此时下三角矩阵刚好是对角阵。\n所以如果是正定矩阵，你可以对A先进行一次LU分解，得到L，那么他的Choloesky分解里就只有对角阵D不知道了。\n而对角阵D其实也是很容易就知道的。\n因为U’你是知道的，而$U\u0026rsquo;=DL^T$，我们可以用这个关系得到D。\n例如$A=\\begin{pmatrix} 3 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 2 \u0026amp; 0 \\ 3 \u0026amp; 0 \u0026amp; 12 \\end{pmatrix}$\n进行一次LU分解得到\n哦对了，这个是这个网站计算得到的。（网址https://matrixcalc.org/zh-CN/)\n然后我们知道L和U\u0026rsquo;了\n由于U\u0026rsquo;=DL，你可以先用待定系数法求D。\n自己试试看，然后你就会发现好像不用那么麻烦了。\n因为\n$U\u0026rsquo;=\\begin{pmatrix} d_{11} \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; d_{22} \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; d_{33} \\end{pmatrix}\\begin{pmatrix} 1 \u0026amp; \\frac{2}{3} \u0026amp; 1 \\ 0 \u0026amp; 1 \u0026amp; -3 \\ 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix}$\n我们只算U’的对角元。\n第一行乘第一列，就是$d_{11}$\n第二行乘以第二列就是$d_{22}$\n第三行乘以第三列就是$d_{33}$\n所以D的对角元是啥？不就是U‘的对角元？所以D也可以直接看出来。\n平方根法（平方分解） 由Cholesky分解还可以进一步得到平方分解。\n对于正定矩阵A它可以分解为$LDL^T$\n但是D也可以进一步拆分啊。\n再构造一个对角阵$D\u0026rsquo;=diag(\\sqrt{d_{11}},\\sqrt{d_{22}},\u0026hellip;,\\sqrt{d_{nn}})$\n那么D就可以看作是$D\u0026rsquo;D\u0026rsquo;^T$\n所以$A=LDL^T=LD\u0026rsquo;D\u0026rsquo;^TL^T=(LD\u0026rsquo;)(LD\u0026rsquo;)^T$\n如果我设$L\u0026rsquo;=LD\u0026rsquo;$则$A=L\u0026rsquo;L\u0026rsquo;^T$\n此时我们说$L\u0026rsquo;=\\sqrt A$\n这就是A的平方根分解。\n只不过，相比于上一种方法这个方法其实计算量更大。\n这个叫平方根法，前面那种方法我们叫改进平方根法。\n啊哈哈，这次反而是先推出改进版的方法。\n追赶法 之前我们就说过，三对角矩阵可以用追赶法来求解。\n现在重要可以来唠唠追赶法了。\n追赶法其实就是对三对角矩阵的LU分解。\n但是三对角矩阵的LU分解也是特殊的。\n例如计算\n$A=\\begin{pmatrix} 2 \u0026amp; -1 \\ -1 \u0026amp; 2 \u0026amp; -1 \\ \u0026amp; -1 \u0026amp; 2 \u0026amp;-1 \\\u0026amp; \u0026amp; -1 \u0026amp;2 \u0026amp;-1\\\u0026amp; \u0026amp; \u0026amp; -1 \u0026amp;2 \\end{pmatrix}$\n它的L一定是这样的形式\n$L=\\begin{pmatrix} \\alpha_1 \u0026amp; \\ -1 \u0026amp; \\alpha_2 \\ \u0026amp; -1 \u0026amp; \\alpha_3 \\\u0026amp; \u0026amp; -1 \u0026amp;\\alpha_4 \\\u0026amp; \u0026amp; \u0026amp; -1 \u0026amp;\\alpha_5 \\end{pmatrix}$\n其中最下面那排-1啊，是和A的最下面那排一样的。\nA的U啊，是单位上三角\n$U=\\begin{pmatrix} 1 \u0026amp; \\beta_1 \\ \u0026amp; 1 \u0026amp; \\beta_2 \\ \u0026amp; \u0026amp; 1 \u0026amp;\\beta_3 \\\u0026amp; \u0026amp; \u0026amp;1 \u0026amp;\\beta_4\\\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\end{pmatrix}$\n那么关键就是证明求$\\alpha_i$和$\\beta_i$了呗。\n方法是直接把LU相乘，毕竟LU=A嘛\nL的第一行乘以U第一列得到$\\alpha_1=2$\n然后我们再算$\\beta_1$\n也就是L的第一行乘以U的第二列，得到$\\beta_1$\n然后我们算$\\alpha_2$\n用L的第二行乘以U的第二列。\n以此类推。\n你会发现我们是先算$\\alpha_i$再算$\\beta_i$\n所以形象的说就是有个追赶的过程。\n因此这个方法的名字叫追赶法。\n至于你说，我不想用矩阵乘法这么麻烦来算，其实这玩意儿有公式，但是我个人觉得反而更麻烦了，而且公式很难记忆，想知道的话还是自己上网查吧。\n最后呢，矩阵分解的气氛都烘托到这里了，再多聊了五毛钱的。\n奇异值分解 矩阵分解里有两个非常重要的分解，其中一个是谱分解，这个在所有线性代数/高等代数课堂上都会介绍，但是奇异值分解却鲜有说明的。\n我们知道，矩阵的几何意义是线性变换，而线性变换其实只有两种。\n一种是伸缩变换，他只改变向量的长度，也就是只伸缩。\n另一种是正交变换，也就是旋转，它不改变向量的长度以及几何图形的形状。\n而奇异值分解做的事情是，把一个一般的线性变换A分解成伸缩变换+旋转变换。\n我们知道，旋转变换的矩阵是正交阵Q（对复数域的矩阵，旋转变换的矩阵是正规阵），而伸缩变换的矩阵是对角阵D。\n由于线性代数课程不介绍复数域矩阵，在此对正规矩阵进行说明。\n对于实数域的矩阵有一个操作叫转置，所谓A的转置$A^T$，就是把A的第i行变到第i列。\n而在复数域的矩阵，和转置对等的叫共轭转置$A^H$，他首先把A中的所有元素取共轭复数，然后再进行转置。\n由于实数的共轭复数是实数本身，所以对实矩阵的转置其实也可以看做是共轭转置。\n而在实数域上，我们说如果一个矩阵满足$A=A^T$，就说A是对称矩阵。\n在复数域上就变成了，如果$A=A^H$则称A是艾尔米特（Hermitian）矩阵。\n在实数域上，正交阵指的是$A^T=A^{-1}$，\n而在复数域上我们说正规矩阵指的是$A^H=A^{-1}$\n也就是说我们希望把一个矩阵A分解成QD。\n但是这是做不到的。\n实际上我们能做的是这样的。\n把A对应的线性变换分解为：\n我先进行一次旋转，然后再进行伸缩，最后再旋转回去。\n也就是说，我们要找两个正交矩阵P、Q，一个对角矩阵D，使得\n$A=PDQ^T$\n这就是奇异值分解了。\n当然，这件事在复数域上就变成了找两个正规矩阵P、Q，一个对角阵D，使得$A=PDQ^T$。\n他有很多用途，例如进行低秩估计等，不过与本文无关了。\n注意，奇异值分解并不要求A是一个方阵，他也不用可逆啊什么的，我们对A没有任何要求。\n那么问题来了，如何对A进行奇异值分解？\n非常简单。\n观察式子$A=PDQ^T$\n对A进行转置$A^T=QDP^T$\n然后算一下$AA^T$和$A^TA$看看\n$AA^T=PD(Q^TQ)DP^T=PDDP^T=PD^2P^T$\n$A^TA=QD(P^TP)DQ^T=QDDQ^T=QD^2Q^T$\n由于D是对角阵所以D²也是对角阵，因此上面两个等式不就是对$AA^T,A^TA$进行正交相似对角化吗？\n也因此$D^2$就是$AA^T,A^TA$的特征值拼成的对角阵。\n一般地，我们对对角矩阵D的元素是有名字的，而且还有顺序要求。（虽然数学上没有这个限制，但是我们实际计算的时候为了保证D的唯一性所以要求D的元素要从小到大排）\n我们称D的最大的元素为A的第一奇异值$\\sigma_1$，D第二大的元素为第二奇异值$\\sigma_2$，以此类推。\n这样的话，A的第i奇异值$\\sigma_i$就是$AA^T,A^TA$的第i大特征值的平方根了。\n但是你可能又注意到了，一个数的平方根有两个啊，所以我们为了保证唯一性还会要求各奇异值＞0，也就是大家都取算术平方根。\n所以最后的最后，A的第i奇异值$\\sigma_i$就是$AA^T,A^TA$的第i大特征值的算术平方根了。\n而再观察前面的式子P和Q就是$AA^T,A^TA$的特征向量拼成的矩阵，也可以跟着求得。\n我们来试试看，对\n$A=\\begin{pmatrix} 1 \u0026amp; 2 \\ 2 \u0026amp; 0 \\ 0 \u0026amp; 2 \\end{pmatrix}$进行奇异值分解。\n首先计算$A^TA$的特征值特征向量，得到特征值为9,4\n所以A的第一奇异值是3，第二奇异值是2。\n因此对角阵$D=\\begin{pmatrix} 3 \u0026amp; 0 \\ 0 \u0026amp; 2 \\ 0 \u0026amp; 0 \\end{pmatrix}$\n嗯，你会发现，由于A不是方阵，所以D也不是方阵，所以D其实不是对角阵，但是他的第i行第i列还是填的第i奇异值。\n如果你发现最后奇异值不够用了，少了，那么你就在矩阵里补0就可以了。\n至于P和Q，我们可以用$A^TA$的特征向量拼出$Q=\\begin{pmatrix} \\frac{1}{\\sqrt 5} \u0026amp; \\frac{2}{\\sqrt 5} \\ \\frac{2}{\\sqrt 5} \u0026amp; \\frac{-1}{\\sqrt 5} \\end{pmatrix}$\n那P呢，你也可以对$AA^T$继续求特征向量啦，但其实没有必要。\n你看哈，$A=PDQ^T$，我们两边右乘Q就有$AQ=PD$，从而就有$Aq_i=\\sigma_ip_i$，其中$p_i,q_i$是P和Q的特征向量。\n式子里AQD都是已知的，我们就可以直接求出$q_i$了。\n（其实，要求P，直接$P=AQD^{-1}$就可以了，也用不着这个什么性质，但我这边特绕远就是为了说奇异值有这个性质而已）\n类似地，我们还能求出$A^Tp_i=\\sigma_i q_i$。\n奇异值分解在这个系列里的用途主要是，可以用奇异值求矩阵的2-范数。\n赋范空间 我们已经不止一次提到，满足下面八大条的非空集合就是线性空间\n设V是一个非空集合，P是一个域（不只是数域）。若：\n1.在V中定义了一种运算，称为加法，即对V中任意两个元素α与β都按某一法则对应于V内惟一确定的一个元素α+β，称为α与β的和。\n2.在P与V的元素间定义了一种运算，称为纯量乘法（亦称数量乘法），即对V中任意元素α和P中任意元素k，都按某一法则对应V内惟一确定的一个元素kα，称为k与α的积。\n3.加法与纯量乘法满足以下条件：\nα+β=β+α，对任意α，β∈V. α+(β+γ)=(α+β)+γ，对任意α，β，γ∈V. 存在一个元素0∈V，对一切α∈V有α+0=α，元素0称为V的零元. 对任一α∈V，都存在β∈V使α+β=0，β称为α的负元素，记为-α. 对P中单位元1，有1α=α(α∈V). 对任意k，l∈P，α∈V有(kl)α=k(lα). 对任意k，l∈P，α∈V有(k+l)α=kα+lα. 对任意k∈P，α，β∈V有k(α+β)=kα+kβ， 我们可以给线性空间增加内积结构把他变成内积空间（也叫欧几里得空间）。\n在这里，我们要给他增加距离结构，或者叫范数。\n所谓范数就是长度的推广，所以我们要求范数满足长度的基本性质。并且要明确，范数的结果是数，所以范数是线性空间内的向量到数的一元映射。\n设V是数域P上的抽象的线性空间，我们在V上定义V到数域P的映射$| .|$，如果他满足下面三个长度应该满足的基本性质\n1.非负性：即V上任意抽象的向量的范数都大于等于0，并且只有零向量的范数为0。\n2.齐次性：即对于V上的任意抽象的向量x，P上的任意数k，有$|kx|=|k||x|$，也就是常数k可以提出来。\n3.三角不等式：即两边之和大于第三边，也就是对于V上的任意抽象的向量x,y，都有$|x+y|\\le|x|+|y|$。\n那么我们就称映射$| .|$是抽象的线性空间V上的范数，此时我们称V加上范数组成的代数结构为赋范线性空间。\n以前我们用抽象向量的内积定义过距离，这其实也就意味着由内积空间可以诱导出赋范空间，但是反过来是不行的。也就是我们不能由范数得到内积。\n在这里，线性空间、内积空间、赋范空间都是抽象的，我们并没有指明所谓是向量一定是高中学的那种n维向量，它完全可以是矩阵、可以是函数、也可以是别的什么东西。\n那我们取一些特例。\n向量范数 对于n维向量$x=(x_1,x_2,x_3,\u0026hellip;,x_n)$，有一类特殊的范数称为p-范数。\n他是$|x|_p=^\\sqrt[p]{x_1^p+x_2^p+\u0026hellip;+x_n^p}$。\n当p=1时，1-范数就是各分量绝对值的和。\n当p=2时，就是我们熟知的现实生活中的距离。\n更特殊的是p=+∞的时候，无穷范数实际上是x的最大分量的绝对值。\n当然，虽然范数有很多，但是p-范数之间是等价的。\n也就是说，你搞一个n维向量的点列$x_n$，只要$x_n$的任意一个范数趋于$x_0$，那么$x_n$的其他范数也是趋于$x_0$的。\n矩阵范数 n维向量有范数，而我们知道，mxn的矩阵全体也是一个抽象线性空间，所以它也能定义范数。\n一个简单的想法是继续沿用向量p-范数的定义，例如我们定义一个矩阵的范数是各个元素的平方和再开根号。\n这当然是可以的，只要我们定义的范数满足三个长度的基本性质就可以了。\n其实我刚刚随口胡诌的范数是矩阵的F-范数。\n一个更常见的矩阵范数是由刚刚说的向量的p-范数诱导出来的。\n所以这种范数被称为诱导范数，也称为矩阵的p-范数。\n他是这么想的，$A$是一个矩阵，但是矩阵乘以向量就得到向量了啊，我们可以用$Ax$的范数定义A的函数。\n但是取什么样的x呢？\n答案是取单位向量x，但是单位向量又有无穷多个，又该取哪个呢？\n这里啊，诱导范数选择的是取$Ax$最大的那个。\n所以最终矩阵的p-范数定义是，\n$|A|_p=\\max |Ax|_p$\n其中x是单位向量，也就是x的p-范数为1。\n但是你在其他地方看到的矩阵范数可能不长这样，他们没有要求x是单位向量而是在范数的结果上除以了x的范数，这是等价的。\n矩阵p-范数的等价定义是\n$|A|_p=\\max \\frac{|Ax|_p}{|x|_p}$\n但是我们必然是不会傻乎乎地用定义去算矩阵范数的。\n而是选择直接预制公式。\n例如矩阵的2-范数其实是A的第一奇异值。\n比如$A=\\begin{pmatrix} 2 \u0026amp; 1 \\ -2 \u0026amp; 1 \\end{pmatrix}$\n我们求$A^TA=\\begin{pmatrix} 8 \u0026amp; 0 \\ 0 \u0026amp; 2 \\end{pmatrix}$\n的最大特征值，再开根号就得到了A的第一奇异值，也是A的2-范数。\n下面给予证明。\n$|A|_2=\\max \\frac{|Ax|_2}{|x|_2}$\n而右边分子分母都是向量的2-范数。\n我们知道n维向量$x=(x_1,x_2,x_3,\u0026hellip;,x_n)$的2-范数是$\\sqrt{(x_1^2+x_2^2+\u0026hellip;+x_n^2)}$，这也可以表示为$\\sqrt{x^Tx}$。\n从而就有\n$|A|_2=\\max \\frac{|Ax|_2}{|x|_2}=\\max \\sqrt{\\frac{x^TA^TAx}{x^Tx}}$\n这里已经出现了熟悉的$A^TA$了。\n我们对$A^TA$进行正交相似对角化，即找一个单位正交矩阵P和对角阵D使得$A^TA=P^{T}DP$\n代入得\n$|A|_2=\\max \\frac{|Ax|_2}{|x|_2}=\\max\\sqrt{\\frac{x^TP^TD(Px)}{x^Tx}}=\\max\\sqrt{\\frac{(Px)^TD(Px)}{x^Tx}}$\n由于P是正交矩阵，所以$PP^T=E$\n那我就在分母动点手脚。\n$|A|_2=\\max\\sqrt{\\frac{(Px)^TD(Px)}{x^Tx}}=\\max\\sqrt{\\frac{(Px)^TD(Px)}{x^TP^TPx}}=\\max\\sqrt{\\frac{(Px)^TD(Px)}{(Px)^T(Px)}}$\n现在进行换元，令$y=Px$\n则\n$|A|_2=\\max\\sqrt{\\frac{y^TDy}{y^Ty}}$\n分子分母其实都是关于y的二次型，或者说我们把矩阵乘法展开\n$|A|_2=\\max\\sqrt{\\frac{y^TDy}{y^Ty}}=\\max\\sqrt{\\frac{\\lambda_1y_1^2+\\lambda_2y_2+\u0026hellip;+\\lambda_ny_n^2}{y_1^2+y_2^2+\u0026hellip;+y_n^2}}$\n然后进行放缩。\n我们先给$A^TA$的特征值，也就是A的奇异值进行排序，认为$\\lambda_1\\ge\\lambda_2\\ge\u0026hellip;\\ge\\lambda_n$\n现在我把所有的$\\lambda_i$都放大为$\\lambda_1$。\n就有：\n$|A|_2=\\max\\sqrt{\\frac{\\lambda_1y_1^2+\\lambda_2y_2+\u0026hellip;+\\lambda_ny_n^2}{y_1^2+y_2^2+\u0026hellip;+y_n^2}}\\le \\sqrt{\\lambda_1\\frac{y_1^2+y_2^2+\u0026hellip;+y_n^2}{y_1^2+y_2^2+\u0026hellip;+y_n^2}}=\\sqrt{\\lambda_1}$\n现在只要证明\n$\\sqrt{\\frac{y^TDy}{y^Ty}}$能取到$\\lambda_1$就可以了，这是显然的，我们取$y=(1,0,0,0,0,\u0026hellip;,0)$就可以了。\n所以最终结论，A的2-范数就是A的第一奇异值。\n矩阵的1范数和无穷范数就比较简单了。\n我举个例子秒会算。\n$A=\\begin{pmatrix} 2 \u0026amp; 1 \\ -2 \u0026amp; 1 \\end{pmatrix}$\n要算1-范数，就先算每一列元素的绝对值的和即4，2\n然后取最大的那个。\n无穷范数就是计算每一行元素的绝对值的和即3,3\n然后取最大的那个3。\n也因为1-范数是先算列元素，所以他也叫列范数，无穷范数则叫行范数。\n这里比较容易把行和列搞反，但是你得知道1是竖着写的，竖着的是列啊！∞是横着写的，横着是行。\n我们以1-范数为例证明一下。\n我们把$Ax$写成$\\begin{pmatrix} a_1, \u0026amp; a_2, \u0026amp; \u0026hellip;\u0026amp;a_n \\end{pmatrix}\\begin{pmatrix} x_1 \\ x_2 \\\u0026hellip;\\x_n \\end{pmatrix}=a_1x_1+a_2x_2+\u0026hellip;+a_nx_n$\n然后取范数就有\n$|Ax|1=|a_1x_1+a_2x_2+\u0026hellip;+a_nx_n|{1}$\n再运用三角不等式，\n$|Ax|1=|a_1x_1+a_2x_2+\u0026hellip;+a_nx_n|{1}\\le|x_1||a_1|_1+|x_2||a_2|_1+\u0026hellip;+|x_n||a_n|_1$\n然后我们再把$a_i$放大为最大的那个$a_k$\n$|Ax|1=|a_1x_1+a_2x_2+\u0026hellip;+a_nx_n|{1}\\le|x_1||a_1|_1+|x_2||a_2|_1+\u0026hellip;+|x_n||a_n|_1\\le(|x_1|+|x_2|+\u0026hellip;+|x_n|)|a_k|_1$\n式子左边的括号就是x的1-范数，所以\n$|Ax|_1\\le|x|_1|a_k|_1$\n而$|A|_1=\\max \\frac{|Ax|_1}{|x|_1}\\le\\frac{|x|_1|a_k|_1}{|x|_1}=|a_k|_1$\n也就是说A的1-范数小于等于第k列的1-范数，而$a_k$是一个向量，他的1-范数就是各分量绝对值的和，所以$|a_k|_1$就是第k列元素绝对值的和。\n现在只需要说明$|a_k|_1$是能取到的就可以了，这个非常简单，只需取$x_k=1$，其他都为0即可。\n无穷范数是类似的，差个转置而已，就不浪费时间说明了。\n","date":"2024-12-22T15:06:59+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%955-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B3%95/","title":"数值计算方法(5) 矩阵分解与线性方程组求解的直接法"},{"content":"还是继续数值计算方法的讨论。本文想简要介绍一下如何用迭代法计算方程和方程组的根。这一次的难度低了很多，我写着也是轻松了不少。\n迭代法求解方程最核心的是利用不动点进行不动点迭代。\n不动点迭代 在高中阶段你可能学习过这样的叫蛛网图的东西：\n蛛网图迭代的极限就是函数的不动点。\n所谓不动点迭代就是利用了这样的性质。\n一般地，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，那么g(X)的不动点就是f(x)的零点。\n而g(x)的不动点又是蛛网图迭代的极限。\n如果用代数语言表示的话，就是迭代公式\n$$x_{k+1}=g(x_k)$$这就是不动点迭代求方程的根的方法。\n当然，如果要更严谨化的说明的话，就是下面的压缩映像原理：\n设g(x)在[a,b]上具有连续的一阶导数，且满足以下条件：\n1.$\\forall x \\in [a,b],g(x) \\in [a,b]$\n2.$\\exist 0 \\le L \u0026lt;1,s.t. \\forall x\\in [a,b],|g\u0026rsquo;(x)|\\le L$\n则迭代过程\n$x_{k+1}=g(x_k)$收敛，且有误差估计式：\n$|x^*-x_k|\\le \\frac{L^k}{1-L}|x_1-x_0|$\n这个是简化版的压缩映像原理了，如果你学过《泛函分析和实变函数》那么你见到的压缩映像原理应该是这样的：\n设(X,d)是完备的距离空间，T是其中自身到自身的映射即X→X，如果$\\forall x,y\\in X,\\exist L\\in(0,1), d(Tx,Ty) \\le Ld(x,y)$（满足这样条件的映射称为压缩映射），则存在唯一的$x^$使得$Tx^=x^*$\n用一句话来说就是，完备的距离空间上到自身的压缩映射必有唯一不动点。\n别扯那么多了，还是看简化版的吧。简化版还有误差估计式嘞。\n从简化版的误差估计式看，k越大估计值$x_k$会离准确值$x^*$越来越近。\n这就足以为不动点迭代法背书了。\n但是这里需要注意的是，无论是泛函分析里加强版的压缩映像原理还是我们这里的简化版压缩映像原理，它都是不动点存在的充分条件而不是必要条件。也就是说，如果你找到一个函数他不满足上面的条件，你其实是不能判定他不存在不动点的。在这里我也看到某些教材在这个地方出现了纰漏。\n如果严格按照定理的说法只使用定理的话，我们是没有办法判定某个函数不具备不动点的。\n除此之外，还有一个更重要的问题也更严重的问题。\n无论是简化版的压缩映像原理还是加强版的，我们都要求你找到一个严格大于0，严格小于1的常数L，可是在实践中经常有人把这个条件简化为$g\u0026rsquo;(x)\\le1$这也是不对的。\n不动点迭代的收敛速度 收敛性是已经知道了的，毕竟误差估计式都给出来了。但是各个不动点迭代的收敛速度还是有差别的。\n我们来考虑第k次迭代后的迭代误差$e_k=x^*-x_k$，如果下一次迭代的迭代误差在k趋于无穷大时和$e_k$的p次方是同阶无穷小我们就说这个迭代是p阶收敛的。\n特别的，p=1称为线性收敛，p=2是平方收敛。\n那我怎么知道一个迭代方法是几阶收敛的呢？其实很简单，我们要求解的是x=g(x)嘛，你在$x=x_k$处把$x^*$泰勒展开一下。\n$g(x_k)=g(x^)+g\u0026rsquo;(\\alpha)(x^-x_k)+\\frac{g\u0026rsquo;\u0026rsquo;(\\alpha)}{2}(x_k-x^*)^2+\u0026hellip;$\n因为我们求解的是x=g(x)，所以$e_k=x^-x_k=g(x^)-g(x_k)=g\u0026rsquo;(\\alpha)(x^-x_k)+\\frac{g\u0026rsquo;\u0026rsquo;(\\alpha)}{2}(x_k-x^)^2+\u0026hellip;$\n所以如果g(x)在不动点$x^*$附近的1阶导，2阶导，3阶导，\u0026hellip;，p-1阶导都是0，而p阶导不为0，不就说明它是p阶收敛的了？\n这不就结了。\n接下来的迭代方法都是基于不动点迭代得出的，所以他们的收敛速度也是用这个方法求解的，就不多嘴了。\n迭代法的加速 现在我们分析出了不动点迭代的收敛速度，那么问题就来了，有些时候这个收敛速度非常慢，有没有办法加快？\n可以的，我们还是用误差事后估计的方法加速，这个方法好像每一节都有的样子你应该也熟悉了吧。\n针对迭代公式$x_{k+1}=g(x_k)$，它与准确值的误差$x^-x_{k+1}=g(x^)-g(x_k)=g\u0026rsquo;(\\alpha)(x^*-x_k)$\n又是拉格朗日中值定理，how old are U？（怎么老是你？）\n我们还是认为g(x)的导数值变化不大，是一个常数L，则我们估计出了$x_{k+1}$的误差，从而可以得到更好的近似值也就是把$x^*$解出来，得到\n$x^*\\approx \\frac{1}{1-L}x_{k+1}-\\frac{L}{1-L}x_k$\n这是一个更好的近似值，接下来再用这个更好地近似值进行迭代这就实现了加速。\n埃特金算法 但是上面的加速方法还可以优化一下，其最大的问题就是这个L取啥。\n其实这个问题也很简单，我们直接不想了啊哈哈。\n直接解决掉问题本身，解决掉提出问题的人。\n额我的意思是，我们把L消了。\n你再迭代一次得到$x_{k+1}\u0026rsquo;=g(x_{k+1})$，然后再用拉格朗日中值定理得到\n$x^-x_{k+1}\u0026rsquo;\\approx L(x^-x_{k+1})$\n和前面第一次迭代得到的$x^-x_{k+1}=L(x^-x_k)$相除就消掉L了，这样就不用考虑了。\n然后我们把$x^$解出来，得到$x^=x_{k+1}\u0026rsquo;-\\frac{(x_{k+1}\u0026rsquo;-x_{k+1})^2}{x_{k+1}\u0026rsquo;-2x_{k+1}+x_{k}}$\n这又是更好的近似值，然后把这个近似值代入原来的迭代公式进行迭代，这也实现了加速。这就是埃特金算法。\n牛顿迭代法 我们说了这么多其实都是基于已经将这个方程转化为x=g(x)，然后用迭代公式$x_{k+1}=g(x_k)$求解。\n但是我们不知道如何把方程转化为x=g(x)，牛顿迭代法就是解决了这个问题。\n思路其实也非常简单，我们知道微分有dy=f\u0026rsquo;(x)dx，于是$f(x)-f(x_k) \\approx f\u0026rsquo;(x_k)(x-x_k)$。\n从而$f(x)=f(x_k)+f\u0026rsquo;(x_k)(x-x_k)=0$\n那么$x=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$，完成啦！\n我们把f(x)=0转化为了x=g(x)的形式了，从而再使用不动点迭代得到f(X)根的迭代公式：\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这就是牛顿迭代法。\n用前面的收敛速度的计算方法可以得到在f(x)=0只有单根的情况下，在单根附近牛顿迭代法是平方收敛的。\n牛顿下山法 注意，我说的是在f(x)=0只有单根的情况下，在单根附近牛顿迭代法是平方收敛的。\n很多时候函数有多根结论就未必是这样的。\n更有甚者，你的初值点离根太远，牛顿迭代法可能会发散。\n所以就有了牛顿下山法，为我们选择一个合适的初值点。\n牛顿下山法是下山法+牛顿法。所谓下山法，就是在不动点迭代的基础上要求每次迭代函数值的绝对值都要下降，也就是要求$|f(x_{n+1})|\\le|f(x_k)|$，显然这样的话每次迭代函数值都更接近0，也就有很大的概率是更接近方程的根的。\n但是事情往往不是那么美妙，因为咱们暂时还没有科学的方法找到下一个迭代的点。\n这时可以把牛顿法引入进来，我们先用牛顿法进行一次迭代得到\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n然后把这个$x_{k+1}$和$x_k$加权平均作为新的$x_{k+1}'$\n也就是$x_{k+1}\u0026rsquo;=\\lambda x_{k+1} + (1-\\lambda)x_k=x_k-\\lambda\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这里$0\u0026lt;\\lambda \\le1$被称为下山因子，我们就是每次迭代找这么一个合适的下山因子。\n而下山因子怎么找呢？二分呗。\n诶等等二分法？\n二分法不也可以求方程的根？\n所以很多时候我们也会用二分法先得到一个精确解的范围，然后把初值定在里面，然后再用牛顿法或者牛顿下山法。\n弦截法 到这里看起来已经非常完美了，至少我是这么认为的。\n但是实际上，有极少部分函数的导数是很难求解的，所以我们要用差商估计导数，这就是弦截法了。\n用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_0)}{x_k-x_0}$代入牛顿迭代法，就是弦截法了。\n如果用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$代入牛顿迭代法，就是快速弦截法了。\n线性方程组迭代的收敛性 前面说的都是非线性方程，那线性方程呢？一元的情况确实不用费心了，我口算都给你解了。\n但是现实里的线性方程组往往阶数非常高，所以也需要一个高效的求解方法。我们还是先介绍迭代法。方法其实和前面是类似的所以一并讲解。\n线性方程组AX=b如果我们可以将其化为X=BX+f，那么用前面所说的不动点迭代法就有迭代公式\n$X_{k+1}=BX_k+f$\n这是我们线性方程组迭代法的基石。\n它的误差：\n$e_{k+1}=|x^-x_{k+1}|=|BX^+f-(BX_{k}+f)|=B|X^*-X_k|=Be_k$\n从而，$e_k=B^ke_0$\n那么如果$B^k$能收敛于0的话该迭代法就收敛了，用线性代数或者高等代数的知识就能明白这等价于B的谱半径（最大特征值）小于1。\n现在我们有了对于所有矩阵的收敛性判别法，而对于一些特殊的矩阵不用这么麻烦。\n比如，对角占优方程组他的雅可比迭代和高斯-赛德尔迭代都是收敛的。\n这两种迭代方法我们等下讲，但因为这个话题在这了嘛所以我就先说了。\n证明的话因为没说迭代方法，所以也讲不了，其实你也可以等下自己试试看能不能证出来。\n我只在这里说一下什么是对角占优方程组。\n它指的是系数矩阵是对角占优矩阵的方程组。\nOK，说了和没说一样。\n所谓对角占优矩阵说的是，主对角线上的元素的绝对值＞同行其他元素的绝对值之和的矩阵。\n这就明白了吧。\n而且这个名字现在看着是不是很直观？主对角线上的元素绝对值比你一整行其他元素绝对值的和都大，那是在这一行绝对的制霸啊。\n这样的矩阵其实一定是可逆阵，这个你也可以证明看看。\n雅可比迭代 现在的问题还是和前面一样的，不动点迭代法说的轻巧，但是你怎么把AX=b转化成X=BX+f呢？\n其中的一种方法就是雅可比迭代法了。\n对方程组AX=b，我们将A分解为对角阵D，下三角矩阵L，上三角矩阵U使得\nA=D-L-U。\n（值得一提的是，这个分解是相当容易的，D就是A的对角元，L取A的下三角去掉主对角线，U取A的上三角去掉主对角线即可）\n那么AX=b就是\n(D-L-U)X=b\n然后移项得\nDX=(L+U)X+b\n从而$X=D^{-1}(L+U)X+D^{-1}b$\n完事了，已经变成X=BX+f的形式了，所以就有迭代公式\n$X_{k+1}=D^{-1}(L+U)X_k+D^{-1}b$\n这就是雅可比迭代法了。\n但是这个方法可以稍微变一下，我们移项的时候不一定要把L和U全部移走，这就是高斯-赛德尔迭代法了。\n高斯-赛德尔迭代法 还是安装雅可比迭代的步骤我们得到，(D-L-U)X=b移项但是只移U得到\n(D-L)X=UX+b\n然后得到$X=(D-L)^{-1}UX+(D-L)^{-1}b$\n于是就有迭代公式$X_{k+1}=(D-L)^{-1}UX_k+(D-L)^{-1}b$\n但是我们一般不会这么使用，而是再等式两边再乘以D-L得到\n$(D-L)X_{k+1}=UX_k+b$\n从而$DX_{k+1}=LX_{k+1}+UX_k+b$\n所以$X_{k+1}=D^{-1}LX_{k+1}+D^{-1}UX_k+D^{-1}B$\n这才是我们一般最爱用的高斯-赛德尔迭代公式。\n其实到这里，你应该也能自己造出第三个迭代公式了吧。高斯-赛德尔迭代只移了U，那我只移动L行不行？当然也行啊，反正思路就是这么个思路，怎么折腾随便你。\n","date":"2024-12-21T20:10:44+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%954-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/","title":"数值计算方法(4) 迭代法求解方程"},{"content":"上一期讲了数值积分方法，这一次自然是要讲数值微分方法的，不然太不完善了。\n更何况数值微分方法其实是基于数值积分方法得到的。\n我们先从比较简单的估计导数值来开篇。\n差商方法 估计函数的导数值意义其实没有前面积分那么大，因为基本初等函数都能很容易地求导，有准确值了近似值的意义就没有那么大了。\n不过还是来试试吧。\n近似导数的最简单的方法就是用导数的定义。\n你看一阶差商$\\frac{f(a+h)-f(a)}{h}$，当h趋于0时根据这就是导数的定义啊，所以反过来我们可以让h非常小，这样就是导数的近似值了。\n这种差商在这里有一个名字叫向前差商。\n有向前自然就有向后$\\frac{f(a)-f(a-h)}{h}$。\n其实还有中心差商$\\frac{f(a+h)-f(a-h)}{2h}$。\n中心差商还有一个名字叫中点方法，其实这玩意也能看做是向前差商和向后差商的平均值。\n如果是我们手算的话，其实这样就很好了。\n我们手算的话h越小误差越小，但这么麻烦的东西自然是不可能手算的。\n但是一旦交给计算机算啊，h如果太小，计算机计算的误差就会增加（计算机进行浮点数运算是不准确的，这是由浮点数的存储方式决定的，计算机的浮点数大多都按照IEEE的规范设计的，是存在舍入误差的）。\n总之，现在这个h如果太大，从数学上看的误差会变大（我们称为截断误差），h如果太小计算机计算的时候舍入误差会太大。\n那么又来了，步长h应该怎么选呢？\n这情况和龙贝格算法一模一样啊。\n还是用理查德森外推法。\n我们可以导出一个一模一样的加速公式。\n$G_n(h)=\\frac{4^nG_{n-1}(\\frac{h}{2})-G_{n-1}(h)}{4^n-1}$\n然后画一模一样的表就可以了。\n这里确实没太大区别。\n我们先用泰勒公式计算余项：\n$G(h)-f\u0026rsquo;(a)=\\alpha_1 h^2+\\alpha_2h^4+\u0026hellip;+\\alpha_nh^{2n}+\u0026hellip;$\n把步长折半\n$T(\\frac{h}{2})-f\u0026rsquo;(a)=\\alpha_1 \\frac{h^2}{4}+\\alpha_2\\frac{h^4}{16}+\u0026hellip;+\\alpha_n\\frac{h^{2n}}{4^n}+\u0026hellip;$\n然后消掉h²项得到更好的$f\u0026rsquo;(a)$的误差估计，每次都这样计算，整理出来的递推公式就是上面的那个式子，由于余项的形式和龙贝格算法是一样的所以最终的递推式也是一样的。（详情还是回到上一节看一下详细的理查德森外推法吧）\n插值型求导公式 前面我们说插值是对函数的拟合，所以这里自然可以用插值多项式替代函数f(x)，用插值多项式的导数作为f(x)导数的近似，但是这玩意儿没那么靠谱，因为插值多项式在函数值上比较接近，但是他们的导数值可能差得很远，所以这条路子没那么靠谱，也就没那么多理论了。你就当是半破产了吧。而且操作起来也不难，就是无脑用插值多项式替代f(x)而已，所以不多说了。\n接下来才是重点，唠唠怎么求解微分方程。\n微分方程数值解 微分方程数值解的求法主要是利用了数值求积方法，在此我们以标准的微分方程初值问题为例介绍几个方法。\n在《常微分方程》这门课程中（注意是一门课，不是高等数学的那个章节），你应该听过皮卡逐步逼近定理。\n它这里的微分方程近似解是一个多项式，而我们这里说的微分方程数值解不是这样的东西。\n针对这样的初值问题，你给我一个步长h，我求出微分方程的解g(x)在x+h，x+2h,\u0026hellip;等处的函数值，我们这里说的数值解是这样的东西。\n当然，为了保证初值问题有且只有唯一的解，我们仍然要求f(x,y)关于y满足利普希茨条件。（没听过不用管，这是因为你没上过《常微分方程》这门课，总之就是要保证解存在且唯一而已，这个条件后文不会使用）\n好接下来开始推导。\n对微分方程\n$\\frac{dy}{dx}=f(x,y)$\n我们两边同时积分得到\n$\\int_{x_n}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n也就是\n$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n从而\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n而如果我们可以用数值方法求出这个积分，不就解出了这个微分方程？\n例如，我们直接用左矩形公式求积分，得到\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_n,y_n)$\n这就是欧拉格式。(注意，数值微分里我们称为格式而不是公式，这里没有打错字)\n你可能会发现我这里给的欧拉格式和网上一般的不一样，其实你只要设$h=x_{n+1}-x_n$（当我设了h就默认等步长了）就能得到一般的欧拉格式了。\n$y_{n+1}=y_n+hf(x_n,y_n)$\n同样地，我们可以用右矩形公式得到\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_{n+1},y_{n+1})$\n类似地，我们设$h=x_{n+1}-x_n$就有，\n$y_{n+1}=y_n+hf(x_{n+1},y_{n+1})$\n这就是隐式欧拉格式了。\n那如果我用中矩形公式，还能得到两步欧拉格式：\n对微分方程\n$\\frac{dy}{dx}=f(x,y)$\n我们两边同时积分得到\n$\\int_{x_n-1}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n-1}^{x_{n+1}}f(x,y)dx$\n注意，这次是从$x_{n-1}$积到$x_n$，并且我们要求步长为h，则$x_n$是积分区间中点。\n有$y_{n+1}-y_{n-1}=2hf(x_n,y_n)$\n从而，$y_{n+1}=y_{n-1}+2hf(x_n,y_n)$\n这就是两步欧拉格式。\n还可以用梯形公式来求积分得到梯形格式。\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+\\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]$\n注意力好的人应该已经发现了，梯形格式恰好是显式欧拉格式和隐式欧拉格式的算术平均。\n预报-矫正系统与改进欧拉 前面扯了这么久感觉非常平淡啊，就是套用一下求积公式，下面来点有意思的。\n你看梯形格式里是不是说需要$f(x_{n+1},y_{n+1})$？\n你有没有想过这玩意儿哪里来？\n是不是前面看得特爽但是这个最基本的东西没发现。\n$f(x_{n+1},y_{n+1})$明明是下一次的东西，你怎么能让我现在就给出来呢？\n其实是这样的，我们先用前面的一个显式格式预报一个$f(x_{n+1},y_{n+1})$出来，然后再用隐式格式得到一个矫正后的$y_{n+1}$，这样精度会更高。\n例如，使用显式欧拉格式预报$y_{n+1}=y_n+hf(x_n,y_n )$\n然后再把这个预报的$y_{n+1}$代入隐式欧拉，这就是改进欧拉格式了。\n这样的一套系统我们称为预报-矫正系统。\n你其实是可以任意组合的。\n但是这样的方法仍然没有脱离求积公式的桎梏，而下面的方法就是重新开了一个方向了。\n龙格-库塔方法 这个龙格-库塔方法从另一个角度看问题，他是这么说的。\n函数f的一阶差商$\\frac{f(x_{n+1})-f(x_{n})}{x_{n+1}-x_n}$，因为我们微分方程数值解指的是你给我一个步长h，我求出微分方程的解g(x)在x+h，x+2h,\u0026hellip;等处的函数值，所以分母就是步长h，分子则可以运用拉格朗日中值定理，从而$\\frac{f(x_{n+1})-f(x_{n})}{h}=f\u0026rsquo;(\\alpha)$\n于是，$f(x_{n+1})=f(x_n)+hf\u0026rsquo;(\\alpha)$\n你们呐，折腾这么多其实就是在估计$f\u0026rsquo;(\\alpha)$！\n这个$f\u0026rsquo;(\\alpha)$被称为函数f在区间内的平均斜率。\n你可以试试看，显式欧拉就是用函数在左端点的斜率值估计平均斜率，改进欧拉是用两个端点处的斜率的平均值估计斜率。\n这些估计方式对平均斜率的估计显然精度没有那么高，所以这些方法在计算数值解时的精度自然也不高。\n那我如果多用一些点来估计函数的平均斜率，精度不就提高了？\n龙格-库塔方法就是这样的方法。\n我们在$x_n,x_{n+1}$之间取p个不同点的斜率，计算他们的加权平均，把这个当做平均斜率的估计。\n那取哪些点呢？这个就是龙格-库塔方法精度高的精髓了。\n我们以二阶龙格-库塔方法为例进行推导。\n在这里，龙格-库塔方法的阶数指的就是用的点的数量。\n在这里我们设要取的点的斜率为$k_1,k_2$，要计算他们的加权平均，所以还需要假设权。\n所以我们再设平均斜率$k^*=(1-\\lambda)k_1+\\lambda k_2$\n我们先取其中一个端点为左端点$x_n$试试水，那么就有$k_1=f(x_n,y_n)$了。\n接下来我们要找第二个点$x_{n+p}=x_n+ph,p \\in(0,1]$然后计算他的斜率为$k_2$。\n那怎么找呢？似乎没有头绪了，其实我也没有。不过好在数学家想到了，可以继续用预报-矫正系统啊。\n我们先用显式欧拉预报一个$y_{n+p}=y_n+phk_1$，那么$k_2=f(x_{n+p},y_{n+p})=f(x_{n+p},y_n+phk_1)$了。\n呕吼，搞了一圈合着还是俩未知量，一个没消啊。\n这个方法里真正消元的方法是泰勒展开+比较系数。\n我们先对$k_2=f(x_{n+p},y_n+phk_1)$进行泰勒展开，由于$x_{n+p}=x_n+ph$，所以$k_2$实际上是一个二元函数$f(x,y)$的泰勒展开。\n这个二元函数的泰勒展开，好像只有数学分析介绍了，如果你只学过高等数学的话你应该不知道，所以我这边给一下结论。\n如果函数f在点$P(x_0,y_0)$的邻域U(P)内有n阶连续的偏导数，则对U(P)内的任意一点$(x_0+h,y_0+k)$，存在$\\theta \\in (0,1)$，使得\n$f(x_0+h,y_0+k)=\\sum_{p=0}^n\\frac{1}{p!}(h\\frac{\\partial}{\\partial x}+k\\frac{\\partial}{\\partial y})^pf(x_0,y_0)+o(\\rho),\\rho^n=\\sqrt{h^2+k^2}$\n这是二元函数的n阶泰勒公式。\n现在我们来展开一下但是这里只需要展开两项，\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+(ph\\frac{\\partial}{\\partial x}+phk_1\\frac{\\partial}{\\partial y})f(x_n,y_n)+o(\\rho ^2)$\n现在只是单纯的代入了公式，我们来进行计算。\n先关注偏导数部分。\n$(ph\\frac{\\partial}{\\partial x}+phk_1\\frac{\\partial}{\\partial y})f(x_n,y_n)$\n这里前面一个括号写的是偏微分算子，其实我们直接把函数$f(x,y)$乘进去就可以了。\n也就得到$ph\\frac{\\partial}{\\partial x}f(x_n,y_n)+phk_1\\frac{\\partial}{\\partial y}f(x_n,y_n)$\n由于没有给出f(x,y)具体的表达式，所以这里就不能计算f(x,y)的偏导了。\n把这个结果代入就是最后的展开式了。\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phk_1\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n等等，$k_1$是啥？\n回到前面看看，$k_1=f(x_n,y_n)$\n而我们解的微分方程是啥来着？$\\frac{dy}{dx}=f(x,y)$\n$x_n,y_n$既然是微分方程解上的点自然也就满足这个微分方程了喽，所以$k_1=f(x_n,y_n)=\\frac{dy}{dx}|_{x=x_n}$\n这么写有点难看，我们把式子弄得漂亮一点。微分方程最后的解是一个关于x的函数，我们设为$y(x)$，那么他的导数就是$y\u0026rsquo;(x)$，他在$x_n$处的导数自然就是$y\u0026rsquo;(x_n)$了。\n所以$k_1=y\u0026rsquo;(x_n)$\n也因此\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n再等等，刚刚是不是还说了$k_1=f(x_n,y_n)=y\u0026rsquo;(x_n)$来着？\n这下不是又能代入了？\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n这时候有些注意力比较集中的人就发现了。\nk2的式子里面啊，中括号的内容是$ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}$\n我们把ph提出来，就是$ph[\\frac{\\partial f(x_n,y_n)}{\\partial x}+y\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]$\n你看中括号里面的东西。\n额，也许你看不出来。我给个提示。\n观察二元函数f(x,y)，这里我们已经假设了y是关于x的函数y(x)，所以这时候我们可以求f(x,y)关于x的全导数，利用复合函数求导法则就可以了。\n或者画个路径图。\nf(x,y)首先是关于x,y的二元函数，y又是关于x的一元函数，\n所以f(x,y)关于x的全导数$\\frac{df(x,y)}{dx}=\\frac{\\partial f}{\\partial x}+\\frac{\\partial f}{\\partial y}\\frac{dy}{dx}$\n我把式子写全\n$\\frac{df(x,y)}{dx}=\\frac{\\partial f(x,y)}{\\partial x}+\\frac{\\partial f(x,y)}{\\partial y}\\frac{dy(x)}{dx}$\n我取f(x,y)在点$(x_n,y_n)$的全导数，\n这特么，不就是括号里的$\\frac{\\partial f(x_n,y_n)}{\\partial x}+y\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}$吗？\n所以又能化简了。\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+ph\\frac{df(x_n,y_n)}{dx}+o(\\rho ^2)$\n我再问一遍，我们要求解的微分方程是什么？\n$\\frac{dy}{dx}=f(x,y)$\n所以，$f(x_n,y_n)=\\frac{dy(x_n)}{dx}$\n那$f(x_n,y_n)$再对x求一阶导是啥？\n不就是$y(x)$在$x_n$处的二阶导$y\u0026rsquo;\u0026rsquo;(x_n)$吗？\n所以又能化简了。\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+phy\u0026rsquo;\u0026rsquo;(x_n)+o(\\rho ^2)$\n最后还有个小尾巴，$o(\\rho^2)$是啥？\n回去看看泰勒公式，$\\rho^2=(ph)^2+(phk_1)^2$，它和$h^2$是同阶无穷小，所以$o(\\rho^2)=o(h^2)$\n所以到了最后，\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+phy\u0026rsquo;\u0026rsquo;(x_n)+o(h^2)$\n$k_1$我们说了是$f(x_n,y_n)=f\u0026rsquo;(x_n)$\n代入我们的迭代格式$y_{n+1}=y_n+h[(1-\\lambda)k_1+\\lambda k_2]$\n得到\n$y_{n+1}=y_n+hy\u0026rsquo;(x_n)+\\lambda ph^2y\u0026rsquo;\u0026rsquo;(x_n)+o(h^3)$\n而$y_{n+1}$实际上是y(x)在$x_{n+1}$的取值$y(x_{n+1})=y(x_n+h)$\n这时候我们还可以把一元函数$y(x)$泰勒展开，展开三项得到\n$y_{n+1}=y(x_n+h)=y(x_n)+hy\u0026rsquo;(x_n)+\\frac{h^2}{2}y\u0026rsquo;\u0026rsquo;(x_n)+o(h^3)$\n由于泰勒展开是唯一的，所以我们前后得到的两个泰勒展开应该是一样的才对，也就是$\\lambda p=\\frac{1}{2}$\n总之，最终结论是$2\\lambda p=1$，并且二阶龙格-库塔方法的阶段误差是$h^3$这个数量级的。\n也就是说，只要满足$2\\lambda p=1$的迭代格式都是二阶龙格-库塔格式，误差都是$h^3$这个数量级的。\n我们取$p=1,\\lambda = \\frac{1}{2}$得到的迭代格式就是改进欧拉格式，取$p=\\frac{1}{2},\\lambda=1$得到的迭代格式我们称为变形的欧拉格式，或者也称为中点格式。\n$y_{n+1}=y_n+hk_2$\n$k_1=f(x_n,y_n)$\n$k2=f(x_{n+\\frac{1}{2}},y_n+\\frac{h}{2}k_1)$\n如果我们令$p=\\frac{2}{3},\\lambda=\\frac{3}{4}$，得到的就是休恩公式。\n如果进一步增加点就可以得到三阶、四阶乃至更高阶的龙格-库塔迭代格式不过这个迭代式子啊比较难看了而且也没有什么规律，想了解的话可以自己上网搜寻。他的推导思路倒是和二阶的没什么区别。\n龙格-库塔方法的问题呢已经很小了。不过我们还是可以吹毛求疵出来，在计算$y_{n+1}$的时候我们已经算出了$y_1,y_2,\u0026hellip;,y_n$而龙格-库塔方法没有充分地利用这些已经算出来的数据。\n亚当姆斯方法 如果要利用这些信息你就得到了亚当姆斯方法。\n亚当姆斯方法可以当做龙格-库塔方法的推广继续用泰勒展开得到，但是你懂的，这非常麻烦。\n我们换一个简单的方法——利用插值多项式得到。\n针对微分方程$\\frac{dy}{dx}=f(x,y)$，我们两边积分（熟悉的开局）\n但是这次积分区间不一样，看你想用几个历史信息点了，比如说我想用r+1个历史信息，那就从$x_{n-r+1}$积到$x_{n+1}$，那么左边是函数值的差，右边是一个积分。\n这个积分呢，我用一个r次插值多项式来近似。\n那插值节点选哪r个呢？答案是任意。如果我选择包含$x_{n+1}$的前r+1个插值节点得到的就是r+1阶隐式亚当姆斯格式，我选择$x_n$开始的r+1个插值节点得到的就是r+1阶显式亚当姆斯格式。\n例如，我想得到2阶隐式亚当姆斯方法，我就从$x_n$积到$x_{n+1}$\n得到$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n再用过$x_{n+1},x_n$的线性插值多项式$\\frac{x-x_{n+1}}{x_n-x_{n+1}}f(x_n,y_n)+\\frac{x-x_n}{x_{n+1}-x_{n}}f(x_{n+1},y_{n+1})$近似替代f(x,y)然后算出积分就可以了。\n结果是$y_{n+1}=y_n+\\frac{h}{2}(f_n+f_{n+1})$\n那如果我取插值节点是$x_n,x_{n-1}$就能得到二阶显式亚当姆斯格式，结果是$y_{n+1}=y_n+\\frac{h}{2}(3f_n-f_{n-1})$\n亚当姆斯预报-矫正系统 很经典的场景出现了。\n我们同时有显式和隐式迭代格式，而隐式格式里需要提前知道$y_{n+1}$，那$y_{n+1}$哪里来呢？\n可以由同阶显式迭代格式预报得来。\n这就是亚当姆斯预报-矫正系统，没啥花头。\n前面说了这么多都是关于迭代格式，也就是算法的讨论，那这部分有没有理论呢？\n迭代格式的收敛性和数值稳定性 其实有的。\n一个最严重的问题是收敛性问题，也就是我们叭了叭叭bb了老半天，你迭代的$y_n$是否真的趋于准确值。\n这些方法我都拿出来讲了你应该明白，肯定是收敛的。\n这玩意儿的证明又涉及到了利普希茨条件，又要搞泰勒展开的，比较麻烦，我就给个文章吧。\n知乎的@123456写的关于一阶显式和隐式方法收敛性的理论分析，地址https://zhuanlan.zhihu.com/p/515389776，当然你去网上找其他资料也可以。\n我这里只给个结论。\n显式欧拉格式的全局截断误差$|y(x_n)-y_n|\\le e^{L(b-a)}|y(x_0)-y_0|+\\frac{Mh}{2L}(e^{L(b-a)-1})$，其中$M=\\sup|y\u0026rsquo;\u0026rsquo;(x)|$\n这个全局截断误差有两项，我们说后一项是局部截断误差的累计，而在前一项里，$|y(x_0)-y_0|$是初值条件的误差称为条件误差，e^{L(b-a)}$是条件误差放大倍数，他只于初值问题本身的利普希茨系数L有关。当这个L很大的时候，注意，哪怕是微小的条件误差也会导致显式欧拉格式有很大的全局截断误差，这种情况我们称原问题数值稳定性差。\n当然，这只是定性的说法，如果要定量的话是这样说的。\n我们给一个扰动$\\delta$，如果迭代格式产生的各个节点的误差均在$\\delta$以内，我们就说这个迭代方法是稳定的。\n但是这个稳定性问题是非常复杂的，这个问题在其他学科还有一个名字叫混沌。\n2021年的诺贝尔物理学奖就颁给了混沌相关的研究，咱们就不蹚这深水了。\n我可以告诉你的是，显式欧拉格式是条件稳定的，只有当步长h比较小的时候才稳定。\n关于方程组和边值问题 我们扯了那么多，都是在说微分方程的初值问题。那方程组呢？\n方程组的话其实迭代格式不用改变的，方程组的初值问题不就是$\\frac{d\\vec{y} }{dx}=f(x,\\vec{y})$嘛，你看写成向量不就熟悉了？\n迭代格式不用发生任何变化。\n总之，这样就能求解常微分方程组了。\n而如果是高阶常微分方程，我们知道可以通过换元的方法转化成方程组的求解所以也解决了。\n而微分方程的边值问题的数值解，上面的方法都用不了，而且求解起来比较复杂。\n甚至哪怕是上了《常微分方程》课程的人也未必知道微分方程的边值问题是啥吧。\n所以我就只给个名词了，可以用差商法、有限元法、打靶法等方法求解。\n","date":"2024-12-21T15:45:47+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%953-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值计算方法(3) 数值微分方法"},{"content":"上一期讲了插值方法，这一次自然是要运用一下插值方法了。所以这一期的主题是用插值方法计算定积分。\n机械求积方法 下面我们来介绍一下怎么用插值法来得到数值方法计算函数积分。\n对于大部分函数，我们其实都是很难求其积分的，甚至很多函数例如$e^{x^2}$这样的函数压根就没有初等原函数。所以我们需要寻找数值方法来计算他们的积分。\n对于大多数函数，我们不仅很难求积分，也许微分也很难求，所以我们希望的数值方法一定是不能包含这俩的。\n为了简化问题，我们最终的求积公式就用函数值的线性组合试试看了。\n这种最简单的求积公式就是机械求积。\n也就是找到某些点的函数值，用这些点的函数值的某个线性组合来近似积分值。\n即机械求积公式认为$\\int_a^b f(x)dx \\approx \\sum_{k=0}^n A_k y_k$\n所以关键点就是点的选取和组合系数$A_k$的选择了。\n一种可能的思路就是用上一期提的插值多项式来近似替代这个函数。而且我们是已知了差值余项的，余项的积分就是我们数值积分方法的误差。\n而这些都是多项式啊，都很好计算的。\n这种求积分的数值方法得到的积分公式我们都叫做差值型的求积公式。\n而在插值方法里，点的选择是任意的，那我们就暂且也让大家任意选择。\n这样只需要知道组合系数$A_k$就知道怎么求积了。\n而对于插值型求积公式，我们很容易就能得到$A_k$。\n插值型求积公式就是用f(x)的插值多项式近似f(x)，从而有\n$\\int_a^bf(x)dx \\approx \\int_a^bp_n(x)dx$\n再把拉格朗日插值公式代入得\n$\\int_a^bf(x)dx \\approx \\int_a^b \\sum_{k=1}^n y_k l_k(x)dx$\n$=\\sum_{k=1}^n y_k\\int_a^bl_k(x)dx$\n而我们的机械求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$，从而\n$A_k=\\int_a^b l_k(x)dx$\n代数精度 你也许会觉得这个办法非常粗糙，确实！我们可以来分析一下他的精度。余项么，自然就是拉格朗日插值余项的积分了，这个没啥好说的。\n我们在机械求积里其实最关注代数精度了。\n我们拿多项式函数来表彰一个求积公式的精度。\n取多项式$p(x)=a_nx^n+a_{n-1}x^{n-1}+\u0026hellip;+a_0$\n由于多项式函数总是很容易求出积分的准确值的。\n我们就来看看你的求积公式是从几次多项式开始才变得不准确的。这个次数就是求积公式的代数精度。\n事实上，我们前面那种求积方式的代数精度是很容易看出来的。\n你用n次多项式插值f(x)而我们代入验证的f(x)是m次多项式。\n如果n=m，那么你的插值多项式就是我们代入验证的m次多项式。\n如果n比m还大呢？求积公式的插值多项式会退化为m次多项式，所以积分自然也还是准确的。\n因此，n次插值多项式得到的求积公式至少具有n次代数精度。\n我这里是用的任意n次多项式来进行验证，不过你在外面看到的定义可能是说用$x^n$代入验证，事实上我们俩说的是等价的。\n其他人的说法是你代入$1,x,x^2,\u0026hellip;,x^n$，一直到$x^{n-1}$次方，你都发现求积公式是准确的，但n次方开始不准确了，这时说求积公式有n-1次代数精度。\n显然，他们的定义是我说的定义的特殊情况，所以满足我的定义的，自然满足他们的定义。\n而满足他们定义的求积公式，对$x^{n-1}$都准确。\n则我取任意的n-1次多项式，$p(x)=a_{n-1}x^{n-1}+\u0026hellip;+a_0$\n求积分$\\int_a^bp(x)dx=a_{n-1}\\int_a^bx^{n-1}dx+a_{n-2}\\int_a^bx^{n-2}dx+\u0026hellip;+a_0\\int_a^b1dx$\n$1,x,x^2,\u0026hellip;,x^{n-1}$的积分准确，那么p(x)的积分也就是准确的了。\n所以我们俩的代数精度的定义是等价的，只不过我这个看起来要强一些而已。\n牛顿-科特斯公式 前面我们给的机械求积公式略显粗糙，但也能取得至少n次代数精度，接下来我们会对求积公式进行加强，对它有更高的要求。\n组合系数$A_k$是死的了，所以下面的加强都是从插值点入手。\n例如牛顿-科特斯公式就是进一步要求，插值点的间距相等（步长为h），然后得到一个特殊的结论。\n我们竟然将区间长度提出来了，\n$\\int_a^b f(x)dx=(b-a)\\sum_{k=0}^n C_k f(x_k)$\n并且，$C_k$竟然还是常数。\n我们称$C_k$为科特斯系数，可以直接查科特斯系数表得到，与具体的函数f(x)无关，只和你插值多项式的次数n有关!\n这就是牛顿-科特斯公式。\n其中n=1得到的求积公式被称为梯形公式，n=2的是辛普森公式。\n一般我们也就只用到辛普森公式为止，这是因为前面我们说过插值多项式有龙格现象，也就是会过拟合。我们这里也是一样，你用的求积公式次数太高，插值多项式在区间端点附近疯狂震荡，而且这时候你稍微变一下计算用的数值最后的计算结果差距会非常大（这种情况我们称为数值稳定性差）。\n所以记住常用的求积公式，三个矩形公式，也就是\n左矩形公式：把f(x)直接当做常函数f(a)求矩形的面积$\\int_a^bf(x)dx=(b-a)f(a)$\n还有右矩形公式：$\\int_a^bf(x)dx=(b-a)f(b)$\n以及中矩形公式：$\\int_a^bf(x)dx=(b-a)f(\\frac{a+b}{2})$\n梯形公式，把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积,当然也是什么的n=1时的牛顿科特斯公式$\\int_a^bf(x)dx=(b-a)\\frac{1f(b)+1f(a)}{1+1}$\n既然梯形公式是把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积你其实大可不必用上面我写的复杂的式子，直接上底+下底再乘高除2就完事了。\n我也这样是为了让你记住辛普森公式。\n辛普森公式涉及三个点，然后是等距的，这里假定求a,c的积分，b就是a和c的中点，从而\n$\\int_a^cf(x)dx=(c-a)\\frac{1f(a)+4f(b)+1*f(c)}{1+4+1}$\n重点在系数1,4,1，记住这个就可以了。\n这也是上面的牛顿-科特斯系数表不把$\\frac{4}{6}$化简的原因。\n这里也点出了牛顿-科特斯系数表的性质即每一行的和为1。\n好了，总之这样你应该就记住了这几个公式了。\n但是问题来了，这玩意儿啊都是用的低阶插值，所以代数精度不也就低了。\n左右矩形公式只用了1个点，所以是0阶插值的结果，有0阶代数精度。\n梯形公式两个点，是线性插值的结果，只有1阶代数精度。\n辛普森公式3个点，是抛物插值的结果，2阶代数精度，这不就完全垮了啊！\n你应该能想到应该怎么做，分段呗，继续分段。\n复化方法 这种分段的方法在前面分段低次插值和样条插值里你已经见过了，只不过在这里叫复化方法。\n对应的求积公式叫复化求积公式。\n我们将区间[a,b]n等分，然后用低阶求积公式求每一段的积分值，然后累加就是整个区间的积分值了，复化方法就是这么简单。\n但是我一写公式你又头晕了。\n记住上面那一句话的本质即可，公式你对照着本质看就能看懂了。\n我们将[a,b]按步长h等分成n份，分点就是$x_k=a+kh,k=0,1,2,\u0026hellip;,n$，没毛病吧。区间有n个，所以要n+1个分点，这里下标从0开始，所以k最多取n。\n然后求出这n段的积分$I_k$，注意，分点是0到n，有n+1个分点，区间有n个，如果下标还是从0开始那么k最多到n-1。\n然后将这n个积分求和就是$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}I_k$。\n到这里是最一般的复化求积公式，没错哈。\n然后我们再用低阶求积公式求具体的$I_k$。\n例如，用梯形公式求区间$[x_k,x_{k+1}]$的积分。注意哈k从0开始，而$x_0=a$，而这边是$[a,a+h],[a+h,a+2h]$这样分区间的，所以区间是k到k+1。\n好，来用梯形公式得到$I_k=h*\\frac{f(x_k)+f(x_{k+1})}{2}$\n再试试用辛普森公式求解，$I_k=h*\\frac{f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})}{6}$\n这里$x_{k+\\frac{1}{2}}$指的是$x_k$和$x_{k+1}$的中点。\n接下来要把$I_k$代入复化求积公式了哈。\n这样就得到复化梯形公式$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}h*\\frac{f(x_k)+f(x_{k+1})}{2}$\n复化辛普森公式$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}h*\\frac{f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})}{6}$\n不过你在外面看到的式子可能不是这样的，我们来化简一下。\n首先把常数提出去。\n复化梯形公式$\\int_a^b f(x)dx=\\frac{h}{2}\\sum_{k=0}^{n-1}f(x_k)+f(x_{k+1})$\n复化辛普森公式$\\int_a^b f(x)dx=\\frac{h}{6}\\sum_{k=0}^{n-1}f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})$\n接下来，注意一下哈，$x_k,x_{k+1}$都是区间的分点，所以我在累加的时候除了两端的分点只加了一次，其他分点都加了两次，而$f(x_{k+\\frac{1}{2}})$是区间分点的中点也只加了一次。\n所以式子可以再化简一下这样就是常见的两个复化求积公式了。\n复化梯形公式$\\int_a^b f(x)dx=\\frac{h}{2}[f(a)+2\\sum_{k=1}^{n-1}f(x_k)+f(b)]$\n复化辛普森公式$\\int_a^b f(x)dx=\\frac{h}{6}[f(a)+2\\sum_{k=1}^{n-1}f(x_k)+\\sum_{k=0}^{n-1}4*f(x_{k+\\frac{1}{2}})+f(b)]$\n再来解析一下，f(a)和f(b)是区间的端点，只加了一次，所以系数是1，而$f(x_{k+\\frac{1}{2}})$是区间分点的中点也只加了一次，所以系数也不变。\n式子里的$2\\sum_{k=1}^{n-1}f(x_k)$是区间的内分点，都加了两次所以前面系数带了2。\n总之，复化方法就是这样。但是复化方法有一个不好的地方，就是他的步长h依然是我们随便选取的，我们能不能让他自己找到一个合适的步长h？\n梯形公式递推化 基于这样的想法就有了递推化梯形公式。\n原本我们将区间[a,b]进行n等分，有n+1个分点，可以得到近似公式$T_n$，如果$T_n$精度不够，我们就把步长折半，也就是把区间2n等分，得到$T_{2n}$。\n梯形公式递推化就是简化了$T_{2n}$的计算。\n我们是可以按复化梯形公式重新计算$T_{2n}$的，但是这样比较麻烦。\n梯形公式递推化注意到了我们把区间2n等分时其实新增的分点是原来分点的中点，而原来的n+1个分点可以继续利用。由此得到了一个$T_n$到$T_{2n}$的递推公式。\n$T_{2n}=\\frac{T_n}{2}+\\frac{b-a}{2n}\\sum_{k=1}^nf[a+(2k-1)\\frac{b-a}{2n}]$\n额呵呵，这公式一看就不是什么人话。\n我们说人话，简单点。\n来个例子就秒懂了。\n计算$\\int_0^1\\frac{\\sin x}{x}dx$\n首先用梯形公式不等分计算$T_1=\\frac{f(0)+f(1)}{2}=0.9207355$\n然后用递推公式计算$T_2=\\frac{T_1}{2}+\\frac{1}{2}f(\\frac{1}{2})$\n好，观察一下前面的式子，前面的$\\frac{T_1}{2}$在任何时候都是一样的，它永远是上一个值的一半。\n然后后面的项$\\frac{1}{2}f(\\frac{1}{2})$你先别管$\\frac{1}{2}$。[0,1]二等分增加了1个分点$\\frac{1}{2}$，所以后面是新增加分点$f(\\frac{1}{2})$的和。\n那么下一次呢，把$[0,\\frac{1}{2}],[\\frac{1}{2},1]$再二等分增加分点$\\frac{1}{4},\\frac{3}{4}$，所以之后就是$f(\\frac{1}{4})+f(\\frac{3}{4})$\n那这个系数$\\frac{1}{2}$是怎么递推的？\n这个系数是$\\frac{b-a}{2n}$，分子是积分区间长度b-a，分母是2,4,6,8,10以此类推。\n这下秒懂了吧。\n但是递推化梯形公式还是有问题的，就是梯形公式收敛速度太慢了。\n龙贝格算法 这就要龙贝格算法解决了。\n龙贝格算法其实也是一种事后估计方法。但我想说的是，龙贝格算法更是一种理查德森外推。\n这个理查德森外推是一种通用的数值方法，龙贝格算法是他的特例，之后你还会遇见的。\n他是这样的，如果你有一个数值公式$T(h)$，h是某个参数，不一定是步长，任何参数都可以。我们这个方法是一个非常通用的方法。\n你对$T(h)$进行泰勒展开得到误差估计\n$T(h)-I=\\alpha_1 h+\\alpha_2h^2+\u0026hellip;+\\alpha_nh^n+\u0026hellip;$\n接下来我想提高这个数值公式的精度为$h^2$应该怎么做？\n答案是把h折半，也就是把$\\frac{h}{2}$代入公式得到\n$T(\\frac{h}{2})-I=\\alpha_1 \\frac{h}{2}+\\alpha_2\\frac{h^2}{4}+\u0026hellip;+\\alpha_n\\frac{h^n}{2^n}+\u0026hellip;$\n然后我们把h的一次方消掉，也就二式乘以2减去1式得到\n$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}-I=-\\frac{1}{2}\\alpha_2 h^3-\u0026hellip;$\n也就是说，左边那个$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}$与精确值I的误差是$h^2$阶的，所以$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}$是精度更高的近似值，我们记作$T_1(h)$\n然后如法炮制可以把精度依次提高到h的三次方、四次方、五次方\u0026hellip;\u0026hellip;\n而且不难推算出通用的递推公式\n$T_m(h)=\\frac{2^mT_{m-1}(\\frac{h}{2})-T_{m-1}(h))}{2^m-1}$\n它的误差是h的m+1次方阶的。\n龙贝格算法就是理查德森外推法在求积公式里的特例或者说运用。\n只不过在求积公式里$T(h)$的泰勒展开是\n$T(h)-I=\\alpha_1 h^2+\\alpha_2h^4+\u0026hellip;+\\alpha_nh^{2n}+\u0026hellip;$\n也就是没有奇数阶，所以我要升阶的话折半一次是\n$T(\\frac{h}{2})-I=\\alpha_1 \\frac{h^2}{4}+\\alpha_2\\frac{h^4}{16}+\u0026hellip;+\\alpha_n\\frac{h^{2n}}{4^n}+\u0026hellip;$\n那么每次都是下式乘以4减去上式，\n导致递推公式是\n$T_m(h)=\\frac{4^mT_{m-1}(\\frac{h}{2})-T_{m-1}(h))}{4^m-1}$\n并且误差阶每次加2而不是加1。\n当然，这是我的讲法，更常见的讲法是按误差的事后估计法来推导的，也就是下面这样：\n我们先来计算一下误差，有误差才能事后估计嘛。\n从简单的梯形公式开始。\n按照拉格朗日插值余项，梯形公式的误差$I-T_n=\\sum_{k=0}^{n-1}-\\frac{h^3f\u0026rsquo;\u0026rsquo;(\\alpha_k)}{12}$\n而这里为了消掉中值，我们认为h很小，从而$hf\u0026rsquo;\u0026rsquo;(\\alpha_k) \\approx f\u0026rsquo;(x_{k+1})-f\u0026rsquo;(x_k)$\n也因此梯形公式的误差$I-T_n=\\sum_{k=0}^{n-1}-\\frac{h^3f\u0026rsquo;\u0026rsquo;(\\alpha_k)}{12}\\approx \\frac{-h^2}{12} [f\u0026rsquo;(b)-f\u0026rsquo;(a)]$\n这个误差和$h^2$是一个数量级的。\n类似地，可以推出辛普森公式$S_n$的误差和$h^4$一个数量级，而在牛顿-科特斯公式里n=3的时候得到的三次插值公式对应的求积公式我们称为科特斯公式是$h^6$数量级的。（科特斯公式前面没让你用，但是这里确实需要了，你想记的话也可以回去记啦）\n基于此我们进行误差事后估计。\n对了，在这里$T_n,S_n,C_n$的角标n指的是复化公式里区间的段的数量。\n我们这里说要变步长其实就是变区间的段数嘛。\n复化梯形公式误差和$h^2$是一个数量级的，所以步长变为原来的一半也就是区间分段分为原来的2倍，则误差大概变成了原来的四分之一。\n所以$\\frac{I-T_{2n}}{I-T_n}\\approx\\frac{1}{4}$\n熟悉的式子。\n我们又可以得到更精确的$T_{2n}$的估计值$I=\\frac{4}{3}T_{2n}-\\frac{1}{3}T_n$了。\n不过这里我要把式子写成\n$S_n=\\frac{4^1}{4^1-1}T_{2n}-\\frac{1}{4^1-1}T_n$\n没错，熟悉的结果，对复化梯形公式进行事后估计得到了复化辛普森公式。\n接下来你应该都猜得到结果了。\n$C_n=\\frac{4^2}{4^2-1}S_{2n}-\\frac{1}{4^2-1}S_n$\n$R_n=\\frac{4^3}{4^3-1}C_{2n}-\\frac{1}{4^3-1}C_n$\n额，这里$R_n$是复化龙贝格公式啦。\n总之，现在按这样的方法进行加工，就可以逐步提高求积精度，这就是龙贝格算法。\n你应该也能想到我要掏出这样的图了。\n现在这样步长h是可以随着计算折半的，其实我也觉得到这里就很完美了。\n高斯求积公式 谁知道高斯求积公式出现了。\n高斯求积公式彻底解决了插值点的选取问题，用这个方法选取的一定是最优插值点，而且代数精度是最高的。\n选取适当的$x_0,x_1,\u0026hellip;,x_n$这n+1个点，高斯求积公式可以达到至少2n+1的代数精度。\n这里选择的这些插值点被称为高斯点。\n如果选取了n个高斯点得到的高斯公式称为n点高斯公式。（注意我前面说的是n+1个点有2n+1阶代数精度，那n个点就有2n-1阶代数精度）\n1点高斯公式就是中矩形公式。\n我们来试着求求看两点公式高斯。\n注意，在高斯公式里，我们只能求[-1,1]的积分。\n如果你想求解[a,b]的积分，可以先换元。\n做一个简单的变换，令$x=\\frac{b-a}{2}t+\\frac{a+b}{2}$，就可以把积分区间变成[-1,1]了。\n现在想求两点高斯公式就是要找组合系数$A_1,A_2$和合适的分点$x_1,x_2$使得\n$\\int_{-1}^1f(x)dx=A_1f(x_1)+A_2f(x_2)$\n并且两点高斯公式具有2*2-1阶代数精度，所以他对$1,x,x^2,x^3$都精确成立。\n这样你会得到一个四元三次方程组，根本求解不来啊亲。\n还好，有数学家已经“注意到”高斯点的求解了。\nn点高斯公式的n个高斯点，就是n次勒让德多项式的零点。\n所以真正实用的求积方法是，想用n点高斯公式先写出n次勒让德多项式，再求出其零点，然后零点就是求积点。现在已知了求积节点，不就回到了最开始的机械求积方法了？用那里的方法求出$A_k$就可以了。\n那么这些结论都是怎么来的？\n我们等下再说，因为下面我们要直接来一个加强版的。\n反正到高斯求积公式这里我们的结论就是高斯点是n次勒让德多项式的零点，有了高斯点就可以用机械求积的方法得出组合系数$A_k$了。\n带权高斯求积公式 所谓高斯求积公式的加强版就是增加了权函数的机制。\n这是因为现实里有些函数啊他可能长这样：\n$\\int_{a}^bxe^{x^2}dx$\n如果直接用高斯求积公式是可以求解的，但是效率不高。\n于是又提出了带权高斯求积公式。\n这里我们把x看做权函数$\\rho(x)$，$e^{x^2}$看做要求的积分$f(x)$，于是我们要求的就相当于是带权函数的积分$\\int_{a}^b\\rho (x)f(x)dx$了。\n我们前面说的高斯求积公式其实就是权函数为1，区间为[-1,1]的特殊情况，所以这确实是一个加强版的公式。\n那么这个加权的想法是怎么来的呢？\n其实还是从线性代数的角度想出来的。\n在[快乐数学]傅里叶变换和拉普拉斯变换，链接https://www.bilibili.com/opus/953797131335893047?spm_id_from=333.1387.0.0里我们提到，区间上的连续函数的全体构成线性空间，并且我们可以定义内积结构使之变为内积空间，在那里我们说：\n可以定义内积$\\int_a^bf(x)g(x)dx$为f(x)和g(X)的内积。\n但其实，这个内积条件是可以加强的，我们可以定义带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$，这样也能得到一个内积空间。\n基于此就可以想到给高斯求积公式也整个带权版。\n为啥呢？这是由高斯求积公式的性质决定的。事实上高斯求积公式和其对应的内积空间密切相关。\n我们设$x_i$是n点带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，那么可以定义一个n次多项式$\\omega_n=(x-x_1)(x-x_2)\u0026hellip;(x-x_n)$，这个多项式就是由带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的一个正交多项式。\n也就是说:\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n我们来证明一下。\n先假设$x_0,x_1,x_2,..,x_n$这n+1个点是带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，那么带权高斯公式$\\int_{-1}^1\\rho (x)f(x)dx=\\sum_{k=0}^nA_kf(x_k)$就应该有2n+1次代数精度。\n这是带权高斯公式能达到的最低代数精度嘛，没问题的。\n这也就意味着，这个带权高斯公式对任意次数不小于2n+1的多项式都严格成立，没有任何误差。\n那我就取$f(x)=P_m(x)$了，这里的$P_m(x)$就是定理里说的任意次数小于等于n的多项式。\n既然$P_m(x)$次数小于等于n，而$\\omega(x)$次数是n+1(这里有n+1个高斯点，所以次数是n+1而不是前面说的n)，那么$\\omega(x)P_m(x)$次数就小于等于2n+1，刚好在带权高斯公式严格成立的范围内。\n现在要证明的是$\\omega(x)$与之带权正交，所以就是要算一下内积呗。\n由于带权高斯公式严格成立没有误差所以$\\int_{a}^b\\rho (x)\\omega(x)P_m(x)dx=\\sum_{k=0}^nA_k\\omega(x_k)P_m(x_k)$\n由于$\\omega(x)$的零点刚好就是$x_k$，所以等式右边是0，这也就意味着$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n那反过来，如果我找到了若干点$x_k$把他拼成$\\omega(x)$，并且满足$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交，只要能证明求积公式$\\int_{a}^b\\rho (x)P_m(x)dx=\\sum_{k=0}^nA_kP_m(x_k)$有至少2n+1次代数精度就说明$x_k$是高斯点了。\n这是可以证明的。\n我们用$\\omega(x)$除以$P_m(x)$，得到$P_m(x)=\\omega(x)q(x)+r(x)$，由于r(x)是余项所以他的次数小于除式$\\omega(x)$的次数n+1也就是小于等于n，而被除式$P_m$次数小于等于2n+1，所以商式的次数小于等于2n+1-除式次数(n+1)=n。\n那么我们把这个带余除法的式子代入就有\n$\\int_{a}^b\\rho (x)P_m(x)dx=\\int_{a}^b\\rho(x)\\omega(x)q(x)dx+\\int_{a}^b\\rho(x)r(x)dx$\n我们条件里说$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交，而q(x)次数小于等于n并且前一个积分恰好就是$\\omega_(x)$与q(x)的带权内积，所以前一个积分是0。\n接着看后一个积分，由于高斯求积公式还是插值型的求积公式，所以后一个积分仍然至少有n次代数精度，而后一个积分的被积函数次数小于等于n所以他的求积公式仍然是准确的，因此有$\\int_{a}^b\\rho(x)r(x)dx=\\sum_{k=0}^nA_kr(x_k)$\n注意哦，你看我们的带余除法的式子：\n$P_m(x)=\\omega(x)q(x)+r(x)$\n你把$x_k$代入$\\omega(x_k)$是0，所以$P_m(x_k)=r(x_k)$因此\n$\\int_{a}^b\\rho (x)P_m(x)dx=\\int_{a}^b\\rho(x)\\omega(x)q(x)dx+\\int_{a}^b\\rho(x)r(x)dx=\\sum_{k=0}^nA_kr(x_k)=\\sum_{k=0}^nA_kP_m(x_k)$\n也就是说，现在我们的求积公式有至少2n+1阶代数精度，所以$x_k$就是高斯点。\n有这层关系在我们才有了求高斯点的方法。\n在带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间中总是有基函数$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$。\n虽然这组基不是正交基但是我们在高等代数里学过如何用一组基得出正交基，甚至得出标准正交基。\n这个方法就是施密特正交化。\n如果我们取权函数$\\rho(x)=1$，区间[a,b]为[-1,1]，这就是最开始说的高斯求积公式嘛，对基函数$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$进行施密特正交化就能得到新的一组正交基，然后再进行标准化就能得到标准正交基，而这组标准正交基就是所谓的勒让德多项式了。\n对于线性空间的一组正交基来说，它与任意其他基之间都是正交的。\n而你从中选一个n次多项式$P_n(x)$出来，再从内积空间中随便选一个次数小于n的多项式g(x)，它肯定不是由这个$P_n(x)$线性表出的嘛，所以他一定与$P_n(x)$线性无关，从而$P_n(x)$就与任意次数小于n的多项式正交了。\nOK，你现在再回去看定理。\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n而内积空间中的正交基中的任意一个n+1次多项式都和次数小于n+1也就是次数小于等于n的多项式带权正交。\n由于$\\omega(x)=(x-x_1)(x-x_2)\u0026hellip;(x-x_n)$的最高次系数是1，所以这个$\\omega(x)$是啥啊？\n不就是你从内积空间中的标准正交基里次数为n+1次的多项式吗？\n终于结束了。\n也就是说，你想求n+1点带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，就是要找$\\omega(x)$的零点，而$\\omega(x)$就是由带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基里的n+1次多项式$P(x)$，所以要找高斯点就是找$P_(x)$ 的零点。\n对于前面说的$\\rho(x)=1$这样的特例带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基就是勒让德多项式，我从勒让德多项式里取次数为n+1 的多项式，求他的零点，就得到高斯点了。\n那如果是最一般的带权高斯公式呢？\n方法一样的，我还是先找到带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基。那怎么找呢？\n高等代数里已经学习过了，将基$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$进行施密特正交化得到一组正交基。\n然后呢，我再进行标准化，就得到标准正交基了。\n然后再取标准正交基里次数为n+1的多项式，再求他的零点即可。\n但是你仔细想想，真的需要标准化吗？\n其实不用，所谓的标准化就是在原来正交基的基础上给基除以其长度嘛。\n但是我只要求零点就可以了，你基缩放个常数倍影响零点吗？不影响的。\n所以其实根本就不用什么标准化，只需要正交化然后算零点就可以了。\n那反过来$\\rho(x)=1$的情况我一定要去记整个勒让德多项式吗？\n其实也不用的。\n勒让德多项式是什么$\\frac{n!}{(2n)!}\\frac{d^n}{dx^n}[(x^2-1)^n]$\n前面有一个系数$\\frac{n!}{(2n)!}$，这玩意存不存在影响零点吗？不影响的，这是标准化添加的额外的系数，我只求零点的话不要也罢。\n所以如果我想求n点高斯公式的高斯点，只要计算多项式$\\frac{d^n}{dx^n}[(x^2-1)^n]=0$的零点就可以了。\n这样记忆量会下降一点。\n但是话又说回来了，真的每次都要这么麻烦吗？\n其实也不用。\n其实啥也不用记。\n我们可以直接利用刚刚的性质求解高斯点。\n例如我想找$\\int_0^1\\sqrt xf(x)dx$的两点高斯求积公式。\n我们是要构造$\\omega(x)=(x-x_1)(x-x_2)$求零点的嘛，显然$\\omega(x)$是一个首项系数为1的二次多项式，我们直接设为$x^2+bx+c$。\n然后回去看看性质。\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n所以$\\omega(x)$与多项式1，x带权正交。\n而这里权函数是$\\sqrt x$，既然$\\omega(x)$与1，x带权正交的话就有：\n$\\int_0^1\\sqrt x \\omega(x)1dx=0$\n$\\int_0^1\\sqrt x \\omega(x)xdx=0$\n这不是个含有两个未知量的两个方程吗？我直接解方程不就完事了。\n解得$b=-\\frac{10}{9},c=\\frac{5}{21}$\n然后求$x^2-\\frac{10}{9}x+\\frac{5}{21}=0$的根就得到两个高斯点为$0.821162,0.289949$了。\n接下来你可以用前面的方法求解系数$A_1,A_2$了。\n","date":"2024-12-21T13:49:00+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%952-%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值计算方法(2) 数值积分方法"},{"content":"初次发布于我的个人文档\n之前有一期简单介绍了一下拉格朗日插值和数值积分微分方法，我感觉有点太简单了。所以这次打算开个系列，好好唠一唠。\n什么是插值 在小学阶段，有一种题目叫找规律。\n什么1,2,6,7,10要你填下一个数。但是经常去论坛逛的人会发现，网友啊总是会给一个惊为天人的答案，什么114514啊之类的。\n然后抛出一个多项式，说你看这个114514啊是这个多项式在n=6的取值，前面的几个数也满足。所以这个找规律题下一个是114514。\n事实上，这就是完成了一次数学上的插值任务。\n他呢，相当于是已知若干点（在我前面的例子是已知(1,1),(2,2),(3,6),(4,7),(5,10),(6,114514))要找一个多项式恰好过这些点。\n这就是一个插值问题。\n当然，到了高中上了大学，你应该听说过导数这个玩意儿，所以有的时候我们还会要求多项式在某点的某阶导数是多少。\n这也是插值问题。\n我们也可以综合起来，既要求函数值又要求导数值，这样综合的插值问题我们也有办法解决。\n我们先看最简单的，也是你们一定了解过的。\n泰勒插值 看到名字不知道你想起泰勒公式了没有，没错泰勒插值就是泰勒多项式。\n你可以回去翻翻泰勒公式的引入。\n我给你看看百度百科是怎么介绍的。\n在数学中，泰勒公式（英语：Taylor\u0026rsquo;sFormula）是一个用函数在某点的信息描述其附近取值的公式。这个公式来自于微积分的泰勒定理（Taylor\u0026rsquo;s theorem），泰勒定理描述了一个可微函数，如果函数足够光滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这个多项式称为泰勒多项式（Taylor polynomial）。泰勒公式还给出了余项即这个多项式和实际的函数值之间的偏差。\n你看哈，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这不就是插值问题吗？\n也就是说，泰勒公式事实上是已知某一点的各阶导数，然后找了一个多项式，它的各阶导数值恰好是所给的导数值。\n很显然，这就是我们前面说的给导数型的插值问题。其解就是泰勒多项式。\n并且我们知道，泰勒多项式是唯一的。这个证明非常简单，并且我们可以进一步如果你要求到了函数的无穷阶导数恰好是f(x)的各阶导，那么我们知道，你得到的是泰勒级数，也就是函数f(x)的泰勒展开式。这里我们一并证明了。\n我们假设，除了泰勒公式之外还有一个多项式（对级数的情况就是另一个幂级数）$p(x)=\\sum_{n=0}^{+\\infty}a_n(x-x_n)^n$它也满足要求，\n对级数的情况，所谓的满足首先得满足p(x)收敛吧。所以还得要求p(x)在$x_0$附近内闭一致收敛于f(x)。\n在这种情况下，不管是n有限的泰勒插值，还是n趋于无穷大的泰勒插值，最终的p(x)都可以逐项求导。\n我们求n阶导看看，\n$p^{(n)}(x)=n!a_n+(n+1)n*\u0026hellip;32a_{n+1}(x-x_0)+\u0026hellip;$\n再取$x=x_0$就有$a_n=$泰勒多项式对应项的系数，从而插值问题的泰勒多项式是唯一的，函数的泰勒展开式也是唯一的。\n当然，泰勒展开不是本文关心的，我们只关心插值问题的泰勒多项式是唯一的。\n既然如此，我们不禁要问，那已知n个点的函数值的插值问题其解是不是唯一的呢？\n已知函数值的插值问题的唯一性 看标题就知道了，当然是唯一的。\n我们假设$p(x)=a_0+a_1x+a_2x+\u0026hellip;+a_nx^n$\n这里有n+1个系数，所以我们需要给定n+1个不同的点，或者说n+1个点需要用n次插值多项式插值。\n如果我们将这n+1个点代入就能得到\n$a_0+a_1x_i+a_2x_i+\u0026hellip;+a_nx_i^n=y_i$\n显然，这是一个线性方程组，并且还有更令人兴奋的，\n它的系数矩阵的行列式就是范德蒙德行列式。\n从而，其系数矩阵的行列式是$x_i-x_j$的乘积，又由于这n+1个点是不同的，所以它的系数矩阵的行列式不为0。\n那么根据克莱姆法则，这个线性方程组就有唯一解。\n所以插值多项式是唯一的。\n下一个问题自然就是怎么求解了。\n拉格朗日插值 你是可以硬解刚刚的方程组啦，但是这有点痛苦。\n拉格朗日插值的方法是，这样的：\n你不是要求$p(x_i)=y_i$吗？\n如果我能找到一系列多项式$l_k(x)$在$x_k$处取1，其他地方（指$x_1,x_2,x_3,\u0026hellip;,x_n$但不包含$x_k$)取0,\n那么p(x)不就是$y_i l_k(x)$$吗？\n这就是拉格朗日插值法的思想。\n其中$l_k(x)$被称为插值基函数。\n那么我们怎么找到插值基函数呢？\n其实很简单，$l_k(x)$在其他点取0从而其他点都是插值基函数的零点，所以插值基函数$l_k(x)$有因子\n$\\prod_{i \\neq k}(x-x_i)$\n那么我们怎么保证$l_k(x)$在$x_k$处取1呢？\n很简单啊，把$x_k$代入刚刚的可能的因子，把代入的结果除掉不就行了？\n也就是说$l_k(x)=\\frac{\\prod_{i \\neq k}(x-x_i)}{\\prod_{i \\neq k}(x_k-x_i)}$\n这就是拉格朗日插值基函数了。\n则拉格朗日插值多项式就是\n$p(x)=\\sum_{k=1}^n y_k l_k(x)$\n这就是拉格朗日插值公式了。\n关于插值公式，这个插值公式呢他是一个多项式。\n前面我们说过，n+1个节点要用n次多项式来插值，有时我们也说这样的插值是n次的。或者说，进行了n次插值。\n特殊的，如果是一次插值和二次插值，有时我们会说成是线性插值和抛物插值。\n接下来，如果我们把拉格朗日插值进一步优化，你就能得到埃特金插值。\n埃特金插值 当然，这个埃特金插值说的优化但其实不是优化公式本身，而是给计算过程进行了优化。\n前面我们说的拉格朗日插值有个很大的问题，就是他不具备承袭性。所谓承袭性也就是说我们已知n个点的插值多项式了，现在又加了一个点$x_{n+1}$，我们能在前面得到的插值多项式的基础上直接优化改进，直接以很小的计算量算出新的插值多项式。\n埃特金插值源于这样的观察，首先我们要画一张这样的差值表\n第一列是已知的点的横坐标，第二列是纵坐标。\n我们在表的最上面一项和其他项之间进行线性插值，你会发现得到了第三列，也就是两个节点的线性插值。\n如果在第三列的基础上再进行这样的线性插值得到的刚好是三个点的二次插值。\n进一步地，如果在n次插值的基础上再进行线性插值就会得到n+1次插值多项式。\n因此，想计算$x_0,x_1,x_2,x_3$的三次插值多项式，可以按表的方式计算到第五列。\n如果接下来增加了$x_4$这个点，只需要计算表最下面一列就可以得到新的四次插值多项式了。\n这就是埃特金插值，也称为埃特金逐次插值法。\n牛顿插值 不过我更建议大家用牛顿插值。\n因为牛顿插值在前面两种方法的基础上进一步优化，他也保证了承袭性，并且我们可以直接掏出一个公式。\n牛顿插值源于对拉格朗日插值基函数的观察。\n你看哈\n$l_0(x)=y_0$\n$l_1(x)=y_0\\frac{x-x_1}{x_0-x_1}+y_1\\frac{x-x_0}{x_1-x_0}$\n有没有什么联系？\n似乎很难看出来，但如果是这样的式子呢？\n$l_1(x)=y_0\\frac{x-x_1}{x_0-x_1}+y_1\\frac{x-x_0}{x_1-x_0}=y_0+\\frac{y_1-y_0}{x_1-x_0}(x-x_0)$\n这下一眼就看出来了吧。\n$l_1(x)=l_0(x)+\\frac{y_1-y_0}{x_1-x_0}(x-x_0)$\n更进一步地，可以发现\n$l_2(x)=l_1(x)+\\frac{\\frac{y_1-y_0}{x_1-x_0}-\\frac{y_2-y_1}{x_2-x_1}}{x_2-x_0}(x-x_0)(x-x_1)$\n大佬这注意力真是恐怖如斯啊！！！\n反正这个式子交给我我是不可能注意到的。\n但是现在结论已经公之于众了，而且结论非常漂亮。\n现在大家不难注意到，$l_{n+1}(x)=l_n(x)+$一个式子。\n而这个式子有特征的，它的因子恰好是$(x-x_0)(x-x_1)\u0026hellip;(x-x_{n-1})$\n而前面那个分式，分母是$x_{n-1}-x_0$，分子是两个式子作差，而减式和被减式的结构还是这个式子原本的结构（递归了）。\n前面那个分式就被我们称为差商。\n我们现在递归定义差商，\n参照百度百科的定义就是\n不过我肯定是不能直接抛给你这玩意儿的，虽然很严谨没错，但是你很难看懂。\n我们真正计算差商的方式是列差商计算表。\n这个还是百度百科的图。\n但是单看这个表你可能还是不容易理解，所以我又找了一张图。\n这张图来自B站UP主@泰勒猫爱丽丝的视频，BV号BV1du411a7qB。\n这其实就是差商计算表但是他上了个色，现在就简洁好看多了。\n第一列还是插值点的横坐标，第二列是纵坐标。\n纵坐标其实就是对应点$x_i$的0阶差商$f[x_i]$。（归纳奠基）\n接着相邻两项作差当1阶差商的分子。\n我们用下一项-上一项，例如$f[x_1,x_2]$的分子就是$f[x_2]-f[x_1]$\n那么分母呢？\n你看泰勒猫爱丽丝上的色，你先找到我们在分子里说的下一项也就是$f[x_2]$，然后找到他的颜色绿色，再回到第一列找到绿色的点的横坐标$x_2$，这就是分母的前一项了，类似地你找到$f[x_1]$的颜色红色，再回到第一列找到红色点的横坐标$x_1$，作差$x_2-x_1$就是分母了。\n所以$f[x_1,x_2]=\\frac{f[x_2]-f[x_1]}{x_2-x_1}$\n类似地，你会发现$f[x_i,x_{i+1},\u0026hellip;,x_j]=\\frac{f[x_{i+1},x_{i+2},\u0026hellip;,x_j]-f[x_i,x_{i+1},\u0026hellip;,x_{j-1}]}{x_j-x_i}$。\n分母刚好就是左边[]记号内的两个端点的差。分子则是比他低一阶差商的差。并且你会发现，分子的前一项缺了$x_i$，后一项缺了$x_j$，这是直接从式子里看出差商规律的办法。\n当然，自己手动计算的话我还是建议用刚刚说的那种上色+差商计算表的方法。\n拉格朗日插值余项 现在我们有插值的计算公式了，但是很多时候插值做的其实是拟合的工作而不是前面说的找规律问题，那么我就要问了，我拟合的插值多项式和真实的f(x)的误差是多少，也就是要求余项$R_n=f(x)-p_n(x)$。\n下面简单给个拉格朗日插值余项的结论，其定理的证明网上到处都是，我也没必要再赘述了。\n关于拉格朗日插值的误差，有如下的拉格朗日插值余项定理，\n设[a,b]上有插值节点$x_0,x_1,\u0026hellip;,x_n$，f(x)在[a,b]上有连续的直到n+1阶导数，且希望$f(x_i)=y_i$，\n那么就有当$x \\in [a,b]$时，有\n余项$R_n(x)=f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\prod_{k=0}^n(x-x_k)$\n其中$\\xi \\in [a,b]$\n这就是拉格朗日插值的余项了。由于插值多项式是唯一的，所以其他的插值方法的余项也是这个。\n聪明的你肯定越看越熟悉啊，这余项怎么感觉和泰勒公式的拉格朗日余项差不多？\n其实还真有关系。我们现在探究的插值任务要么只有导数信息，要么只有函数值信息，如果二者混合呢？\n艾尔米特插值 还有，你看那个差商的定义，你不觉得和导数是差不多的么？\n现在如果我令插值点具有等间距h，并且令间距h趋于0，所谓的各阶差商就刚好是泰勒公式的系数了。\n再次借用泰勒猫爱丽丝的视频\n他的视频实在是太优秀了，希望大家都可以去观摩一下。\n总之，我们按这样的情况推广牛顿插值就能得到兼容函数值信息和导数信息二者是艾尔米特插值方法了。\n例如，已知$x_0$的函数值和一阶导数值，$x_1$的函数值。\n那么就有\n横坐标 零阶差商(函数值) 一阶差商 二阶差商 $x_0$ $f(x_0)$ $x_0$ $f(x_0)$ $f\u0026rsquo;(x_0)$ $x_1$ $f(x_1)$ $\\frac{f(x_0)-f(x_1)}{x_0-x_1}$ $\\frac{f\u0026rsquo;(x_0)-\\frac{f(x_0)-f(x_1)}{x_0-x_1}}{x_0-x_1}$ 从而$p(x)=f(x_0)+f\u0026rsquo;(x_0)(x-x_0)+\\frac{f\u0026rsquo;(x_0)-\\frac{f(x_0)-f(x_1)}{x_0-x_1}}{x_0-x_1}(x-x_0)(x-x_0)$\n你可以把式子化简一下，不过我这里化简了反而不利于观察出式子的来历，所以就不动了。\n你可以验证一下，这个插值多项式就是满足$x_0$的函数值和一阶导数值，$x_1$的函数值的艾尔米特插值结果了。\n误差的事后估计：回看埃特金插值 现在插值体系已经比较完备了，这里我想做的是其他的事，就是让你也看出埃特金插值。\n额，牛顿插值你想直接看出来的话我也没有什么太好的办法，没法分享了。\n我提供一个通过误差的事后估计看出埃特金插值的办法。\n假定我们已知了3个节点$x_0,x_1,x_2$，在$x_0,x_1$和$x_1,x_2$之间进行一次线性插值，可以得到两个插值多项式。\n例如，我们对$f(x)=\\sqrt{x}$进行插值，取$x_0=100,x_1=121,x_2=144$，现在我们来求$\\sqrt{115}$的近似值。\n先用$x_0,x_1$进行线性插值得到$\\sqrt{115}\\approx10.71428$，然后再用$x_1,x_2$进行线性插值再把$x\u0026rsquo;=115$代入得到$\\sqrt{115}\\approx10.68182$。\n接下来我们有办法用这两个近似值得到精度更高的近似值。\n现在我们的情况是，通过两次线性插值得到了两个近似值$y\u0026rsquo;_1,y\u0026rsquo;_2$。\n那么依据拉格朗日余项定理，有\n$f(x\u0026rsquo;)-y\u0026rsquo;_1=\\frac{f\u0026quot;(\\alpha)}{2}(x\u0026rsquo;-x_0)(x\u0026rsquo;-x_1)$\n$f(x\u0026rsquo;)-y\u0026rsquo;_2=\\frac{f\u0026quot;(\\beta)}{2}(x\u0026rsquo;-x_1)(x\u0026rsquo;-x_2)$\n如果我们认为f的二阶导变化不大，也就是$f\u0026rsquo;\u0026rsquo;(\\alpha)\\approx f\u0026rsquo;\u0026rsquo;(\\beta)$，然后两式相除就有，\n$\\frac{f(x\u0026rsquo;)-y\u0026rsquo;_1}{f(x\u0026rsquo;)-y\u0026rsquo;_2}=\\frac{x\u0026rsquo;-x_1}{x\u0026rsquo;-x_2}$\n把分子分母颠倒一下就是\n$\\frac{f(x\u0026rsquo;)-y\u0026rsquo;_2}{f(x\u0026rsquo;)-y\u0026rsquo;_1}=\\frac{x\u0026rsquo;-x_2}{x\u0026rsquo;-x_1}$\n再分离常数就有\n$1+\\frac{y_1\u0026rsquo;-y_2\u0026rsquo;}{f(x\u0026rsquo;)-y_1\u0026rsquo;}=1+\\frac{x_1-x_2}{x\u0026rsquo;-x_1}$\n从而两边同时减去1，\n$\\frac{y_1\u0026rsquo;-y_2\u0026rsquo;}{f(x\u0026rsquo;)-y_1\u0026rsquo;}=\\frac{x_1-x_2}{x\u0026rsquo;-x_1}$\n因此，\n$f(x\u0026rsquo;)-y_1\u0026rsquo;=\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$\n也就是说，我们估计出了一个准确的误差$f(x\u0026rsquo;)-y_1\u0026rsquo;\\approx\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$\n这样的话，我已经知道估计出准确值和近似值的误差了，我再把误差补回去不就是一个更精确的近似值了？\n所以我们可以得到更精确的近似值为$y_1\u0026rsquo;+\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$，对本例就是10.7228。\n你会发现，这个近似值就是抛物插值的结果，这就是误差的事后估计法。\n也就是说，我们通过误差的事后估计法可以使得插值的次数+1，这不就也是埃特金插值？\n龙格现象和过拟合 现在你可能有一个大概的印象，就是说插值点越多，插值次数越高精度越高。\n但其实并不是这样的。在机器学习领域有一个叫过拟合的词，说的是你啊用这种方式拼命堆数据大力出奇迹，结果反而会变差。\n例如，你搞了一个分辨叶子的模型，然后给他喂了一万张叶子图片，结果里面的叶子都是带锯齿的，所以模型学习到了带锯齿的东西是叶子，从而你给他一个没锯齿的叶子他会判否，给他个有锯齿的其他东西他却说是叶子。\n我们插值也有类似的过拟合现象。\n插值点越多，插值次数越高，插值多项式的次数也越高，而$x^100$次方，你x稍微变一下，y就会差很多，从而会导致你的插值多项式在端点处震荡地非常离谱，导致精度反而下降了。这就是龙格现象，我个人觉得也是一种过拟合。\n参考百度百科的图，\n你会看到，高次插值多项式在两个端点处疯狂震荡，这样反而会导致精度下降。\n分段低次插值 那么怎么解决这个问题呢？答案是用多次低次插值来拟合函数。\n你给了我1,2,3,4,5,6,7,8,9,10这10个点的信息，我怎么做呢？\n我拼一个分段函数给你，x在[i,i+1]的时候，表达式就是i和i+1的线性插值。\n当然，也可以是x在[i-1,i+1]的时候，表达式是i-1,i,i+1的二次插值等等。\n总之就是给你这样的分段函数，并且他们的插值次数都不高。\n这就是分段低次插值。\n但是这样的插值还是有问题，他在分界点往往不可导，这是我们不希望看到的。\n样条插值 所以样条插值应运而生。\n其实理论说起来也比较简单。\n例如还是已知1,2,3,4,5,6,7,8,9,10的信息。\n我把他分成[1,2],[2,3],\u0026hellip;,[9,10]这样的9段。\n每一段我都用一个三次函数拟合（这个函数被称为样条函数，这样的样条插值被称为三次样条插值，当然你也可以通过改变段的分法来改变样条函数的次数）。\n在这里每一段只有两个点，按道理线性插值就足以了啊，为什么要用三次函数呢？\n这是因为我要强行加条件了，我要求这个样条函数在分界点连续，即2,3,4,5,6,7,8,9处函数值相等。\n这是附加了8个条件。\n而原本有9个三次函数，每个三次函数有4个系数，也就是需要36个条件。\n现在只用了8个，还绰绰有余呢。\n现在我再加强条件，要求样条函数在分界点一阶可导，即要求分界点左右导数相等，这又是8个条件。\n进一步，我还要求二阶可导，又是8个条件。\n这才用了24个条件。还剩下12个条件。\n当然，我自然是需要要求函数在1到10每个点上函数值等于所给的需要插值的函数值的，所以还有2个条件。\n这两个条件给1和10这两个最后的边界点，可以是规定边界点的一阶导或者二阶导都可以，反正把这两个条件用了就可以了。\n然后用计算机来求解就ok了。\n额，你不会觉得36元一次方程组我要手算吧，不会吧不会吧。\n真的有那个毅力手算的朋友，告诉你一下，最后的线性方程组是一个三对角方程组，后面我会介绍追赶法求解三对角方程组的方法的，这种方程最好用那个方法解。\n","date":"2024-12-21T10:12:41+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%951-%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95/","title":"数值计算方法(1) 插值方法"},{"content":"在异步与资源调度-以浏览器事件循环为例我们以浏览器为例简单的介绍了一下资源的调度和事件循环，在那一期我们就留了一个坑。这一期我们就来填上，介绍一下什么是进程、线程、协程，以及他们的区别和联系。\n硬件资源调度 今天我们讲的这些概念都来自于操作系统，是操作系统为了充分利用硬件资源的机制。\n我们先来设想一个最简单的资源调度方案。这也是在IBM7094这样的上古机器里使用的资源调度方案。\n在当时像IBM7094这样的计算机，造价在250万美元以上，非常昂贵因此我们希望充分利用计算机，尽可能地利用上计算机提供的算力资源。\n这台计算机使用的就是批处理方法，计算机没有额外动作只会一个一个地执行任务。用户在磁带上编程，然后计算机不停的执行磁带上的代码，当完成了一个任务或者这个任务出现了异常，那么计算机就执行下一个任务。\n这样的资源调度非常简单，但是后来人们还是发现了一些问题。\n我们还是以现代计算机执行的任务为例，有的时候我可能会写这样的代码\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(){ int a = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); return 0; } 这个代码的问题在于，当程序执行到scanf的时候计算机会等待用户输入，CPU啊之类硬件的就停止工作了。这太浪费了啊！\n这种任务被我们称为是IO密集型任务，当CPU在执行这样的任务的时候我们希望CPU能在IO阻塞的时候执行其他任务。\n那怎么弄呢？\n很简单其实，类似于计算机网络中使用的时分复用，我们可以让多道程序交替执行从而提高效率。\nA程序先执行需要CPU的任务，接着进入需要磁盘IO的任务，CPU就切换到任务B的执行，同时\n磁盘放在继续完成任务A。\n这样的多道程序交替执行就是现代计算机资源调度的一个核心。\n这种方式也被称为并发，并发本质上只有一个CPU在干活，但是他交替执行多个程序，这样不仅提高了CPU利用率而且在用户看来，他会感觉是多个任务同时执行。\n但是我们怎么才能做到这样的并发呢？\n熟悉计算机硬件的人可能会说，只需要修改PC寄存器就行了。（也就是修改CPU正在执行的指令）\n但是\n如果程序A是\n1 2 3 mov ax, 1 mov bx, 1 add ax,bx 也就是ax寄存器存1，bx寄存器存1，执行1+1\n程序B是\n1 2 3 mov ax, 10 mov bx, 10 add ax, bx ax寄存器存10，bx寄存器存10，执行10+10\n我们这样生硬的切换PC就会出现问题了。\n程序A可能已经把ax改成1了，接着你进入了程序B，把ax改成了10，接着B执行完了又回到A则ax还是10，程序A最后就会输出10+1=11了。\n这就出了问题。\n因而，我们需要一个数据结构来存储程序A执行到哪里了，执行的时候各种变量是多少。在操作系统中，这个数据结构被称为PCB。\n但是这样会导致运行中的程序需要额外记录PCB，这就导致运行中的程序和其他程序不一样了。\n所以我们又抽象了一个概念，叫做进程，它的意思就是进行中的程序。\n进程 再次重复一遍，进程就是运行中的程序。现在我们对硬件资源的调度就是对进程的调度。\n为了更好地管理进程，我们还会根据进程的状态对进程进行分类。\n当我创建进程的时候我们说进程处于新建态，\n接着进程会等待CPU的执行，这时是就绪态，通俗的说就是进程已经准备就绪了，随时可以被CPU执行。\n执行中的进程进入了运行态，而执行完成的进程就进入了终止态。\n前面我们还说了磁盘IO会阻塞进程，这时的经常处于阻塞态。\n进程的调度策略，我们前面已经以浏览器为例介绍了一种方案了就不再详细说明了。\n前面我们说我们对硬件资源的调度就是对进程的调度，多道程序交替执行就是现代计算机资源调度的一个核心，那么计算机是如何实现多个进程的交替执行呢？\n这个我们暂时只讲一半。\n因为进程的切换涉及到两块。\n第一块我们之后再说。就是这样的：\n操作系统为了防止进程之间相互影响，例如：\n进程A设置内存地址为100的内存数据为1，进程B却来设置这块内存为2，这可能会导致进程A报错打架。所以操作系统引入了内存映射表，引入了虚拟内存的机制。\n思路很简单，进程A看到的内存100，其实是在真实的内存里可能是1100，但是进程B看到的内存100在真实内存里是2100。每次看到一个进程访问内存100，我就先去内存映射表里看看这个内存地址100在真实的内存里到底是哪个地址然后再执行指令。（但是虚拟内存的存在导致了不同进程之间的资源是不共享的）\n所以，进程之间的切换还要照顾到虚拟内存和内存映射表的切换，这一部分等我们以后有机会讲操作系统的内存调度的时候再说吧。\n进程切换的另一块是不同进程之间指令序列的切换，我们来讲这个。\n进程的指令切换 不过我更想做的是我们自己写个函数调用来实现一下进程间的指令切换。有没有办法呢？\n可以的。\n我们来试试看：\n假如进程1是这样的代码\n1 2 3 4 5 6 7 8 内存地址100:A(){ B(); 内存地址104 } 内存地址200:B(){ yield(); 内存地址204 } 进程2是\n1 2 3 4 5 6 7 8 内存地址300:C(){ D(); 内存地址304 } 内存地址400:D(){ yield(); 内存地址404 } 我们先启动进程1，先进入地址100的A函数，然后A函数调用B函数，B函数执行yield函数。yield函数的意思是切换到另一个进程。\n那么CPU会执行C函数，然后C函数调用了D函数，D函数再切换到进程1，接着函数就开始返回了。\n但是我们来分析看看现在的函数调用栈。\nA调用B，104入栈。\nB调用yield，204入栈，\nC调用D，304入栈，\nD调用yield，404入栈。\n接着开始返回了，此时我们在进程1，但是出栈的时候出的是进程2的404，这不就炸了。\n你明明要运行进程1啊，怎么出了人家的东西。\n这个问题只需要稍加修改就行了，我们给进程1和2分别维护一个栈。\n这样进程1的栈只有104和204了，然后204出栈，104出栈。\n但是现在入栈的过程又不太一样了。\n还是\nA调用B，104入栈。\nB调用yield，204入栈\n但是现在要切换到进程2去了，我们要换一个栈，因此需要一个指针来指向当前的栈，还需要给两个栈分别申请内存空间。\n栈的信息存储在一个叫TCB的数据结构中，而esp是指向当前栈的指针变量。\n那么yield函数是做了什么呢？\n将当前栈的信息存起来，然后切换esp为下一个进程的栈。就这么两句简单的语句。\n现在我们来看看新建线程的时候要做什么，就是要申请一个新的栈然后先把当前的第一个语句入栈再等待执行。（注意C语言基础，语句是在出函数调用栈的时候执行的）\n出栈的时候你会发现我只说了线程1的出栈而没有说线程2的出栈。这是因为线程1已经结束了然而他没有切换到线程2。\n但是这个无伤大雅，因为\n线程2完成阻塞的任务之后会进入就绪态，当CPU空闲的时候操作系统会按一定规则唤醒一个就绪态的线程，这个就等以后有时间我们聊聊真实完整的操作系统的任务调度吧。\n像我们这样实现的所谓的进程，只实现了指令序列的切换而资源没有切换，并且没有进入操作系统内核，一直在用户态进行操作，这种所谓的进程就是协程（也称为纤程或者用户级线程）。\n这个协程呢，没有涉及到操作系统内核也就没有涉及到系统调用，甚至你自己可以在任何高级编程语言上实现。\n现在Python、kotlin、Java等高级编程语言已经有一套官方的标准库来实现协程了。（啊哈哈，还在用java 8的可以试试参考上面的方法自己手动实现一个，俺们jdk 21先跑了）\n用户级线程的问题 用户级线程始终没有进入操作系统内核但是有没有问题呢？\n有的，因为这样的线程只在用户态并发，但是在内核态什么也没做，那么操作系统怎么可能会知道你创建了多个用户级线程呢？\n试想这样的一个场景：\n进程A开了用户级线程1 用户级线程2\n用户级线程1进入了操作系统内核，也就是进入了内核态并发生了阻塞。\n那么操作系统为了高效利用CPU会将CPU的使用权交给其他进程而不是用户级线程2（这是因为在操作系统眼里只有进程A一整个进程而没有两个用户级线程，所以他在调度的时候自然不会考虑这些）。从而你会发现，用户级线程2跟着用户级线程1阻塞了，此时用户就会感到卡顿了。\n所以要想真正实现并发，必须要操作系统介入，实现内核级的线程。这就是真正的线程了。\n线程之间仍然不切换虚拟内存的内存映射表，从而线程之间是共享资源的。\n而要实现内核级线程，首先他在用户态和用户级线程没有区别需要维护两个栈。\n那么在内核态呢？\n你会发现，无非不还是栈啊什么的切换，无非还是一些函数调用，所以在内核态也还是要维护这样的两个栈。\n因此每一个线程都要在用户态和内核态维护两套不同的栈。\n当用户态通过系统调用调用了操作系统的接口说我要切换线程了，会发生什么呢？\n在用户态，我们的线程应该做和用户态线程一样的操作，入栈接下来要运行的代码。\n而在内核态，我们还是要把这个线程在内核态的信息入栈，接下来和前面类似，完成内核态的栈的切换（代码和前面其实是一样的），再从内核态离开进入另一个线程的用户态执行代码。\n如果要说的高大上一点就是，线程1将从线程2返回后要执行的代码入用户态的栈，然后通过中断（对x86架构的计算机就是执行汇编命令int 0x80）进入内核态，内核态的栈再将切换线程的代码出栈执行线程切换的代码（schedule）将执行的线程切换为线程2，然后线程2在内核态的栈再出栈执行汇编命令iret回到用户态，接着用户态的栈出栈执行线程2的代码。\n总结 总之，运行中的程序叫做进程，进程与进程之间资源是不共享的。\n而我们只在用户态实现的资源共享的利用两个栈实现的用户级线程就是协程。\n而操作系统利用两套栈实现的资源共享的并发结构就是线程。\n他们的区别是进程资源不共享，切换的时候需要切换资源也要切换指令序列。而线程只切换指令序列。\n但是相比于轻巧的协程，线程的切换开销要大，不过协程在执行需要进行系统调用的指令的时候还是会有阻塞的问题。\n但是在实际编程的时候你可能又会发现，协程是用户级实现的，不受操作系统调度的影响，程序员可以随意把控当前运行的协程是哪一个自由度更高。（以后你会看到，操作系统在进行资源调度的时候会对线程进行时间分片，程序员无法直接把控什么时候切换切出线程，当前在执行哪个线程从而会带来一些并发问题）\n","date":"2024-12-04T18:37:49+08:00","permalink":"https://ColaBlack.github.io/p/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/","title":"进程线程与协程"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文想简要介绍和推导一下拉格朗日插值和数值积分方法。\n什么是插值？ 所谓的插值就是已知几个离散点的信息视图求一个满足这些信息的函数的过程。\n如拉格朗日插值和牛顿插值就是已知f(x)在若干点的函数值希望找一个多项式函数穿过这些点。\n而艾尔米特插值则更进一步要求函数在各个点的各阶导数值都等于指定的值。\n本文只介绍最基础的拉格朗日插值和牛顿插值。\n插值的唯一性 这两种插值方法都是已知一系列点$(x_i,y_i)$，找一个多项式p(x)它穿过了这些点。\n其实这个问题你应该很容易就能找到第一个方法，待定系数法嘛。\n我们假设$p(x)=a_0+a_1x+a_2x+\u0026hellip;+a_nx^n$\n这里有n+1个系数，所以我们需要给定n+1个不同的点，或者说n+1个点需要用n次插值多项式插值。\n如果我们将这n+1个点代入就能得到\n$a_0+a_1x_i+a_2x_i+\u0026hellip;+a_nx_i^n=y_i$\n显然，这是一个线性方程组，并且还有更令人兴奋的，\n它的系数矩阵的行列式就是范德蒙德行列式。\n从而，其系数矩阵的行列式是$x_i-x_j$的乘积，又由于这n+1个点是不同的，所以它的系数矩阵的行列式不为0。\n那么根据克莱姆法则，这个线性方程组就有唯一解。\n所以插值多项式是唯一的。\n拉格朗日插值 那么怎么求插值多项式呢？\n你是可以硬解刚刚的方程组啦，但是这有点痛苦。\n拉格朗日的方法是，这样的：\n你不是要求$p(x_i)=y_i$吗？\n如果我能找到一系列多项式$l_k(x)$在$x_k$处取1，其他地方（指$x_1,x_2,x_3,\u0026hellip;,x_n$但不包含$x_k$)取0,\n那么p(x)不就是$y_i l_k(x)$吗？\n这就是拉格朗日插值法的思想。\n其中$l_k(x)$被称为插值基函数。\n那么我们怎么找到插值基函数呢？\n其实很简单，$l_k(x)$在其他点取0从而其他点都是插值基函数的零点，所以插值基函数$l_k(x)$有因子\n$$\\prod_{i \\neq k}(x-x_i)$$那么我们怎么保证$l_k(x)$在$x_k$处取1呢？\n很简单啊，把$x_k$代入刚刚的可能的因子，把代入的结果除掉不就行了？\n也就是说$l_k(x)=\\frac{\\prod_{i \\neq k}(x-x_i)}{\\prod_{i \\neq k}(x_k-x_i)}$\n这就是拉格朗日插值基函数了。\n则拉格朗日插值多项式就是\n$$p(x)=\\sum_{k=1}^n y_k l_k(x)$$这就是拉格朗日插值公式了。\n把拉格朗日插值进一步优化，你就能得到埃特金插值和牛顿插值。\n这个就不多介绍了，比较复杂而且插值公式是唯一的，你用任何方法得到的插值公式都是一样的。而且市面上大把的直接计算插值的软件和库，他们直接内置了其他的插值方法。\n拉格朗日插值余项 下面简单给个拉格朗日插值余项的结论，其定理的证明网上导出都是，我也没必要再赘述了。\n关于拉格朗日插值的误差，有如下的拉格朗日插值余项定理，\n设[a,b]上有插值节点$x_0,x_1,\u0026hellip;,x_n$，f(x)在[a,b]上有连续的直到n+1阶导数，且希望$f(x_i)=y_i$，\n那么就有当$x \\in [a,b]$时，有\n余项$R_n(x)=f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\prod_{k=0}^n(x-x_k)$\n其中$\\xi \\in [a,b]$\n这就是拉格朗日插值的余项了。由于插值多项式是唯一的，所以其他的插值方法的余项也是这个。\n数值积分方法 下面我们来介绍一下怎么用插值法来得到数值方法计算函数积分。\n对于大部分函数，我们其实都是很难求其积分的，甚至很多函数例如$e^{x^2}$这样的函数压根就没有初等原函数。所以我们需要寻找数值方法来计算他们的积分。\n一种可能的思路就是用刚刚的插值多项式来近似替代这个函数。而且我们是已知了差值余项的，余项的积分就是我们数值积分方法的误差。\n而这些都是多项式啊，都很好计算的。\n这种求积分的数值方法得到的积分公式我们都叫做差值型的求积公式。\n前面我说这只是数值求积的一种思路，其最本真的思路其实是取函数的部分函数值，用他们的线性组合来近似积分。\n也就是最一般化的求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$。\n只需要知道$A_k$就知道怎么求积了。\n而对于插值型求积公式，我们很容易就能得到$A_k$。\n插值型求积公式就是用f(x)的插值多项式近似f(x)，从而有\n$\\int_a^bf(x)dx \\approx \\int_a^bp_n(x)$\n再把拉格朗日插值公式代入得\n$\\int_a^bf(x)dx \\approx \\int_a^b \\sum_{k=1}^n y_k l_k(x)dx$\n$=\\sum_{k=1}^n y_k\\int_a^bl_k(x)dx$\n而我们最一般的求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$，从而\n$A_k=\\int_a^b l_k(x)dx$\n牛顿-科特斯公式 如果我们进一步要求，插值点的间距相等（步长为h），我们可以得到一个特殊的结论。\n我们竟然将区间长度提出来了，\n$\\int_a^b f(x)dx=(b-a)\\sum_{k=0}^n C_k y_k$\n并且，$C_k$竟然还是常数。\n我们称$C_k$为科特斯系数，可以直接查科特斯系数表得到，与具体的函数f(x)无关，只和你插值多项式的次数n有关!\n这就是牛顿-科特斯公式。\n其中n=1得到的求积公式被称为梯形公式，n=2的是辛普森公式。\n对牛顿-科特斯公式的玩法有很多，例如复化得到复化梯形公式和复化辛普森公式，还有递推化得到龙贝格公式等等。\n还有变步长使得精度尽可能高的高斯公式等等玩法。\n数值微分方法 有了积分当基石我们就可以用数值方法求解微分方程。\n我们以标准的微分方程初值问题为例介绍几个简单的方法。\n对微分方程\n$$\\frac{dy}{dx}=f(x,y)$$我们两边同时积分得到\n$$\\int_{x_n}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n}^{x_{n+1}}f(x,y)dx$$也就是\n$$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$$从而\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)dx$$而如果我们可以用数值方法求出这个积分，不就解出了这个微分方程？\n例如，我们直接用积分区间左端点得到的矩形的面积来近似积分（这个叫做左矩形求积公式）\n得到\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_n,y_n)$$这就是欧拉格式。(注意，数值微分里我们称为格式而不是公式，这里没有打错字)\n你可能会发现我这里给的欧拉格式和网上一般的不一样，其实你只要设$h=x_{n+1}-x_n$（当我设了h就默认等步长了）就能得到一般的欧拉格式了。\n$$y_{n+1}=y_n+hf(x_n,y_n)$$同样地，我们可以用积分区间右端点得到的矩形面积（右矩形公式）近似积分得到\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_{n+1},y_{n+1})$$类似地，我们设$h=x_{n+1}-x_n$就有，\n$$y_{n+1}=y_n+hf(x_{n+1},y_{n+1})$$这就是隐式欧拉格式了。\n那如果我用区间中点的矩形，还能得到两步欧拉格式：\n对微分方程\n$$\\frac{dy}{dx}=f(x,y)$$我们两边同时积分得到\n$$\\int_{x_n-1}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n-1}^{x_{n+1}}f(x,y)dx$$注意，这次是从$x_{n-1}$积到$x_n$，并且我们要求步长为h，则$x_n$是积分区间中点。\n有$y_{n+1}-y_{n-1}=2hf(x_n,y_n)$\n从而，$y_{n+1}=y_{n-1}+2hf(x_n,y_n)$\n这就是两步欧拉格式。\n还可以用刚刚说的梯形公式来求积分得到梯形格式，或者引入预报-矫正系统得到改进的欧拉格式。\n以及另外一个思路可以得到一整套的龙格-库塔方法和亚当姆斯方法。\n","date":"2024-11-30T15:26:27+08:00","permalink":"https://ColaBlack.github.io/p/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86/","title":"拉格朗日插值和数值微积分"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文想简要介绍一下如何用计算机是如何用迭代法计算方程和方程组的根的。\n不动点迭代 在高中阶段你可能学习过这样的叫蛛网图的东西：\n蛛网图迭代的极限就是函数的不动点。\n所谓不动点迭代就是利用了这样的性质。\n一般地，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，那么g(X)的不动点就是f(x)的零点。\n而g(x)的不动点又是蛛网图迭代的极限。\n如果用代数语言表示的话，就是迭代公式\n$$x_{k+1}=g(x_k)$$这就是不动点迭代求方程的根的方法。\n当然，如果要更严谨化的说明的话，就是下面的压缩映像原理：\n设g(x)在[a,b]上具有连续的一阶导数，且满足以下条件：\n1.$\\forall x \\in [a,b],g(x) \\in [a,b]$\n2.$\\exist 0 \\le L \u0026lt;1,s.t. \\forall x\\in [a,b],|g\u0026rsquo;(x)|\\le L$\n则迭代过程\n$x_{k+1}=g(x_k)$收敛，且有误差估计式：\n$|x^*-x_k|\\le \\frac{L^k}{1-L}|x_1-x_0|$\n从误差估计式看，k越大估计值$x_k$会离准确值$x^*$越来越近。\n这就足以为不动点迭代法背书了。\n牛顿迭代法 将不动点迭代进一步推广就能得到牛顿迭代法。\n前面我们知道，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，然后用迭代公式$x_{k+1}=g(x_k)$求解。\n但是我们不知道如何把方程转化为x=g(x)，牛顿迭代法就是解决了这个问题。\n思路其实也非常简单，我们知道微分有dy=f\u0026rsquo;(x)dx，于是$f(x)-f(x_k) \\approx f\u0026rsquo;(x_k)(x-x_k)$。\n从而$f(x)=f(x_k)+f\u0026rsquo;(x_k)(x-x_k)=0$\n那么$x=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$，完成啦！\n我们把f(x)=0转化为了x=g(x)的形式了，从而再使用不动点迭代得到f(X)根的迭代公式：\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这就是牛顿迭代法。\n弦截法 对于某些函数其导数不便于求解，所以我们可以用差商替代导数，这就是弦截法了。\n用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_0)}{x_k-x_0}$代入牛顿迭代法，就是弦截法了。\n如果用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$代入牛顿迭代法，就是快速弦截法了。\n雅可比迭代法 对于线性方程组，方法其实是类似的。\n线性方程组AX=b如果我们可以将其化为X=BX+f，那么用不动点迭代就有迭代公式\n$X_{k+1}=BX_k+f$\n这是我们线性方程组迭代法的基石。\n它的误差：\n$e_{k+1}=|x^-x_{k+1}|=|BX^+f-(BX_{k}+f)|=B|X^*-X_k|=Be_k$\n从而，$e_k=B^ke_0$\n那么如果$B^k$能收敛于0的话该迭代法就收敛了，可以演算得到这等价于B的谱半径（最大特征值）小于1。\n但是还是一样的，不动点迭代法说的轻巧，但是你怎么把AX=b转化成X=BX+f呢？\n其中的一种方法就是雅可比迭代法了。\n对方程组AX=b，我们将A分解为对角阵D，下三角矩阵L，上三角矩阵U使得\nA=D-L-U。\n（值得一提的是，这个分解是相当容易的，D就是A的对角元，L取A的下三角去掉主对角线，U取A的上三角去掉主对角线即可）\n那么AX=b就是\n(D-L-U)X=b\n然后移项得\nDX=(L+U)X+b\n从而$X=D^{-1}(L+U)X+D^{-1}b$\n完事了，已经变成X=BX+f的形式了，所以就有迭代公式\n$X_{k+1}=D^{-1}(L+U)X_k+D^{-1}b$\n这就是雅可比迭代法了。\n但是这个方法可以稍微变一下，我们移项的时候不一定要把L和U全部移走，这就是高斯-赛德尔迭代法了。\n高斯-赛德尔迭代法 还是安装雅可比迭代的步骤我们得到，(D-L-U)X=b移项但是只移U得到\n(D-L)X=UX+b\n然后得到$X=(D-L)^{-1}UX+(D-L)^{-1}b$\n于是就有迭代公式$X_{k+1}=(D-L)^{-1}UX_k+(D-L)^{-1}b$\n但是我们一般不会这么使用，而是再等式两边再乘以D-L得到\n$(D-L)X_{k+1}=UX_k+b$\n从而$DX_{k+1}=LX_{k+1}+UX_k+b$\n所以$X_{k+1}=D^{-1}LX_{k+1}+D^{-1}UX_k+D^{-1}B$\n这才是我们一般最爱用的高斯-赛德尔迭代公式。\n","date":"2024-11-29T14:11:03+08:00","permalink":"https://ColaBlack.github.io/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"方程求根的迭代法"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文简要介绍一下主成分分析和因子分析这两个最常用的降维算法。\n大题内容和之前发的主成分分析与因子分析没有区别，只是增加了R语言实现。\n主成分分析PCA 如果你手上有一组数据，例如是大家的语文数学英语成绩。但是现在有一个问题，咱们的试卷出得有那么一点点不好，大家的成绩都集中在一起了，也就是试卷的区分度不大。现在，我们有没有办法补救呢？\n注意：这只是一个例子而已，自然是不考虑我们进行各种变换之后的现实问题，例如这样搞成绩会不公平啊什么的。\n总之，我们的核心问题是，有没有办法对现有数据进行变换，使得数据的每一个个体尽可能被分开。\n这就是主成分分析的一个可以选择的切入点。\n那我们要选择什么样的变换呢？以及有没有办法将一个群体之间的不同个体距离拉远。\n以p维正态分布为例进行可行性探索 嗯，对我们先拿p维正态分布探索一下我们想法的可行性。\n我们假设p维随机向量X服从协方差阵为$\\Sigma$，均值向量为$\\mu$的p维正态分布。\n那么X的概率密度函数就是$P(x)=\\frac{1}{(2\\pi)^{\\frac{p}{2}}|\\Sigma|^{\\frac{1}{2}}}e^{-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)}$，我们来观察其概率密度等高线，显然，这里只有e的指数是变量，所以概率密度等高线满足：\n$$-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=C_1$$也就是$(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=C_2$\n我们可以对$\\Sigma $进行谱分解。\n谱分解说明：\n根据线性代数的知识我们可以知道，任意实对称阵A可以正交相似对角化，即\n$\\forall 实对称矩阵A,\\exist正交阵Q和对角阵\\Lambda，使得A=Q\\Lambda Q^T$\n如果我们已知A的特征值$\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n$和对应的特征向量$e_1,e_2,\u0026hellip;,e_n$，则\nQ=($e_1,e_2,\u0026hellip;,e_n$)，$\\Lambda =diag(\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)$\n这意味着:\n$$A=Q\\Lambda Q^T$$$$=(e_1,e_2,...,e_n)diag(\\lambda_1,\\lambda_2,...,\\lambda_n)(e_1,e_2,...,e_n)^T$$$$=(\\lambda_1 e_1,\\lambda_2 e_2,...,\\lambda_n e_n)(e_1,e_2,...,e_n)^T$$$$=\\lambda_1 e_1 e_1^T + \\lambda_2 e_2 e_2^T +...+ \\lambda_n e_n e_n^T$$$$=\\sum_{i=1}^n\\lambda_i e_i e_i^T$$这就是谱分解了。\n我们假设$\\Sigma$的特征值为$\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_p$，对应的特征向量为$e_1,e_2,\u0026hellip;,e_p$，那么$\\Sigma$就可以谱分解为\n$\\Sigma=\\sum_{i=1}^p\\lambda_i e_i e_i^T$，将他代入概率密度等高线方程就有，\n$(x-\\mu)^T{(\\sum_{i=1}^p\\lambda_i e_i e_i^T)}^{-1}(x-\\mu)=C_2$\n也就是，\n$$\\sum_{i=1}^p\\frac{[e_i(x-\\mu)]^T[e_i(x-\\mu)]}{C_2}=1$$这是p维的类似椭圆的方程，当p=2时这就是椭圆方程。\n这意味着，概率密度等高线是同样有着长轴和短轴。\n因而，这意味着如果我们将原始变量X进行正交变换将坐标轴旋转到长轴上就可以达成我们的目标将一个群体之间的不同个体距离拉远。\n演算 接下来，我们有了方向就可以进行推演了。\n我们要将原始变量X进行正交变换得到新的一组变量，这从几何看就是进行坐标轴旋转。\n总之，从代数角度看就是，设p维随机向量X=$(x_1,x_2,\u0026hellip;,x_p)$的协方差阵为$\\Sigma$。\n那么我们就是要找一组新的变量Z=$(z_1,z_2,\u0026hellip;,z_p)$使得（新变量被称为主成分）\n$$z_1=a_{11}x_1+a_{12}x_2+...+a_{1p}x_p=a_1^TX$$$$z_2=a_{21}x_1+a_{22}x_2+...+a_{2p}x_p=a_2^TX$$\u0026hellip;\n$$z_p=a_{p1}x_1+a_{p2}x_2+...+a_{pp}x_p=a_p^TX$$而此时，$var(z_j)=a_j^T\\Sigma a_j,cov(z_j,z_k)=a_j^T\\Sigma a_k$\n我们前面说了，我们希望将一个群体之间的不同个体距离拉远，也就是要最大化新变量Z的方差，与此同时我们自然希望各个新变量之间无关也就是：\n最大化$var(z_j)$，希望$cov(z_j,z_k)=0$\n对于$z_1$来说就是希望最大化$a_1^T\\Sigma a_1$，但是显然我们可以通过无限扩大$a_1$的长度来实现最大化$z_1$的方差，这是我们不期望看到的。\n所以我们再额外要求$z_1$的长度是1即$a_1^Ta_1=1$。\n这样的话其实我们就是在最大化$a_1^T\\Sigma a_1=\\frac{a_1^T\\Sigma a_1}{a_1^Ta_1}$（注意哦，现在分母为1所以除了等于没除）。\n类似地，我们对$z_2$会要求$a_2^Ta_2=1$，并且$cov(z_2,z_1)=a_2^T\\Sigma a_1=0$\n最大化$a_2^T\\Sigma a_2$。\n以此类推，但是到最后一个变量$z_p$我们只能要求最小化$a_p^T\\Sigma a_p$了，因为这个对应的是前面说的高维椭圆的短轴，是最小的。\n那么，怎么进行最小化呢？\n一般的教材这里就是上拉格朗日乘数法了，计算比较复杂我就不说了。给个结论吧。\n$\\forall a \\in R^p,\\Sigma \\in M_p且\\Sigma为对称矩阵。$\n设$(\\lambda_j,e_j)$为$\\Sigma$的特征值、单位特征向量。\n$$a\\neq 0, a⊥e_1,e_2,...,e_{j-1},$$$$max \\frac{a^T\\Sigma a}{a^T a}=\\lambda_j在a=e_j时取到最大。$$ 利用上述结论就可以知道，X的第j个主成分$z_j=e_j^TX$\n且$var(z_j)=e_j^T\\Sigma e_j$\n注意$(\\lambda_j,e_j)$为$\\Sigma$的特征值、单位特征向量。\n所以$\\Sigma e_j =\\lambda_j e_j,e_j^Te_j=1$\n因而$var(z_j)=e_j^T\\Sigma e_j=e_j^T \\lambda_j e_j=\\lambda_j e^T_je_j=\\lambda_j$。\n所以，X的第j个主成分$z_j$是其协方差矩阵$\\Sigma$的第j个单位特征向量乘以原始变量X，并且第j个主成分的方差就是$\\Sigma$第j个特征值$\\lambda_j$。\n这就是主成分分析的结论。\n更进一步的，如果我们对原始变量进行标准化然后再进行主成分分析，可以证明这相当于对原始变量的相关系数矩阵R进行对应的主成分分析。\n降维 从上面的推导我们可以看到对p维向量进行主成分分析只能得到p个主成分，似乎不能降维啊。那么我们一般说的降维是怎么回事？\n前面我们知道，第j个主成分的方差就是$\\Sigma$第j个特征值$\\lambda_j$。\n如果我们将全部的主成分的方差求和，那就是对$\\Sigma$全部的特征值的求和，也就是$\\Sigma$的迹，也就是X各个分量的方差的和。\n所以到现在为止我们还没有损失任何一点点方差。\n如果降维的话就会损失方差了，这是因为所谓的降维就是将各个特征值从大到小排列，然后去掉比较小的特征值和对应的主成分。\n这样的话就会损失方差了，也就损失了部分信息。这就是所谓的利用主成分分析进行降维。\nR语言实现 R语言作为为统计而生的语言，实现主成分分析非常简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 示例数据 X \u0026lt;- matrix(c(1, 2, 1, 4, 1, 0, 10, 2, 10, 4, 10, 0), nrow=6, byrow=TRUE) # 标准化数据 X_scaled \u0026lt;- scale(X) # 应用PCA pca_result \u0026lt;- prcomp(X_scaled, scale.=FALSE) # scale.=FALSE表示数据已经标准化 # 提取主成分得分 pca_scores \u0026lt;- pca_result$x # 主成分的方差贡献率 pca_variance \u0026lt;- pca_result$sdev^2 / sum(pca_result$sdev^2) * 100 核心就是这里的prcomp函数。\n当然，我们已经知道主成分分析的结果是样本协方差矩阵的特征向量特征值。\n所以也可以用上面的公式手动求解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 示例数据 X \u0026lt;- matrix(c(1, 2, 1, 4, 1, 0, 10, 2, 10, 4, 10, 0), nrow=6, byrow=TRUE) # 计算协方差矩阵 cov_matrix \u0026lt;- cov(X) # 计算特征值和特征向量 eigen_result \u0026lt;- eigen(cov_matrix) # 排序特征值和特征向量 sorted_eigen \u0026lt;- eigen_result$vectors[, order(eigen_result$values, decreasing = TRUE)] sorted_values \u0026lt;- eigen_result$values[order(eigen_result$values, decreasing = TRUE)] # 选择主成分（例如，前两个主成分） k \u0026lt;- 2 principal_components \u0026lt;- sorted_eigen[, 1:k] # 计算主成分得分 pca_scores \u0026lt;- as.data.frame(t(X %*% principal_components)) # 主成分的方差贡献率 pca_variance \u0026lt;- sorted_values[1:k] / sum(sorted_values) * 100 因子分析 那么因子分析是什么？\n还是看学生成绩数据吧，从学生的成绩上我们可以看到，优秀的学生似乎各科成绩都很好。也许你还会发现，各科成绩高度相关，这意味着他们可能由某一个潜在变量决定（智商）。\n因子分析就是由原始数据寻找这样的潜变量。\n由于潜变量的数量往往少于原始变量的数量，所以因子分析也是一种降维方法。\n因子分析建立了一个因子模型，它认为原始变量Y是各个潜变量的线性组合，即\n$$Y_i=l_{i1}F_1+l_{i2}F_2+...+l_{im}F_m+\\epsilon_i$$其中，$F_j$是潜变量也叫公共因子，我们假设有m个，当然一般要求m不大于原始变量的个数p。\n系数$l_ij$被称为因子载荷，$Y_i$则是原始变量而$\\epsilon_i$是类似误差的特殊因子。\n我们还对公共因子提了一些基础的要求，首先$F_i,F_j$不相关（正交），$F_i,\\epsilon_j、\\epsilon_i,\\epsilon_j$不相关，来保持各个变量之间的独立性。\n当然，因子模型用矩阵表示更简洁，就是\n$Y=AF+\\epsilon$\n那前面说的那些要求用矩阵表示就是：\n$m \\le p$ cov(F,$\\epsilon$)=0 $D_F=var(F)=单位阵I_m$ $D_\\epsilon=var(\\epsilon)=diag(\\sigma_1^2,\\sigma_2^2,\u0026hellip;,\\sigma_p^2) $ 而因子模型最重要的是协方差阵的矩阵分解：\n$var(X)=\\Sigma=cov(AF+\\epsilon,AF+\\epsilon)=Acov(F,F)A^{-1}+cov(\\epsilon,\\epsilon)=AA^{-1}+D_\\epsilon$\n演算 那么如何求解因子模型中未知的A和$\\epsilon$呢？\n答案是利用协方差矩阵的矩阵分解：\n$\\Sigma=AA^{-1}+D_\\epsilon$\n而前面我们说过$\\Sigma$可以分解为$Q\\Lambda Q^T$，其中$Q=($e_1,e_2,\u0026hellip;,e_n$)，$$\\Lambda =diag(\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)$\n我们再进行小小的变换，定义$\\Lambda_2=(e_1\\sqrt{\\lambda_1},e_2\\sqrt{\\lambda_2},\u0026hellip;,e_p\\sqrt{\\lambda_p})$，\n则$\\Sigma=\\Lambda_2 \\Lambda_2$。\n当$\\Sigma$的后p-m个特征值很小的时候，我们就可以忽略掉后面的项，用$\\Lambda_2$的前m项估计A，从而$D_\\epsilon=\\Sigma-AA^{-1}$也就可以计算了。\n这就是因子分析的主成分法求解。\n主轴因子法 除此之外因子分析还有一个常用的算法是主轴因子法，推导比较复杂我就只说思路了。\n我们知道\n$\\Sigma=AA^{-1}+D_\\epsilon$\n那么如果我们先估计$D_\\epsilon$在分解也可以得到A。\n先把原始变量进行标准化从而$\\Sigma=原始变量的相关系数矩阵R$\n再定义约相关系数矩阵$R^*=R-D_\\epsilon=AA^{-1}$，\n然后估计$R^*$，\n再用约相关阵的公式计算A和$D_\\epsilon$就可以了。\n至于约相关阵怎么估计，有4种方法，但是我个人觉得只有一种方法比较好，然而这种方法的解就是主成分解，所以我个人其实感觉主轴因子法，，，，，，，，没太大意思。\n而且由于约相关矩阵是估计来的，你没法保证他的正定性，所以这种方法的解释性也比较差。\n因子分析的R语言实现 这个实现也非常简单，并且R语言内置的因子分析可以估计因子得分和进行因子旋转。这两个东西的理论非常复杂，结果也很难看，所以我压根就没提。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 输入数据 data \u0026lt;- matrix(c(一些数据), nrow=3, byrow=TRUE) # 执行因子分析，factors=2表示提取2个公共因子，rotation表示进行方差最大化因子旋转 fa_result \u0026lt;- factanal(data, factors=2, rotation=\u0026#34;varimax\u0026#34;) # 查看因子载荷矩阵 fa_result$loadings # 提取因子得分 fa_scores \u0026lt;- fa_result$scores # 可视化 biplot(fa_result) ","date":"2024-11-27T12:09:07+08:00","permalink":"https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%904-%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/","title":"多元统计分析(4)-降维方法-主成分分析与因子分析"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本期是基于我刚刚完成的SmartCanvas项目简要介绍一下如何在Windows上部署kafka。\n值得一提的是，kafka是一个大数据场景下常用的分布式基于消息订阅模型的开源流处理平台，在SmartCanvas中当做消息队列使用。\n注意看他的定位，大数据场景、分布式等词，其实意味着kafka需要依托于服务器集群环境，所以他正常的操作还是安装在linux集群上，本文在Windows上安装只是安装一个单机的开发时测试用的kafka。\n1.下载kafka安装包 前往kafka官网下载，\n本文选择的是 kafka_2.13-3.9.0.tgz，只需要下载3.9.0\nBinary downloads:\nScala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) 选择下面那个就可以了。\n这里简单说明一下\nSupported releases 支持版本\n3.9.0\nReleased November 6, 2024 发布于 2024 年 11 月 6 日\nRelease Notes 发布说明\nDocker image: apache/kafka:3.9.0. Docker 镜像：apache/kafka:3.9.0.\nDocker Native image: apache/kafka-native:3.9.0. Docker 原生镜像：apache/kafka-native:3.9.0.\nSource download: kafka-3.9.0-src.tgz (asc, sha512) 源代码下载：kafka-3.9.0-src.tgz (asc, sha512)\nBinary downloads:\n二进制下载：\nScala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) We build for multiple versions of Scala. This only matters if you are using Scala and you want a version built for the same Scala version you use. Otherwise, any version should work (2.13 is recommended).\n我们为多个版本的 Scala 进行构建。这只有在您使用 Scala 并且希望使用与您使用的相同 Scala 版本构建的版本时才重要。否则，任何版本都应该可以工作（推荐使用 2.13）。\nkafka 3.9.0在官网上是的这样的，\n额，下面的中文官网是没有的，是已经翻译之后的。\nkafka提供了三种下载方式，通过docker镜像可以一键安装部署。\n通过源代码下载，你将获得kafka的源代码，你可以自行编译。\n下面的二进制下载则是打包后能直接运行的应用程序，我们这次就是选择的这个方式。\n但是你会看到二进制下载有两种，什么2.12 2.13之类的。\n这是scala的版本，kafka是基于scala构建的所以这里有不同版本的scala编译的程序。\n虽然kafka是基于scala构建的，但scala和kotlin类似也是一门jvm语言，所以你运行的话只需要准备java环境就可以了不需要下载scala。\n总结：下载kafka安装包，准备java运行环境即可。\n2.解压 额，就是字面意思，解压压缩包就可以了。\nWindows不用教了吧，下个什么7-zip，bandizip之类的解压就可以了。\nlinux命令也不难，\n1 tar -zxvf 压缩包目录 -C 解压目录 解压完我个人的习惯是把解压目录改名成kafka，这个随意不是必须做的。\n3.进行配置 我这次选择在Windows上部署kafka，主流方式是部署在linux上啦，其实都一样的。\n但是部署在linux上一般不需要进行下面的配置：\n先建一个文件夹用来存放kafka的日志。\n然后进入kafka\\config用vim或记事本打开里面的server.properties。\n找到62行\nlog.dirs=/tmp/kafka-logs\n这是日志文件的地址，很显然这不是Windows文件系统应该有的地址。\n现在换成你刚刚建的文件夹的位置。\n但是注意，要把路径的单斜杠\\重复一遍进行转义，即把\\换成 \\\\\n接下来的步骤，不管部署在Windows还是linux上都要进行处理。\n找到34行\nlisteners=PLAINTEXT://:9092\n这是是kafka的地址，改成\n1 listeners=PLAINTEXT://localhost:9092 这样kafka就会监听本地9092端口了。\n这是我配置完之后的配置文件，可以给你参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 # Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright ownership. # The ASF licenses this file to You under the Apache License, Version 2.0 # (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # This configuration file is intended for use in ZK-based mode, where Apache ZooKeeper is required. # See kafka.server.KafkaConfig for additional details and defaults # ############################# Server Basics ############################# # The id of the broker. This must be set to a unique integer for each broker. broker.id=0 ############################# Socket Server Settings ############################# # The address the socket server listens on. If not configured, the host name will be equal to the value of # java.net.InetAddress.getCanonicalHostName(), with PLAINTEXT listener name, and port 9092. # FORMAT: # listeners = listener_name://host_name:port # EXAMPLE: # listeners = PLAINTEXT://your.host.name:9092 #listeners=PLAINTEXT://:9092 listeners=PLAINTEXT://localhost:9092 # Listener name, hostname and port the broker will advertise to clients. # If not set, it uses the value for \u0026#34;listeners\u0026#34;. #advertised.listeners=PLAINTEXT://your.host.name:9092 # Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details #listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL # The number of threads that the server uses for receiving requests from the network and sending responses to the network num.network.threads=3 # The number of threads that the server uses for processing requests, which may include disk I/O num.io.threads=8 # The send buffer (SO_SNDBUF) used by the socket server socket.send.buffer.bytes=102400 # The receive buffer (SO_RCVBUF) used by the socket server socket.receive.buffer.bytes=102400 # The maximum size of a request that the socket server will accept (protection against OOM) socket.request.max.bytes=104857600 ############################# Log Basics ############################# # A comma separated list of directories under which to store log files log.dirs=D:\\\\softwareLocate\\\\kafka\\\\logs # The default number of log partitions per topic. More partitions allow greater # parallelism for consumption, but this will also result in more files across # the brokers. num.partitions=1 # The number of threads per data directory to be used for log recovery at startup and flushing at shutdown. # This value is recommended to be increased for installations with data dirs located in RAID array. num.recovery.threads.per.data.dir=1 ############################# Internal Topic Settings ############################# # The replication factor for the group metadata internal topics \u0026#34;__consumer_offsets\u0026#34; and \u0026#34;__transaction_state\u0026#34; # For anything other than development testing, a value greater than 1 is recommended to ensure availability such as 3. offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 ############################# Log Flush Policy ############################# # Messages are immediately written to the filesystem but by default we only fsync() to sync # the OS cache lazily. The following configurations control the flush of data to disk. # There are a few important trade-offs here: # 1. Durability: Unflushed data may be lost if you are not using replication. # 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush. # 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks. # The settings below allow one to configure the flush policy to flush data after a period of time or # every N messages (or both). This can be done globally and overridden on a per-topic basis. # The number of messages to accept before forcing a flush of data to disk #log.flush.interval.messages=10000 # The maximum amount of time a message can sit in a log before we force a flush #log.flush.interval.ms=1000 ############################# Log Retention Policy ############################# # The following configurations control the disposal of log segments. The policy can # be set to delete segments after a period of time, or after a given size has accumulated. # A segment will be deleted whenever *either* of these criteria are met. Deletion always happens # from the end of the log. # The minimum age of a log file to be eligible for deletion due to age log.retention.hours=168 # A size-based retention policy for logs. Segments are pruned from the log unless the remaining # segments drop below log.retention.bytes. Functions independently of log.retention.hours. #log.retention.bytes=1073741824 # The maximum size of a log segment file. When this size is reached a new log segment will be created. #log.segment.bytes=1073741824 # The interval at which log segments are checked to see if they can be deleted according # to the retention policies log.retention.check.interval.ms=300000 ############################# Zookeeper ############################# # Zookeeper connection string (see zookeeper docs for details). # This is a comma separated host:port pairs, each corresponding to a zk # server. e.g. \u0026#34;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\u0026#34;. # You can also append an optional chroot string to the urls to specify the # root directory for all kafka znodes. zookeeper.connect=localhost:2181 # Timeout in ms for connecting to zookeeper zookeeper.connection.timeout.ms=18000 ############################# Group Coordinator Settings ############################# # The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance. # The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms. # The default value for this is 3 seconds. # We override this to 0 here as it makes for a better out-of-the-box experience for development and testing. # However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup. group.initial.rebalance.delay.ms=0 4.安装zookeeper 接下来，似乎可以直接启动kafka了，但是你想得美嘞。\n再次重复一下kafka的地位，大数据场景下常用的分布式基于消息订阅模型的开源流处理平台，\n这意味着kafka需要zookeeper提供分布式协调服务，协调各个kafka集群中的机器，虽然我们只是在安装单机开发测试服务器，但是zookeeper还是少不了。\n前往zookeeper官网，下载安装包，你划到下面就可以看到\nDownload\nApache ZooKeeper 3.9.3 is our current release, and 3.8.4 our latest stable release.\nApache ZooKeeper 3.9.3\nApache ZooKeeper 3.9.3(asc, sha512)\nApache ZooKeeper 3.9.3 Source Release(asc, sha512)\n在这里，我选择下载zookeeper 3.9.3\n点击Apache ZooKeeper 3.9.3(asc, sha512)这个链接就可以了。\nWe suggest the following location for your download:\nhttps://dlcdn.apache.org/zookeeper/zookeeper-3.9.3/apache-zookeeper-3.9.3-bin.tar.gz\nAlternate download locations are suggested below.\nIt is essential that you verify the integrity of the downloaded file using the PGP signature ( .asc file) or a hash ( .md5 or .sha* file).\n然后你会看到这样的页面，点击上面的链接，https://dlcdn.apache.org/zookeeper/zookeeper-3.9.3/apache-zookeeper-3.9.3-bin.tar.gz就可以下载到zookeeper安装包了。\n然后找个地方解压就可以了。\n再对zookeeper进行配置，应该轻车熟路了。\n进入zookeeper\\conf找到zoo.cfg用vim或记事本打开，\n直接给你看我的配置文件，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=D:\\\\softwareLocate\\\\zookeeper\\\\data dataLogDir=D:\\\\softwareLocate\\\\zookeeper\\\\log # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to \u0026#34;0\u0026#34; to disable auto purge feature #autopurge.purgeInterval=1 ## Metrics Providers # # https://prometheus.io Metrics Exporter #metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider #metricsProvider.httpHost=0.0.0.0 #metricsProvider.httpPort=7000 #metricsProvider.exportJvmInfo=true 你要配置的是12和13行，配置zookeeper数据文件夹和zookeeper日志文件夹，找个地方新建出这两个文件夹然后把路径换成你自己的即可。\ndataDir=D:\\\\softwareLocate\\\\zookeeper\\\\data dataLogDir=D:\\\\softwareLocate\\\\zookeeper\\\\log\n5.启动zookeeper 接下来，我们终于可以启动zookeeper和kafka了。\n我们要先启动zookeeper。\n进入zookeeper\\bin文件夹，找到zkServer.cmd（对linux系统，找到zkServer.sh），然后打开cmd等终端。\n如果你不知道怎么打开终端的话，对linux你还能不知道也是神人了。\n对于Windows系统，你去文件资源管理器的地址栏，输入cmd回车即可。\n在终端中输入zkServer.cmd的文件名再按回车\n1 zkServer.cmd 就可以启动zookeeper了。\n6.启动kafka 然后我们来启动kafka。\n启动kafka就是启动\nkafka\\bin\\windows\\kafka-server-start.bat\n但是我们还得指定刚刚设置的配置文件，所以我的建议是你去kafka\\bin目录，打开cmd输入\n1 bin\\windows\\kafka-server-start.bat config\\server.properties 并按回车。\n解析一下这个命令，命令的前一半是指定到了当前目录下的bin目录下的windows里面的kafka-server-start.bat文件。\n后一半类似，指定了我们刚刚书写的配置文件。\n只需要稍等片刻，kafka就会启动完成了。\n7.跑一个小demo 这里我选择复用smartCanvas项目的代码，\n由于这是一个spring boot项目所以这里选择使用spring-kafka来操作kafka。\n首先安装依赖：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.kafka\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-kafka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 然后前往application.yml进行设置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 spring: kafka: bootstrap-servers: \u0026#34;kafka服务器地址\u0026#34; producer: # 消息生产者key和value序列化器，这里是字符串序列化器 key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer # 类似地，这里是消费者key和value序列化器 consumer: key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer group-id: \u0026#34;使用者组名称\u0026#34; 然后在消息生产者处注入kafkaTemplate操作kafka。\n1 2 @Resource private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; 然后将消息发送出去。\n1 kafkaTemplate.send(\u0026#34;smartCanvas_genChartByAI\u0026#34;, JSONUtil.toJsonStr(chart)); 这里的\u0026quot;smartCanvas_genChartByAI\u0026quot;是kafka中的话题（topic）的名称。\nJSONUtil.toJsonStr(chart)是一个字符串，这个就是消息生产者产生的消息。\n消息生产者代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Resource private ChartService chartService; //接口依赖的其他服务 @Resource private UserService userService; //接口依赖的其他服务 @Resource private AiService aiService; //接口依赖的其他服务 @Resource private RedissonUtils redissonUtils; //接口依赖的其他服务 @Resource private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; /** * 智能分析（异步） * * @param file 上传的文件 * @param requestDTO 智能分析请求 * @param request 请求 * @return 智能分析结果 */ @PostMapping(\u0026#34;/gen/async\u0026#34;) public BaseResponse\u0026lt;GenResultVO\u0026gt; genChartAsyncByAi(@RequestPart(\u0026#34;file\u0026#34;) MultipartFile file, GenChartByAiRequest requestDTO, HttpServletRequest request) { chartService.validGenChartParams(file, requestDTO); User user = userService.getLoginUser(request); try { redissonUtils.limitRate(\u0026#34;smartCanvas_genChartByAI_async_\u0026#34; + user.getId(), 2L); } catch (BusinessException e) { throw new BusinessException(ErrorCode.TOO_MANY_REQUESTS_ERROR, \u0026#34;请求过于频繁，请稍后再试\u0026#34;); } String data = ExcelUtils.excelToCsv(file); Chart chart = Chart.builder() .chartData(data) .chartName(requestDTO.getChartName()) .chartType(requestDTO.getChartType()) .goal(requestDTO.getGoal()) .createrId(user.getId()) .status(ChartStatusEnums.PROCESSING.getValue()) .execmsg(ChartStatusEnums.PROCESSING.getDesc()) .build(); chartService.save(chart); //提交给kafka消息队列 kafkaTemplate.send(\u0026#34;smartCanvas_genChartByAI\u0026#34;, JSONUtil.toJsonStr(chart)); return ResultUtils.success(new GenResultVO(null, \u0026#34;\u0026#34;, \u0026#34;{}\u0026#34;, ChartStatusEnums.PROCESSING.getValue(), ChartStatusEnums.PROCESSING.getDesc())); } 然后是消息的消费者，\n只需要给消息的消费者方法增加注解@KafkaListener(topics = {\u0026quot;要接受消息的topic名称\u0026quot;})即可。\n在smartCanvas中是这样实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package cn.cola.smartcanvas.service.impl; import cn.cola.smartcanvas.model.enums.ChartStatusEnums; import cn.cola.smartcanvas.model.po.Chart; import cn.cola.smartcanvas.model.vo.GenResultVO; import cn.cola.smartcanvas.service.AiService; import cn.cola.smartcanvas.service.ChartService; import cn.cola.smartcanvas.service.KafkaService; import cn.hutool.json.JSONUtil; import lombok.extern.slf4j.Slf4j; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Service; import javax.annotation.Resource; /** * 卡夫卡服务实现类 * * @author ColaBlack */ @Service @Slf4j public class KafkaServiceImpl implements KafkaService { @Resource private AiService aiService; @Resource private ChartService chartService; /** * 智能分析任务 * * @param record 消息记录 */ @Override @KafkaListener(topics = {\u0026#34;smartCanvas_genChartByAI\u0026#34;}) public void genResultTask(ConsumerRecord\u0026lt;String, String\u0026gt; record) { if (record == null || record.value() == null) { log.error(\u0026#34;kafka 中消息记录为空\u0026#34;); return; } GenResultVO resultVO; Chart chart = JSONUtil.toBean(record.value(), Chart.class); String chartData = chart.getChartData(); String goal = chart.getGoal(); String chartType = chart.getChartType(); if (chartType == null) { chartType = \u0026#34;任意统计图\u0026#34;; } try { resultVO = aiService.genResult(goal, chartType, chartData); resultVO.setId(chart.getId()); } catch (Exception e) { log.error(\u0026#34;智能分析异常\u0026#34;, e); chart.setStatus(ChartStatusEnums.FAILED.getValue()); chart.setExecmsg(ChartStatusEnums.FAILED.getDesc()); chartService.updateById(chart); return; } chart.setGeneratedChart(resultVO.getOption()); chart.setAnalyzedResult(resultVO.getResult()); chart.setStatus(ChartStatusEnums.SUCCESS.getValue()); chart.setExecmsg(ChartStatusEnums.SUCCESS.getDesc()); chartService.updateById(chart); } } @Service注解将消息消费者注册为spring bean，然后genResultTask就是真正的处理消息的方法。\nConsumerRecord\u0026lt;String, String\u0026gt; record的record的value就是消息生产者产生的消息了。\n在smartCanvas项目里，是通过将消息反序列化为java对象再进行下一步业务逻辑处理的。\n1 Chart chart = JSONUtil.toBean(record.value(), Chart.class); ","date":"2024-11-25T20:35:35+08:00","permalink":"https://ColaBlack.github.io/p/windows%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2kafka%E5%92%8Czookeeper/","title":"Windows如何部署kafka和zookeeper"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n在上次我们以浏览器的事件循环为例简要介绍了如何调度异步资源，这一次要来填个坑，介绍一下浏览器是如何渲染页面的。没看过上一期的话就先看一下上一期的开头，了解一下浏览器的多进程图景。\n1.解析HTML 在上一期我们讲到，浏览器的页面由渲染进程完成，在这一期你将看到渲染进程是一个包含了渲染主线程等多个线程的进程。\n当浏览器通过网络进程向服务器发送请求得到响应的HTML文本后，他要做的第一个工作就是解析收到的HTML文本。\n对于大部分标签，建立对应的DOM树。对于CSS，建立对应的CSSOM树。\n但是当解析工作遇到link的时候，按道理就需要去下载对应的css，但是我们知道网络IO是一个耗时比较长的过程，所以这个步骤也会阻塞渲染主线程。\n因此，浏览器并不是以这个方式解析的。\n而是先启动一个预解析线程，预先快速\u0026quot;浏览\u0026quot;一下HTML标签，下载HTML文本引用的外部CSS文件和JS文件。\n当渲染主线程遇到一般的标签那就解析成DOM，但是当渲染主线程遇到link引用CSS的时候，渲染主线程将不会等待，直接解析下面的其他内容。（异步）\n那么外部的CSS由谁解析呢？\n由和刚刚说的预解析线程解析。\n那外部JS呢？\nJS比较特殊，现在来讲。\n由于在JS中存在改变DOM树和CSSOM树的可能，所以JS的解析完全由渲染主线程操刀，并且当渲染主线程遇到script标签的时候，它会暂停现有的对HTML的解析（阻塞），等待预解析线程把对应的JS代码下载好，并且需要等到全局代码都被解析执行完成之后才继续解析HTML文本。\n总之，解析过程就是得到DOM和CSSOM的过程，此时的CSSOM已经是一个包含浏览器默认样式、内部样式、外部样式、行内样式的比较完整的树结构了。\n2.样式计算 之所以说是“比较完成的树”是因为此时CSSOM里还保留着em等相对值和计算属性，这一步就是将这些相对值和计算属性计算出来。\n计算之后的就是最终样式computed style了。\n非常简单，不需要多说什么其他话了。\n3.布局 第三步是根据前面的信息对页面进行布局，生成布局树。\n在这一步渲染主线程要遍历全部的DOM，计算他们的位置信息和几何信息。\n但是注意，布局树和DOM树并不完全一致。\n对于CSS为display:none的元素，由于他们不显示，所以不会在布局树中。DOM中不存在伪元素节点，但我们知道伪元素节点都有几何信息所以他们存在于布局树中。\n由于存在规定\n内容必须在行盒中\n行盒和块盒不能相邻\n所以，在布局这一步还会生成一些匿名的行盒或者块盒来使得页面满足这一规则。\n4.分层 接下来，渲染主线程会对布局树的元素进行分层。这是一个优化的方法，当将来某一层改变后就只需要对这一层的元素进行对应改变就可以了，这将提高浏览器的性能。\n5.绘制 接下来，绘制这一步就是为每一层生成对应的绘制指令，你可以理解为canvas之类的东西。\n啊，什么把画笔移动到哪里哪里，然后向哪里哪里花一条直线什么的。\n到生成绘制指令这一步，渲染主线程的任务才算结束。\n6.分块 接下来压力给到了合成线程。啊，其实也不全是。\n分块的工作要交给很多个被称为分块器的线程协作完成。\n所谓分块就是字面意思，将每一层的元素分为若干小块，以便后续步骤的分工。\n7.光栅化 一看到光栅化这个词已经有人在瑟瑟发抖了吧，其实很简单的。\n就是把前面分的每一块变成位图。\n或者说，合成线程会将每一个块的信息交给显卡（GPU）进程来绘制我们真正能看到的图像。\n当然GPU进程会开多个线程来同时绘制图像，并且它将优先计算靠近视口的块，因为用户正在看那里嘛。\n8.绘制 这一步是最后一步了。\n合成线程在拿到GPU渲染的一张张位图后，将生成指引（quad）信息，标注出每个位图应该画在屏幕的哪个位置，要不要进行选择和缩放等。\nCSS中的transform正是也只是作用于这一阶段，这也是其运行效率高的本质原因。\n当生成指引信息后，合成线程会将指引信息传递给GPU进程，然后GPU进程会产生系统调用操作显卡硬件绘制用户真正能看到的页面图像。\n9.后记 这就是浏览器渲染一个页面的全部步骤了。\n了解这个或许没有什么用，额可能吧。\n不过可以让你小心一点。\n有一些操作会影响布局树，这时浏览器会从第三步重新开始后面的全部过程了，这被称为回流/重排(reflow)，如果可以的话应该尽量避免这样的操作。\n当然，当你连续多次进行修改布局树的操作，浏览器会进行优化，自动合并这些操作，等对应的JavaScript代码全部完成后才统一进行一次reflow。\n但是这也意味着，这时JavaScript获取的布局属性可能是不准确的，为了避免这种情况，当JavaScript代码尝试获取布局属性的时候浏览器会立刻进行reflow操作而不是等待代码全部运行完成。所以这种情况也应该规避。\n而当你改变了DOM的几何信息的时候，浏览器就需要从绘制这一步重新开始，这一过程被称为重绘(repaint)。\n这个效率会比reflow高一些，因为reflow是从第三步布局开始，也会经历完repaint经历的全部过程。（也有说法称reflow会引起repaint，从结果上看两种说法没有任何区别，你怎么理解都可以）\n但是还得是transform高效啊，只影响了最后一步绘制，只有合成线程受到影响了而已，这效率高的不是一点半点啊。\n","date":"2024-11-23T16:28:26+08:00","permalink":"https://ColaBlack.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/","title":"浏览器是如何渲染页面的"},{"content":"初次发布于我的个人文档\n参考:\nchromiun官方文档\nw3c官方文档\n针对一个异步的程序应该如何对它进行资源的调度呢？本文以浏览器为典型范例进行简单介绍。\n1.查看浏览器的多进程图景 打开任意一个浏览器这里以edge为例。\n然后打开Windows的任务管理器，你看到的可能是这样：\n事实上，在edge浏览器（其他浏览器也有类似的功能）按shift+esc键能打开浏览器内部的任务管理器，可能长这样：\n不管怎么样总之，都可以看到你打开了一个浏览器实际上打开了好多个“进行中的程序”也就是进程。\n浏览器作为及其复杂的而又非常常用的程序，不得不使用多进程的方式优化。\n而正是因为浏览器使用了多进程，所以有的时候你会发现，某一个网页卡了但是浏览器没有卡死，一个页面卡死了但是另一个页面没有卡死。这是因为他们本来就“不是一个程序”。\n多进程是一种充分利用计算机硬件资源的方式，关于多进程、多线程和协程的有关概念以后有时间也许会分享。\n总而言之言而总之，浏览器是一个多进程的复杂的应用程序。\n浏览器的诸多线程里，最主要的是三个：\n浏览器进程负责浏览器界面的展示（不是网页，而是浏览器界面内的什么选项卡啊按钮啊什么的）、用户交互、子进程管理等等\n网络进程负责启动多个线程来执行网络任务，也就是收发各种网络请求。\n渲染进程才是负责网页渲染的，有时间也会展开说说浏览器是如何渲染网页的。 渲染进程是浏览器最重要也是最繁忙的进程，说他重要是因为我打开浏览器最主要的就是想看页面啊，没渲染进程怎么能行？说他繁忙，可以等以后展开。\n2.阻塞和非阻塞、同步和异步 刚刚我们说渲染进程是浏览器最重要也是最繁忙的进程，那么渲染进程是怎么组织资源调度和分配的呢？\n比如说，用户点击了一个按钮，我肯定要执行一段代码，但是与此同时可能有一个计时器也刚好到时间了，也想执行一段代码，那怎么办呢？\n进一步的，我怎么知道用户点击了一个按钮呢？是不是我得一直监听用户输入啊，那我岂不是要开一个任务一直运行着，那我渲染进程岂不是还得等用户点击按钮用户有输入了才能继续执行？\n这种现象被称为阻塞。\n也就是这个任务会卡着某一个线程，这个线程要等这个任务完成才能继续执行代码。\n我们写的一般的代码是不会卡着线程的，比如什么i++啊之类的，一下子就完成了所以不会阻塞。\n那如果我想做一些网络交互啊，磁盘输入输出（input/output,IO)之类的，那时间就长了，主线程就得等这些任务完成才能继续执行了，这就是阻塞了。\n再比如，下面的Python代码\n1 2 3 a = \u0026#34;hello World\u0026#34; input(\u0026#34;请输入\u0026#34;) print(a) 第二行在等待用户输入，如果用户一直不输入那么程序不会停止也不会运行第三个语句，而是会一直等待用户输入，用术语来讲就是阻塞。\n像这种，每个任务都按顺序完成的情况我们称之为同步。\n根据刚刚举的例子可以发现，同步的代码可能发生阻塞也可能不发生，我们分别称这两种情况为同步阻塞、同步非阻塞。\n结论：同步不一定阻塞\n不过比起这个结论更重要的是理解刚刚说的分析的过程。\n对于浏览器来说，他确实想执行监听用户的任务，但是又不想阻塞主线程不然用户看到的网页就一卡一卡的。\n那该怎么办呢？\n那就要使用异步的方式。\n这是一个简单的用java(python由于全局解释器锁的存在不太适合当例子了，JavaScript则是运行在浏览器的渲染主线程上也不太适合)实现的异步调用demo。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class CallbackThreadExample { // 定义一个回调接口 interface Callback { void onFinish(String result); } // 实现Runnable接口的类 static class Task implements Runnable { private final Callback callback; public Task(Callback callback) { this.callback = callback; } @Override public void run() { // 执行一些任务 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } // 任务完成，调用回调函数 if (callback != null) { callback.onFinish(\u0026#34;任务完成\u0026#34;); } } } public static void main(String[] args) { // 创建一个回调对象 Callback callback = result -\u0026gt; System.out.println(\u0026#34;回调函数被调用，结果：\u0026#34; + result); // 创建并启动新线程 Thread thread = new Thread(new Task(callback)); thread.start(); // 主线程可以继续执行其他任务 System.out.println(\u0026#34;主线程继续执行...\u0026#34;); } } callback被称为回调函数，简单说就是“回头再调用\u0026quot;。\nmain函数里定义了回调函数 Callback callback = result -\u0026gt; System.out.println(\u0026quot;回调函数被调用，结果：\u0026quot; + result);\n就是说等时机成熟，你给我调用这句输出语句。\ntask类定义了一个任务，叫线程睡眠2秒，然后再调用回调函数。（你看，回调函数是不是“回头再调用了”）\n很显然，task任务会阻塞主线程2秒，我们不希望这件事发生。所以新开了另一个线程来执行这个任务，这样主线程就可以继续执行了，也就不会阻塞了。\n这就是异步非阻塞。\n创建新线程执行原本会阻塞的任务，利用回调函数给予反馈是异步的一种实现方式。前面我们说同步的程序所有任务会按顺序完成，但这里异步的任务会和主线程同时完成，这就是异步和同步的区别。\n3.消息队列 那么浏览器是怎么处理纷繁复杂的异步任务的呢？\n熟悉JavaScript的话你会发现，像网络IO，交互，计时器等都是也只能按异步+回调的方式调用。那浏览器会在什么时候执行回调呢？\n如果网络IO完成的同时，计时器时间也到了应该先完成哪个？\n很快你会发现，这是一个任务生产的速率大于任务消费的速率的情况，这种模型我们一般可以通过排队的方式解决。\n你们俩同时想我启用某个任务了是吧，一个任务正在进行另外两个任务也想启动是吧，排队！\n队列这种数据结构就是现实里的排队，讲究的是先到先得。\n在我们这种情况下，用面向对象的术语来说就是需要一个消息队列，当一个任务想执行了，先往消息队列里发一个消息，我想执行某某任务，然后渲染主线程会先服务队首也就是排在最前面的人。\n4.事件循环 在浏览器具体实现的时候，又有一些细节需要注意。\n我们以谷歌chromiun内核为例，观察chromiun的源码，你会发现在chromiun渲染进程中存在一个死循环（这个循环被W3C称为事件循环在chromiun源码中被称为消息循环)，它不断地从消息队列中取任务，当消息队列为空时会休眠，只要队列里有任务就执行队首的任务，是吗？\n是也不完全是。\n对于一般的简单程序来说也许这样就足够了，但是对浏览器这个复杂的应用程序来说，完全不够！\n浏览器中有事件交互、网络IO等诸多异步任务，很显然事件交互的优先级要高一些，也就是当用户点击按钮啊什么的你浏览器必须尽快给出响应，不要让用户觉得卡顿。\n但是这样的话就破坏了消息队列“先进先出，先到先得”的特性，又该怎么办呢？\n5.微队列和宏队列 动动你的脑瓜子想想，虽然队列里的成员不能有优先级，只能先到先得，但是消息队列不是可以有优先级吗？\n我开好几个不同优先级的消息队列不就得了。\n如果你看过很多早期的教程或者早期w3c规范，你可能会听说过微队列和宏队列的说法，但是随着浏览器执行任务的复杂，w3c已经不再使用宏队列的说法了。（微队列仍在使用）光靠微队列和宏队列已经不足以支撑现代浏览器的资源调度了。\n现代浏览器有微队列、交互队列、延时队列等诸多消息队列。\n按照w3c最新的规范，微队列是优先级最高的队列，当渲染主进程完成手头现有的工作后只要微队列有任务在等着，那么他就会执行微队列的任务。这是因为微队列里都是一些支撑浏览器运行的重要任务。交互队列由于和用户体验息息相关所以优先级也比较高。像延时队列这种只关乎计时器的消息队列优先级就比较低，如果微队列的任务和交互队列的任务没有完成，那即使计时器到了，计时器的回调函数也不会被执行。这也是为什么计时器其实不能严格准确精准无误地按照程序员设定的时间执行任务。\n前面我们说“微队列里都是一些支撑浏览器运行的重要任务”其实也并不完全吧，我们还是有办法把一个函数添加到微队列的，可以通过以下代码\n1 Promise.resolve().then(函数) 将函数包装成任务，塞到微队列。\n翻看chromiun内核源码你会知道，这些消息队列里存放的不是函数句柄（或者说指向函数的指针）而是一个被包装起来的结构体，所以这里要用“包装成任务”的说法。\n","date":"2024-11-15T21:07:57+08:00","permalink":"https://ColaBlack.github.io/p/%E5%BC%82%E6%AD%A5%E4%B8%8E%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6-%E4%BB%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%BA%E4%BE%8B/","title":"异步与资源调度 以浏览器事件循环为例"},{"content":"初次发布于我的个人文档\n1.安装 使用如下的命令之一就可以获取工程费的phaser项目。\n1 2 3 4 5 npm create @phaserjs/game@latest npx @phaserjs/create-game@latest yarn create @phaserjs/game pnpm create @phaserjs/game@latest bun create @phaserjs/game@latest 或者使用\n1 npm install phaser 安装npm包在其他项目使用。\n也可以使用\n1 2 3 4 \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.86.0/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.86.0/phaser.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这些方式从cdn获取源码。\n或者，按照本文的方式，从github直接下载源码在本地使用。\n前往其github仓库下载dist目录下的phaser.js然后导入自己的项目中。\n例如\n1 \u0026lt;script src=\u0026#34;js/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2.预加载资源 接下来以本人模仿的玩具项目google-dinosaur为例介绍如何使用phaser.js制作简单的小游戏。\n首先需要先创建一个游戏场景类，在构造函数中声明场景的名称。\n1 2 3 4 5 export default class PreLoad extends Phaser.Scene { constructor() { super(\u0026#34;preLoadScene\u0026#34;); } } 当进入场景时phaser.js会先调用场景的preload方法。\n在preload方法中调用以下两个函数就可以预加载音乐和图片资源。\n1 2 this.load.audio(\u0026#34;音乐名称\u0026#34;, \u0026#34;音乐地址\u0026#34;); this.load.image(\u0026#34;图片名称\u0026#34;, \u0026#34;图片地址\u0026#34;); 而对于动画，我们只需要提供几个关键帧的图片，phaser.js会自动绘制动画，这种我们称之为精灵表单对象。使用这样的方法载入：\n1 2 3 4 5 this.load.spritesheet( \u0026#34;关键帧的名称\u0026#34;, \u0026#34;关键帧的地址\u0026#34;, {关键帧信息，如关键帧的大小等} ); 接下来phaser.js会调用create方法创建场景，在google-dinosaur项目中，create方法用于跳转到gameScene场景。\n1 this.scene.start(\u0026#34;gameScene\u0026#34;); 最后，给一下第一个场景的完整代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * 在游戏开始前预加载资源 */ export default class PreLoad extends Phaser.Scene { constructor() { super(\u0026#34;preLoadScene\u0026#34;); } preload() { // 加载背景音乐 // 死亡音效 this.load.audio(\u0026#34;dead\u0026#34;, \u0026#34;./assets/audio/Dead.wav\u0026#34;); // 跳跃音效 this.load.audio(\u0026#34;jump\u0026#34;, \u0026#34;./assets/audio/Jump.wav\u0026#34;); // 得分音效 this.load.audio(\u0026#34;score\u0026#34;, \u0026#34;./assets/audio/Score.wav\u0026#34;); // 加载图片资源 for (let i = 1; i \u0026lt;= 5; i++) { // 5张仙人掌图片 this.load.image(`cactus-${i}`, `./assets/images/Cactus-${i}.png`); } // 地面图片 this.load.image(\u0026#34;ground\u0026#34;, \u0026#34;./assets/images/Ground.png\u0026#34;); // 游戏结束文字图片 this.load.image(\u0026#34;gameover_text\u0026#34;, \u0026#34;./assets/images/Gameover_text.png\u0026#34;); // 再玩一次按钮图片 this.load.image(\u0026#34;replay_button\u0026#34;, \u0026#34;./assets/images/Replay_button.png\u0026#34;); for (let i = 1; i \u0026lt;= 4; i++) { // 4张小恐龙图片 this.load.spritesheet( `dinosaur-${i}`, `./assets/images/Dinosaur-${i}.png`, { frameWidth: 88, frameHeight: 94 } ); } } create() { // 切换到游戏场景 this.scene.start(\u0026#34;gameScene\u0026#34;); } } 3.创建场景 在介绍如何创建场景前，我们先写gameScene场景的代码框架，也就是\n1 2 3 4 5 export default class GameScene extends Phaser.Scene { constructor() { super(\u0026#34;gameScene\u0026#34;); } } 由于资源已经在前面预加载完了所以这里不需要预加载资源，我们直接写create方法即可。\n3.1创建游戏对象 在创建场景的时候主要的代码是创建游戏需要的对象，以google-dinosaur项目为例，需要创建地面、小恐龙、仙人掌等对象。\n地面的宽度和游戏画布的宽度一样，高度则位与中间，这意味着我们要先获取画布的高度和宽度。\n1 2 3 // 获取游戏画布的宽度和高度 this.width = this.sys.game.config.width; this.height = this.sys.game.config.height; 地面是静态不动的，对于这种静态的对象要用this.physics.add.staticGroup()方法先创建静态对象组。\n然后创建对象\n1 2 3 4 this.ground .create(this.width / 2, this.height - 13, \u0026#34;ground\u0026#34;) .setScale(2) .refreshBody(); create方法的前两个参数是对象的坐标，在phaser.js中默认的坐标系是从左上角开始,越往右x越大，越往下y越大。（当然，这个是可以自己改的）而这里的坐标默认是以对象的左上角为标准的。(左上角也被称为原点，也是可以自己改动的)\n例如你想把一个图片的左上角放到(0,0)，那就直接在create里输入0,0就可以了。\n\u0026ldquo;ground\u0026quot;是刚刚预加载的图片对象的名字，有这个参数phaser.js才知道刚刚创建的地面对象的贴图是ground。\nsetScale(2)则是将地面放大了2倍,refreshBody()要求phaser.js重新计算刷新地面对象的物理属性。\n对于会运动且有物理碰撞效果的一般的对象，可以用this.physics.add.group()为他们创造组。\n针对精灵表单和其他的一般对象可以用这样的方式创建\n1 2 3 this.dinosaur = this.physics.add .sprite(50, this.height / 2, \u0026#34;dinosaur-1\u0026#34;) .setOrigin(0, 1); dinosaur-1是动画的第一帧或者是对象的贴图。setOrigin则将该对象的原点设置到了x为0%，y为100%也就是对象的左下角了。\n如果要加入碰撞效果呢，就可以用这样的方法\n1 2 // 让小恐龙与地面发生碰撞，防止小恐龙掉落 this.physics.add.collider(this.dinosaur, this.ground); 3.2初始化动画 参考google-dinosaur的代码，\n1 2 3 4 5 6 7 8 9 10 11 12 // 定义恐龙奔跑的动画 this.dinosaur.anims.create({ key: \u0026#34;run\u0026#34;, frames: [ { key: \u0026#34;dinosaur-1\u0026#34; }, { key: \u0026#34;dinosaur-2\u0026#34; }, { key: \u0026#34;dinosaur-3\u0026#34; }, { key: \u0026#34;dinosaur-4\u0026#34; }, ], frameRate: 10, repeat: -1, }); 精灵表单的anims.create方法可以初始化动画，key则给了动画一个名字，叫做run。frames数组则列举了动画需要的关键帧的名字。frameRate是帧速率，repeat则说明了动画需要重复几次，-1表示动画要一直重复。\n3.3初始化音乐 初始化音乐就更简单了。使用this.sound.add(\u0026quot;音乐名称\u0026quot;)就可以了。\n以google-dinosaur为例只要这样就能初始化三个音乐了。\n1 2 3 this.deadSound = this.sound.add(\u0026#34;dead\u0026#34;); this.jumpSound = this.sound.add(\u0026#34;jump\u0026#34;); this.scoreSound = this.sound.add(\u0026#34;score\u0026#34;); 3.4监听用户输入 这里以监听用户键盘输入为例，使用\n1 this.input.keyboard.on(\u0026#34;keydown\u0026#34;, this.handleJump.bind(this), this); keydown表示监听用户的任意键盘输入，也就是用户按任意键就调用handleJump方法。\nhandleJump方法的代码很简单，就不说了。\n1 2 3 4 5 6 7 8 9 10 11 handleJump() { // 如果小恐龙不在地面上，则不执行跳跃以避免用户进行二段跳 if (!this.dinosaur.body.onFloor()) { return; } // 跳跃，设置y的速度为-1500像素每秒(负速度的方向向上) this.dinosaur.setVelocityY(-1500); // 播放跳跃音效 this.jumpSound.play(); } 4.编写每一帧的处理 接下来phaser.js会在游戏的每一帧都调用update函数\n这个部分只有播放精灵表单的动画是通用的。\n1 2 // 播放奔跑动画 this.dinosaur.anims.play(\u0026#34;run\u0026#34;, true); 这个语句就可以播放刚刚初始化的小恐龙奔跑动画。\n其他的语句都不是通用的，我就直接放google-dinosaur的源码给各位参考了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 update(time, delta) { // 播放奔跑动画 this.dinosaur.anims.play(\u0026#34;run\u0026#34;, true); // 检测小恐龙是否跳过仙人掌 this.cactusGroup.getChildren().forEach((cactus) =\u0026gt; { // 如果仙人掌的x坐标小于50且未被计分 if (cactus.x \u0026lt; 50 \u0026amp;\u0026amp; !cactus.getData(\u0026#34;scored\u0026#34;)) { // 标记仙人掌为已计分，避免重复计分 cactus.setData(\u0026#34;scored\u0026#34;, true); // 播放得分音效 this.scoreSound.play(); } }); // 定义计时器，每隔1-5秒生成一个仙人掌 this.timer = this.timer || time; const cactusInterval = Phaser.Math.Clamp( 2000 - this.speed * 100, 500, 2000 ); // 最小间隔为500ms，最大间隔为2000ms if (time - this.timer \u0026gt; cactusInterval) { this.summonCactus(); this.timer = time; } } 5.定义对象交互逻辑 接下来需要游戏其实就已经开始进行了，但是我们还没有定义对象之间的关系和结束游戏的方法。\n例如，在google-dinosaur项目中，当小恐龙和仙人掌碰撞的时候应该停止游戏。\n不过这个你可能得回去修改刚刚写的代码，例如修改增加小恐龙和仙人掌碰撞的代码为\n1 2 3 4 5 6 7 8 // 添加小恐龙与仙人掌组之间的碰撞检测 this.physics.add.collider( this.dinosaur, this.cactusGroup, this.handleDinoCactusCollision, null, this ); 这个代码既增加了二者的碰撞，又定义了当二者碰撞的时候调用handleDinoCactusCollision函数。\n这部分其实也没有通用的代码。\n大致上也就这三个代码比较常用\n1 2 3 4 5 6 7 8 // 播放死亡音效 this.deadSound.play(); // 停止物理模拟 this.physics.pause(); // 停止所有动画 this.anims.pauseAll(); 为了处理google-dinosaur的特殊需求，在该项目里这个函数其实是这样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 handleDinoCactusCollision(dinosaur, cactus) { // 播放死亡音效 this.deadSound.play(); // 停止物理模拟 this.physics.pause(); // 停止所有动画 this.anims.pauseAll(); this.speed = 1; this.score = 0; // 游戏结束时停止得分增加 if (this.scoreEvent) { this.scoreEvent.remove(false); } this.handleGameOver(); } handleGameOver() { // 显示游戏结束文字 const gameOverText = this.add .image(this.width / 2, this.height / 2 - 100, \u0026#34;gameover_text\u0026#34;) .setScale(2); // 显示再玩一次按钮 const replayButton = this.add .image(this.width / 2, this.height / 2 + 100, \u0026#34;replay_button\u0026#34;) .setInteractive() .setScale(2); // 为再玩一次按钮添加点击事件监听器 replayButton.on(\u0026#34;pointerdown\u0026#34;, () =\u0026gt; { this.scene.restart(); // 重新开始当前场景 }); } 6.配置并启动游戏 通过前面的步骤你已经完成了绝大部分代码。接下来只需要配置一下然后就可以启动游戏啦。\n前面的代码就只是定义了两个类，除了一堆定义之外其实没有代码被执行。\n如果想真正地启动游戏，只需要一句话：\n1 2 // 创建游戏实例 const game = new Phaser.Game(config); config是游戏的配置对象，这里以google-dinosaur项目的配置为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 游戏配置 const config = { type: Phaser.AUTO, // 游戏渲染器类型 width: 800,// 游戏画布宽度 height: 300,// 游戏画布高度 backgroundColor: \u0026#34;#ffffff\u0026#34;, //修改背景色为白色 parent: \u0026#34;game\u0026#34;, // 游戏绑定的父标签的id scene: [PreLoad, GameScene], // 游戏场景列表，会先进入第一个场景 physics: { default: \u0026#34;arcade\u0026#34;, // 默认物理引擎 arcade: { gravity: { y: 5000 }, // 重力设置 debug: false, // 调试模式，开发时使用 }, }, }; 每一个配置项我都写了注释，应该可以直接看懂了。\n在这里，游戏渲染器类型你可能不知道是什么意思，其实就是调整游戏是用webGL渲染还是canvas渲染。一般选自动就可以了。\n","date":"2024-11-14T18:59:45+08:00","permalink":"https://ColaBlack.github.io/p/phaser%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E7%9A%842d%E5%B0%8F%E6%B8%B8%E6%88%8Fdemo/","title":"Phaser开发简单的2d小游戏demo"},{"content":"初次发布于我的个人文档\n本文简要介绍一下如何实现一个简化版的类vue的响应式。\n1.假装不知道响应式 如果我们不知道vue等响应式框架，那么又该如何手动实现类似的功能呢？\n先来看这么一个简单的页面\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Program\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;data1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p id=\u0026#34;data2\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;data3\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 现在，如果这里的三个data需要变动，与此同时我们还希望页面进行所谓的“重新渲染”即让页面也跟着数据的变动变化应该怎么做呢？\n首先，要写js代码让这几个标签有内容对吗？\n只需要封装这三个函数即可\n1 2 3 4 5 6 7 8 9 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; 对于旧数据，只需要调用函数传入即可，例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { data1: \u0026#34;Hello World!\u0026#34;, data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; showData1(data); showData2(data); showData3(data); 但是接下来如果要更改data1，你会发现页面并不会变化，除非你重新调用showData1。\n例如，这段代码就实现了3秒后变化data1并使得页面发生变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { data1: \u0026#34;Hello World!\u0026#34;, data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; showData1(data); showData2(data); showData3(data); setTimeout(() =\u0026gt; { data1 = \u0026#34;Welcome to my program.\u0026#34;; showData1(data1); }, 3000); 2.针对特殊变量实现响应式 所以手动实现响应式的关键，就是在改变变量的时候再次调用showData函数。\n然而每次都手动去调用肯定是很麻烦而且不优雅的。\n很容易想到，只要重载对应变量的set方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { _data1: \u0026#34;Hello World!\u0026#34;, // 使用一个下划线前缀来存储data1实际的值 data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; Object.defineProperty(data, \u0026#34;data1\u0026#34;, { get: function () { return this._data1; // 使用存储的实际值 }, set: function (value) { this._data1 = value; // 更新存储的实际值 showData1(value); // 调用showData1来更新页面上的内容 }, }); showData1(data); showData2(data); showData3(data); setTimeout(() =\u0026gt; { data.data1 = \u0026#34;Welcome to my program.\u0026#34;; // 使用新设置的setter }, 3000); 这样就完成了对data1的封装。\n类似地，可以自己手动完成对data2 data3的封装。\n然而，这并不是什么好的选择，自己动手还是太累了。\n3.尝试封装为一般化工具 所以我们要来尝试封装成一般化的工具！\n我们来手写一个封装或者说观察函数，来观察这个对象，为这个对象的所有字段都重写get和set方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; Object.defineProperty(obj, key, { get: function () { return innerValue; }, set: function (value) { innerValue = value; }, }); } } 也就是这样。\n但是接下来你会发现，我们不知道应该调用哪些函数了。\n不妨回过头想想，手动实现的时候你是怎么知道要调用showData1这个函数的。\n我们为什么不把三个showData函数全部调用一遍呢？\n是不是因为showData1这个函数使用了data1这个变量啊，或者说就是这个函数调用了data1的get方法。\n所以，我们应该先重写get方法，记录哪个函数使用了get方法。\n那我怎么知道是哪个函数正在使用get方法呢？\n解决方案是，让这个函数使用get方法前手动在全局变量上记录自己，然后get函数访问全局变量获取信息。\n原本我们的调用是\n1 showData1(data); 现在改为\n1 showData1(data); 接着，data1的get方法只需要访问全局变量window.__func就知道谁正在调用get方法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; let funcs = []; Object.defineProperty(obj, key, { get: function () { if (window.__func \u0026amp;\u0026amp;!funcs.includes(window.__func)) { funcs.push(window.__func); } return innerValue; }, set: function (value) { innerValue = value; }, }); } } 这就实现了依赖收集。\n然后呢，在有函数调用set方法的时候，只需要调用funcs里面的所有函数即可，也就是派发更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; let funcs = []; Object.defineProperty(obj, key, { get: function () { if (window.__func \u0026amp;\u0026amp;!funcs.includes(window.__func)) { funcs.push(window.__func); } return innerValue; }, set: function (value) { for (let i = 0; i \u0026lt; funcs.length; i++) { funcs[i](); } innerValue = value; }, }); } } 4.设计代理 但是，每次在调用get方法前还要自己手动设置全局变量还是太麻烦。如何把这个过程也自动化呢？\n其实我们就是想加强调用了属性get方法的函数的功能，而由于我们做的是通用组件又不好直接修改函数本身。\n这时，可以建一个新的对象或者函数，由它代理，或者说替代我们访问旧的函数或对象。\n例如\n1 2 3 4 5 function runFunc(func) { window.__func = func; func(); window.__func = null; } 以后，用户想调用func就使用runFunc代理，由runFunc替用户访问func。现在只要用户用这个函数访问func并且设置了被watch的对象，那么就实现了响应式了。\n","date":"2024-11-13T20:05:21+08:00","permalink":"https://ColaBlack.github.io/p/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%AE%80%E5%8C%96/","title":"响应式原理（简化）"},{"content":"初次发布于我的个人文档\n参考：\n1.1Panel 官方文档\n本文介绍一下如何利用1panel部署一个简单的前后端分离项目。\n1,拥有一个Liunx服务器 第一步是购买一个Linux服务器，可以买一台线下真实的机器+公网IP或买一个阿里云、腾讯云、京东云、华为云服务器。\n2.安装1panel 参考1panel官方文档，安装1panel。\n在这里以Ubuntu系统为例，只需运行\n1 curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh \u0026amp;\u0026amp; sudo bash quick_start.sh 即可安装，安装完成后终端上有写1panel的URL和账号名密码。\n3.安装运行环境 在虚拟机中安装java等运行环境。\n然后，可以在1panel中安装项目需要的中间件，如MySQL、minio、redis等。\n4.打包后端项目 先介绍一下如何打包maven项目。\n需要注意的是，你可能会发现在idea的maven菜单里，已经有一个package选项了，然而默认情况下这样打的包是不带项目依赖的。所以这样的jar包不能独立运行。\n但是如果你用的是spring boot项目，则pom.xml中可能已经安装了插件spring-boot-maven-plugin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 如果pom.xml有这样的代码则说明maven有插件spring-boot-maven-plugin。\n这时直接在idea的maven菜单运行package选项就得到带依赖的jar包了，可以直接java -jar运行。\n以部署笔者的teaai项目为例，打包后你会在target文件夹下看到teaai-backend-0.0.1-SNAPSHOT.jar，这就是打包后的jar文件，直接运行即可启动后端服务。\n对于非spring boot项目又该如何打包呢？\n需要安装maven-assembly-plugin插件，方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\u0026lt;!-- 插件版本号 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;edu.zafu.teaai.MainApplication\u0026lt;/mainClass\u0026gt; \u0026lt;!-- 替换为你的主类的完整类名 --\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 然后再运行package即可。\n对于gradle项目，没有什么太大的区别。\n这里只介绍一般的gradle项目如何打带依赖的jar包。\ngradle依赖打包需要安装shadow插件，在build.gradle.kts中的plugins，增加这样的代码：\n1 2 3 plugins { id(\u0026#34;com.gradleup.shadow\u0026#34;) version \u0026#34;8.3.3\u0026#34; } 然后增加shadow任务，同样还是在build.gradle.kts中增加一下代码：\n1 2 3 4 5 6 7 8 9 tasks { shadowJar { archiveBaseName.set(\u0026#34;nocrud\u0026#34;) archiveVersion.set(\u0026#34;\u0026#34;) manifest { attributes[\u0026#34;Main-Class\u0026#34;] = \u0026#34;cn.cola.nocrud.MainKt\u0026#34; } } } 这段代码以笔者的nocrud项目为例，在上面的代码中nocrud是你项目的名称，attributes[\u0026quot;Main-Class\u0026quot;] = \u0026quot;cn.cola.nocrud.MainKt\u0026quot;则规定了主类。\n需要注意的是，如果你的主类是一个kotlin代码，则需要再原本的类名后面加上Kt，这是因为kotlin是一个jvm语言，编译后你会发现kotlin编译器会在所有的kotlin类名称后面加上Kt。\n完成了这些，刷新一下项目，你会发现idea的gradle菜单中新增了一个shadow任务，双击shadowJar命令执行即可打包。\n打包完的jar包在build/libs目录内。\n5.启动后端项目 在1panel-主机-文件中上传打包后的jar包。\n然后到网站-运行环境-java中运行后端项目。\n当然如果你的后端是go语言或php或nodejs那么就去对应的页面。\n本文以java项目为例，选择创建运行环境，设置名称和java sdk版本，将运行目录设置为jar包的上传目录。\n在启动命令一栏输入完整的启动命令，如\n1 java -jar ./teaai-backend-0.0.1-SNAPSHOT.jar 然后注意，1panel和宝塔面板有所不同，1panel的后端项目也是基于容器化部署的，需要填写应用在容器内的访问端口和容器外的端口。\n然后打开端口外部访问并设置容器名称。\n点击确定即可。\n最后提醒一下，因为1panel是容器化部署，而在容器内localhost指向的是容器内部的地址，如果想访问容器网外的本机的其他容器请使用本机的真实内网IP。\n6.部署其他中间件 这里需要根据中间件的不同进行部署，如关系型数据库需要建表等。\n7.打包前端项目 这里以打包teaai项目为例，teaai是一个vue项目。\n用WebStrom打开teaai前端项目，一般而言当你利用vue-cli创建项目时，在package.json中有这样的命令。\n1 \u0026#34;build\u0026#34;: \u0026#34;run-p type-check \\\u0026#34;build-only {@}\\\u0026#34; --\u0026#34;, 你可以直接点击WebStorm左边的运行按钮运行，也可以在终端中输入\n1 npm run build 打包项目。\n当然，如果你用pnpm或yarn等运行这个命令也一样。\n打包后你将在dist目录下看到打包后的结果。\n8.启动前端项目 进入1panel-网站-运行环境-php创建一个php运行环境，拓展模版选择“默认”即可。\n然后去你的DNS服务商配置域名解析（这个因服务商而不同，在此无法演示）。\n接下来进入1panel面板-网站-网站，如果你没有安装OpenResty（你可以理解为nginx增强版）则1panel会提示你安装。\n在网站页面选择创建网站-运行环境-选择刚刚创建的php运行环境\n（如果你的网站是静态网站也可以不创建php运行环境而直接选静态网站）\n输入网站的域名和需要访问的端口号,点击确定。\n你会看到1panel页面的表格中多了一条记录，点击其中的网站目录下的文件夹图标，进入文件界面上传前端打包的dist目录的内容。\n接着。如果要设置代理和https服务的话，回到刚刚的1panel-网站-网站页面，点击网站记录右边的配置，在这里可以对网站进行限流、反向代理、配置HTTPS服务等操作。\n如果开启了https服务，记得在防火墙打开443端口！\n","date":"2024-11-08T19:39:09+08:00","permalink":"https://ColaBlack.github.io/p/%E5%88%A9%E7%94%A81panel%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE-java%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85/","title":"利用1panel部署前后端分离项目 Java代码打包 前端打包"},{"content":"初次发布于我的个人文档\n参考:智谱ai官方文档\n1.安装依赖 在maven 的pom.xml中输入\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.bigmodel.openapi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oapi-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;release-V4-2.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.编写通用AI调用工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package edu.zafu.teaai.utils; import com.zhipu.oapi.ClientV4; import com.zhipu.oapi.Constants; import com.zhipu.oapi.service.v4.model.*; import edu.zafu.teaai.constant.AiConfig; import io.reactivex.Flowable; import java.util.ArrayList; import java.util.List; /** * AI调用模块 * * @author ColaBlack */ public class AiUtils { /** * 业务ID模版 */ private static final String REQUEST_ID_TEMPLATE = \u0026#34;teaAI-request-%s\u0026#34;; /** * AI调用客户端 */ private static final ClientV4 CLIENT = new ClientV4.Builder(AiConfig.API_KEY).build(); /** * 调用AI接口(同步) * * @param prompt 提示词 * @return AI返回的答案 */ public static String aiCaller(String prompt) { List\u0026lt;ChatMessage\u0026gt; messages = new ArrayList\u0026lt;\u0026gt;(); ChatMessage chatMessage = new ChatMessage(ChatMessageRole.USER.value(), prompt); messages.add(chatMessage); String requestId = String.format(REQUEST_ID_TEMPLATE, System.currentTimeMillis()); ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder() .model(AiConfig.MODEL_NAME) .stream(Boolean.FALSE) .invokeMethod(Constants.invokeMethod) .messages(messages) .requestId(requestId) .build(); ModelApiResponse invokeModelApiResp = CLIENT.invokeModelApi(chatCompletionRequest); return invokeModelApiResp.getData().getChoices().get(0).getMessage().getContent().toString(); } /** * 调用AI接口(SSE) * * @author ColaBlack */ public static Flowable\u0026lt;ModelData\u0026gt; aiCallerFlow(String prompt) { List\u0026lt;ChatMessage\u0026gt; messages = new ArrayList\u0026lt;\u0026gt;(); ChatMessage chatMessage = new ChatMessage(ChatMessageRole.USER.value(), prompt); messages.add(chatMessage); String requestId = String.format(REQUEST_ID_TEMPLATE, System.currentTimeMillis()); ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder() .model(AiConfig.MODEL_NAME). stream(Boolean.TRUE). invokeMethod(Constants.invokeMethod) .messages(messages) .requestId(requestId) .build(); ModelApiResponse invokeModelApiResp = CLIENT.invokeModelApi(chatCompletionRequest); return invokeModelApiResp.getFlowable(); } } 3.配置信息 将代码中的AiConfig.MODEL_NAME替换为要使用的模型名称，AiConfig.API_KEY替换为你的API_KEY\n4.调用AI 如果要同步调用AI，那就直接将全部的提示词传入aiCaller方法，耐心等待即可返回结果。\n这里消息的生产速度往往大于消费速度，因此可以考虑介入消息队列MQ。\n同步调用如果一直让用户长时间等待用户体验不好，可以使用流式调用。\n将全部的提示词传入aiCallerFlow方法得到一个Flowable对象。\n为了将AI响应的结果传给前端，可以采用轮询、SSE、WebSocket等方式。这里选择使用SSE将响应由服务端推送给前端。\n这里的代码是传入全部的提示词，返回一个SseEmitter对象给前端，方便前端使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public SseEmitter generateQuestionSSE(String prompt) { // 建立 SSE 连接对象，0 表示不超时 SseEmitter emitter = new SseEmitter(0L); // AI 生成的流式响应结果 Flowable\u0026lt;ModelData\u0026gt; modelDataFlowable = AiUtils.aiCallerFlow(prompt); modelDataFlowable // 指定观察者的线程池 .observeOn(Schedulers.io()) // 从智谱的响应中获取数据 .map(chunk -\u0026gt; chunk.getChoices().get(0).getDelta().getContent()) // 去掉响应中多余的空格 .map(message -\u0026gt; message.replaceAll(\u0026#34;\\\\s\u0026#34;, \u0026#34;\u0026#34;)) // 去掉为空字符串的响应 .filter(StringUtils::isNotBlank) .flatMap(message -\u0026gt; { // 将字符串转换为字符数组以便后续业务处理 List\u0026lt;Character\u0026gt; charList = new ArrayList\u0026lt;\u0026gt;(); for (char c : message.toCharArray()) { charList.add(c); } return Flowable.fromIterable(charList); }) .doOnNext(c -\u0026gt; { // 进行业务处理 // 然后发送结果，这里为了演示直接不进行处理将给一个字符c都全部如实发送 emitter.send(c); }) //当AI响应完毕时关闭SSE .doOnComplete(emitter::complete) // 订阅AI响应流 .subscribe(); return emitter; } 4.前端接受SSE消息\n这里选择使用原生的方式接收。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const handleSSE = async () =\u0026gt; { // 发送sse请求 const eventSource = new EventSource(REQUEST_URL) //传入请求地址 // 按项目给予用户生产中提示 alert(\u0026#39;生成中，请稍后\u0026#39;) // 开始监听sse消息 eventSource.onmessage = (event) =\u0026gt; { //解析后端推送的消息，这里以后端传JSON字符串为例 const res = JSON.parse(event.data) //进行处理，以追加到form.test为例 form.value.test = [...(form.value.test || []), res] } //处理报错和停止接受 eventSource.onerror = (event) =\u0026gt; { //正常停止接收 if (event.eventPhase === EventSource.CLOSED) { eventSource.close() alert(\u0026#39;生成结束\u0026#39;) } else { //报错记录日志 eventSource.close() console.error(\u0026#39;生成失败\u0026#39;) } } } ","date":"2024-11-04T19:35:19+08:00","permalink":"https://ColaBlack.github.io/p/%E6%99%BA%E8%B0%B1ai-java-sdk%E8%B0%83%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E6%93%8D%E4%BD%9C/","title":"智谱AI java SDK调用（前后端操作）"},{"content":"初次发布于我的个人文档\n参考资料 [FreeMarker官方文档（英文）](Apache FreeMarker Manual)\nFreeMarker 中文官方参考手册\nPicocli官方文档（英文）\npicocli-中文博客\n1.安装依赖 1 2 3 4 // https://mvnrepository.com/artifact/org.freemarker/freemarker implementation(\u0026#34;org.freemarker:freemarker:2.3.33\u0026#34;) // https://mvnrepository.com/artifact/info.picocli/picocli implementation(\u0026#34;info.picocli:picocli:4.7.6\u0026#34;) 2.编写Freemarker demo 参考官方文档，编写一个简单Freemarker的demo，生成一个Java文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import freemarker.template.Configuration import freemarker.template.TemplateExceptionHandler import java.io.File import java.io.OutputStreamWriter fun main() { // 创建配置对象 val config = Configuration(Configuration.VERSION_2_3_33) // 设置模板文件存放的目录 config.setDirectoryForTemplateLoading(File(\u0026#34;src/main/resources/templates\u0026#34;)) // 设置默认的编码格式 config.defaultEncoding = \u0026#34;UTF-8\u0026#34; // 设置异常处理器 config.templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER /* 利用HashMap创建数据模型 { \u0026#34;user\u0026#34;: \u0026#34;Big Joe\u0026#34;, \u0026#34;latestProduct\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/ColaBlack\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;No CRUD\u0026#34; } */ val hashMap = HashMap\u0026lt;String, Any\u0026gt;() hashMap[\u0026#34;user\u0026#34;] = \u0026#34;ColaBlack\u0026#34; val latest: MutableMap\u0026lt;String, Any\u0026gt; = HashMap() hashMap[\u0026#34;latestProduct\u0026#34;] = latest latest[\u0026#34;url\u0026#34;] = \u0026#34;https://github.com/ColaBlack\u0026#34; latest[\u0026#34;name\u0026#34;] = \u0026#34;No CRUD\u0026#34; // 获取模板文件 val template = config.getTemplate(\u0026#34;demo.ftl\u0026#34;) val out = OutputStreamWriter(File(\u0026#34;src/main/java/edu/zafu/generated/demo.java\u0026#34;).outputStream()) // 输出渲染后的内容 template.process(hashMap, out) // 关闭输出流 out.close() } 对应的模版文件demo.ftl如下：\n1 2 3 4 5 6 7 8 9 package edu.zafu.generated; public class demo { public static void main(String[] args) { System.out.println(\u0026#34;Hello ${user}\u0026#34;); System.out.println(\u0026#34;The latest product is ${latestProduct.name}\u0026#34;); System.out.println(\u0026#34;You can find it at ${latestProduct.url}\u0026#34;); } } 将模版文件放入src/main/resources/templates目录下，运行main 函数，将生成的Java文件输出到src/main/java/edu/zafu/generated/demo.java文件中。\n3.编写命令行picocli demo 参考官方文档，编写一个命令行demo，实现一个简单的ls命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import picocli.CommandLine import picocli.CommandLine.* import java.io.File import kotlin.system.exitProcess /** * ls命令demo * * @author ColaBlack */ // 定义一个dir命令，name为ls，description为该命令的描述信息，mixinStandardHelpOptions为true，表示该命令需要自动生成help选项 @Command(name = \u0026#34;dir\u0026#34;, description = [\u0026#34;列出当前目录的目录结构\u0026#34;], mixinStandardHelpOptions = true) // 定义一个dir类，继承Runnable接口，实现run方法，用于执行ls命令，其中Callable的泛型int表示call方法的返回值类型 class Dir : Runnable { // 该参数在命令行中指定，索引为0，description为描述信息 @Parameters(index = \u0026#34;0\u0026#34;, description = [\u0026#34;要列出的目录路径\u0026#34;]) var path: String? = null // 定义一个path变量，用于接收命令行参数 // 该选项缩写为-a，全称为--all，description为描述信息 @Option(names = [\u0026#34;-a\u0026#34;, \u0026#34;--all\u0026#34;], description = [\u0026#34;显示所有文件，包括隐藏文件\u0026#34;]) var showHidden = false // 定义一个showHidden变量，用于接收-a选项，是否显示隐藏文件 // 用户执行命令时，会调用run方法 override fun run() { if (path == null) { println(\u0026#34;文件路径不能为空\u0026#34;) return } val file = File(path!!) if (!file.exists()) { // 判断目录是否存在 println(\u0026#34;文件路径不存在: $path\u0026#34;) return } if (!file.isDirectory) { // 判断是否为目录 println(\u0026#34;$path 不是一个目录\u0026#34;) return } val files = file.listFiles() if (files == null) { // 判断目录是否为空 println(\u0026#34;目录为空\u0026#34;) return } for (item in files) { if (showHidden || !item.name.startsWith(\u0026#34;.\u0026#34;)) { println(item.name) } } } } fun main(args: Array\u0026lt;String\u0026gt;) { val exitCode = CommandLine(Dir()).execute(*args) // 执行命令 exitProcess(exitCode) // 退出程序 } 运行main函数并设置参数就可以使用CLI\n4.编写需要制作成模版的代码 编写需要制作成模版的代码，例如本项目的controller代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 package $cn.cola.controller; import cn.cola.model.dto.user.UserUpdateRequest; import cn.cola.model.dto.user.UserQueryRequest; import cn.cola.model.dto.user.UserAddRequest; import cn.cola.common.constant.UserConstant; import cn.cola.common.exception.ThrowUtils; import cn.cola.common.DeleteRequest; import cn.cola.common.BaseResponse; import cn.cola.common.ResultUtils; import cn.cola.common.AuthCheck; import cn.cola.common.ErrorCode; import cn.cola.model.po.User; import cn.cola.model.vo.UserVO; import cn.cola.service.UserService; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.web.bind.annotation.*; import org.springframework.beans.BeanUtils; import lombok.extern.slf4j.Slf4j; import javax.annotation.Resource; import java.util.List; /** * 用户接口 * * @author ColaBlack */ @RestController @RequestMapping(\u0026#34;/user\u0026#34;) @Slf4j public class UserController { @Resource private UserService userService; // region 增删改查 /** * 插入用户（仅管理员） * * @param userAddRequest 用户添加请求体 * @return 新增的用户ID */ @PostMapping(\u0026#34;/insert\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Long\u0026gt; insertUser(@RequestBody UserAddRequest userAddRequest) { ThrowUtils.throwIf(userAddRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userAddRequest.getUserAccount() == null || userAddRequest.getUserAccount().isEmpty(), ErrorCode.PARAMS_ERROR, \u0026#34;账号不能为空\u0026#34;); User user = new User(); BeanUtils.copyProperties(userAddRequest, user); int res = userService.getBaseMapper().insert(user); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，增加用户失败\u0026#34;); return ResultUtils.success(user.getId()); } /** * 删除用户(仅管理员) * * @param deleteRequest 删除请求体 * @return 删除的记录数 */ @PostMapping(\u0026#34;/delete\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; deleteUser(@RequestBody DeleteRequest deleteRequest) { ThrowUtils.throwIf(deleteRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(deleteRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); int res = userService.getBaseMapper().deleteById(deleteRequest.getId()); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，删除用户失败\u0026#34;); return ResultUtils.success(res); } /** * 修改用户(仅管理员) * * @param userUpdateRequest 用户更新请求体 * @return 更新的记录数 */ @PostMapping(\u0026#34;/update\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; updateUser(@RequestBody UserUpdateRequest userUpdateRequest) { ThrowUtils.throwIf(userUpdateRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userUpdateRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = new User(); BeanUtils.copyProperties(userUpdateRequest, user); int res = userService.getBaseMapper().updateById(user); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR); return ResultUtils.success(res); } /** * 分页查询用户列表（仅管理员） * * @param userQueryRequest 条件查询请求体 * @return 用户列表 */ @PostMapping(\u0026#34;/select/page\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Page\u0026lt;User\u0026gt;\u0026gt; selectUserByPage(@RequestBody UserQueryRequest userQueryRequest) { long current = userQueryRequest.getCurrent(); long size = userQueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 100, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;User\u0026gt; queryWrapper = userService.getQueryWrapper(userQueryRequest); Page\u0026lt;User\u0026gt; res = userService.getBaseMapper().selectPage(page, queryWrapper); return ResultUtils.success(res); } /** * 根据ID查询用户信息（仅管理员） * * @param userQueryRequest 条件查询请求体 * @return 用户信息 */ @PostMapping(\u0026#34;/select/id\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;User\u0026gt; selectUserById(@RequestBody UserQueryRequest userQueryRequest) { ThrowUtils.throwIf(userQueryRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userQueryRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = userService.getBaseMapper().selectById(userQueryRequest.getId()); return ResultUtils.success(user); } /** * 根据ID查询用户信息（全体用户） */ @GetMapping(\u0026#34;/get/id\u0026#34;) public BaseResponse\u0026lt;UserVO\u0026gt; getUserById(@RequestParam(\u0026#34;id\u0026#34;) long id) { ThrowUtils.throwIf(id \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = userService.getBaseMapper().selectById(id); UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); return ResultUtils.success(userVO); } /** * 分页查询用户信息（全体用户） */ @PostMapping(\u0026#34;/get/page\u0026#34;) public BaseResponse\u0026lt;Page\u0026lt;UserVO\u0026gt;\u0026gt; getUserByPage(@RequestBody UserQueryRequest userQueryRequest) { long current = userQueryRequest.getCurrent(); long size = userQueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 20, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;User\u0026gt; queryWrapper = userService.getQueryWrapper(userQueryRequest); Page\u0026lt;User\u0026gt; res = userService.getBaseMapper().selectPage(page, queryWrapper); Page\u0026lt;UserVO\u0026gt; userVoPage = new Page\u0026lt;\u0026gt;(); BeanUtils.copyProperties(res, userVoPage); List\u0026lt;UserVO\u0026gt; records = userVoPage.getRecords(); records.clear(); for (User user : res.getRecords()) { UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); records.add(userVO); } return ResultUtils.success(userVoPage); } // endregion // region 其他接口 // todo: 此处补充其他接口 // endregion } 这个文档最先是在我的另一个个人文档网站的，但是在文档迁移的时候这个文件出了问题，里面的内容是我手工复原的，这段模版代码可能有问题，但是这不影响这篇文章的内容。\n5.编写FreeMarker模版 将原代码中可以被参数化的部分用${}包裹起来就得到了模版，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 package ${packageName}.controller; import ${packageName}.model.dto.${key}.${upperKey}UpdateRequest; import ${packageName}.model.dto.${key}.${upperKey}QueryRequest; import ${packageName}.model.dto.${key}.${upperKey}AddRequest; import ${packageName}.common.constant.${upperKey}Constant; import ${packageName}.common.exception.ThrowUtils; import ${packageName}.common.DeleteRequest; import ${packageName}.common.BaseResponse; import ${packageName}.common.ResultUtils; import ${packageName}.common.AuthCheck; import ${packageName}.common.ErrorCode; import ${packageName}.model.po.${upperKey}; import ${packageName}.model.vo.${upperKey}VO; import ${packageName}.service.${upperKey}Service; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.web.bind.annotation.*; import org.springframework.beans.BeanUtils; import lombok.extern.slf4j.Slf4j; import javax.annotation.Resource; import java.util.List; /** * ${name}接口 * * @author ${author} */ @RestController @RequestMapping(\u0026#34;/${key}\u0026#34;) @Slf4j public class ${upperKey}Controller { @Resource private ${upperKey}Service ${key}Service; // region 增删改查 /** * 插入${name}（仅管理员） * * @param ${key}AddRequest ${name}添加请求体 * @return 新增的${name}ID */ @PostMapping(\u0026#34;/insert\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Long\u0026gt; insert${upperKey}(@RequestBody ${upperKey}AddRequest ${key}AddRequest) { ThrowUtils.throwIf(${key}AddRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}AddRequest.get${upperKey}Account() == null || ${key}AddRequest.get${upperKey}Account().isEmpty(), ErrorCode.PARAMS_ERROR, \u0026#34;账号不能为空\u0026#34;); ${upperKey} ${key} = new ${upperKey}(); BeanUtils.copyProperties(${key}AddRequest, ${key}); int res = ${key}Service.getBaseMapper().insert(${key}); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，增加${name}失败\u0026#34;); return ResultUtils.success(${key}.getId()); } /** * 删除${name}(仅管理员) * * @param deleteRequest 删除请求体 * @return 删除的记录数 */ @PostMapping(\u0026#34;/delete\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; delete${upperKey}(@RequestBody DeleteRequest deleteRequest) { ThrowUtils.throwIf(deleteRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(deleteRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); int res = ${key}Service.getBaseMapper().deleteById(deleteRequest.getId()); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，删除${name}失败\u0026#34;); return ResultUtils.success(res); } /** * 修改${name}(仅管理员) * * @param ${key}UpdateRequest ${name}更新请求体 * @return 更新的记录数 */ @PostMapping(\u0026#34;/update\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; update${upperKey}(@RequestBody ${upperKey}UpdateRequest ${key}UpdateRequest) { ThrowUtils.throwIf(${key}UpdateRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}UpdateRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = new ${upperKey}(); BeanUtils.copyProperties(${key}UpdateRequest, ${key}); int res = ${key}Service.getBaseMapper().updateById(${key}); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR); return ResultUtils.success(res); } /** * 分页查询${name}列表（仅管理员） * * @param ${key}QueryRequest 条件查询请求体 * @return ${name}列表 */ @PostMapping(\u0026#34;/select/page\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Page\u0026lt;${upperKey}\u0026gt;\u0026gt; select${upperKey}ByPage(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { long current = ${key}QueryRequest.getCurrent(); long size = ${key}QueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 100, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;${upperKey}\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;${upperKey}\u0026gt; queryWrapper = ${key}Service.getQueryWrapper(${key}QueryRequest); Page\u0026lt;${upperKey}\u0026gt; res = ${key}Service.getBaseMapper().selectPage(page, queryWrapper); return ResultUtils.success(res); } /** * 根据ID查询${name}信息（仅管理员） * * @param ${key}QueryRequest 条件查询请求体 * @return ${name}信息 */ @PostMapping(\u0026#34;/select/id\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;${upperKey}\u0026gt; select${upperKey}ById(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { ThrowUtils.throwIf(${key}QueryRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}QueryRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = ${key}Service.getBaseMapper().selectById(${key}QueryRequest.getId()); return ResultUtils.success(${key}); } /** * 根据ID查询${name}信息（全体用户） */ @GetMapping(\u0026#34;/get/id\u0026#34;) public BaseResponse\u0026lt;${upperKey}VO\u0026gt; get${upperKey}ById(@RequestParam(\u0026#34;id\u0026#34;) long id) { ThrowUtils.throwIf(id \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = ${key}Service.getBaseMapper().selectById(id); ${upperKey}VO ${key}VO = new ${upperKey}VO(); BeanUtils.copyProperties(${key}, ${key}VO); return ResultUtils.success(${key}VO); } /** * 分页查询${name}信息（全体用户） */ @PostMapping(\u0026#34;/get/page\u0026#34;) public BaseResponse\u0026lt;Page\u0026lt;${upperKey}VO\u0026gt;\u0026gt; get${upperKey}ByPage(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { long current = ${key}QueryRequest.getCurrent(); long size = ${key}QueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 20, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;${upperKey}\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;${upperKey}\u0026gt; queryWrapper = ${key}Service.getQueryWrapper(${key}QueryRequest); Page\u0026lt;${upperKey}\u0026gt; res = ${key}Service.getBaseMapper().selectPage(page, queryWrapper); Page\u0026lt;${upperKey}VO\u0026gt; ${key}VoPage = new Page\u0026lt;\u0026gt;(); BeanUtils.copyProperties(res, ${key}VoPage); List\u0026lt;${upperKey}VO\u0026gt; records = ${key}VoPage.getRecords(); records.clear(); for (${upperKey} ${key} : res.getRecords()) { ${upperKey}VO ${key}VO = new ${upperKey}VO(); BeanUtils.copyProperties(${key}, ${key}VO); records.add(${key}VO); } return ResultUtils.success(${key}VoPage); } // endregion // region 其他接口 // todo: 此处补充其他接口 // endregion } 6.制作CLI工具 完整代码参考：No CRUD项目\n","date":"2024-10-29T19:35:19+08:00","permalink":"https://ColaBlack.github.io/p/%E7%B1%BBnocrud%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8Efreemarker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%B6%E4%BD%9C%E5%99%A8picocli/","title":"类NoCRUD项目开发手册 模版引擎FreeMarker 命令行制作器Picocli"},{"content":"初次发布于我的个人文档\n本文收集了一些常用的配置类，便于后续查询使用。\n后端常用配置 1.全局跨域配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package edu.zafu.teaai.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 全局跨域配置 * * @author ColaBlack */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 覆盖所有请求 registry.addMapping(\u0026#34;/**\u0026#34;) // 允许发送 Cookie .allowCredentials(true) // 放行哪些域名（必须修改为你实际的域名，否则 * 会和 allowCredentials 冲突） .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .exposedHeaders(\u0026#34;*\u0026#34;); } } 注意：放行的域名，allowedOriginPatterns()必须修改为前端的域名，否则会冲突。\n2.避免Long转json时的精度丢失 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package edu.zafu.teaai.config; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import org.springframework.boot.jackson.JsonComponent; import org.springframework.context.annotation.Bean; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * 配置如何处理Json文本 * * @author ColaBlack */ @JsonComponent public class JsonConfig { /** * 添加 Long 转 json 精度丢失的配置 */ @Bean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); SimpleModule module = new SimpleModule(); module.addSerializer(Long.class, ToStringSerializer.instance); module.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(module); return objectMapper; } } 在Java中Long类型是64位有符号整数，‌范围从-9,223,372,036,854,775,808到9,223,372,036,854,775,807，然而在JavaScript中整数最长只有15位，所以需要在Long类型对象进行序列化时将Long类型转化为字符串避免精度丢失。\n此时，如果传递一个Long类型的ID则前端收到的是一个字符串，就不会有精度问题。\n3.开启MyBatis分页功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package edu.zafu.teaai.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * MyBatis Plus 配置 * * @author ColaBlack */ @Configuration @MapperScan(\u0026#34;edu.zafu.teaai.mapper\u0026#34;) public class MyBatisPlusConfig { /** * 拦截器配置 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } Mybatis的分页功能需要以上配置才能开启。\n4.开启MyBatis下划线转驼峰、逻辑删除功能 1 2 3 4 5 6 7 8 9 mybatis-plus: configuration: map-underscore-to-camel-case: true # 驼峰命名 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: logic-delete-field: is_delete # 全局逻辑删除的实体字段名 logic-delete-value: 1 # 逻辑已删除值（默认为 1） logic-not-delete-value: 0 # 逻辑未删除值（默认为 0） 需要在application.yml中增加以上配置。\n前端常用配置 1.前端为开发服务器开启代理解决跨域问题 1 2 3 4 5 6 7 8 9 server: { port: 1222, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:1221\u0026#39;, changeOrigin: true } } }, 在vite.config.ts的defineConfig函数传入的实参对象中增加这样的配置即可。\n其意义是，将前端开发服务器开在1222端口，将所有/api开头的请求代理到后端http://localhost:1221。\n以后只需要向前端服务器http://localhost:1222发请求即可。\n增加完之后你的配置文件可能长这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { fileURLToPath, URL } from \u0026#39;node:url\u0026#39; import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ server: { port: 3000, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:1221\u0026#39;, changeOrigin: true } } }, plugins: [ vue() ], resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) } } }) 对于这个配置，官方文档是这样说明的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 export default defineConfig({ server: { proxy: { // 字符串简写写法：http://localhost:5173/foo -\u0026gt; http://localhost:4567/foo \u0026#39;/foo\u0026#39;: \u0026#39;http://localhost:4567\u0026#39;, // 带选项写法：http://localhost:5173/api/bar -\u0026gt; http://jsonplaceholder.typicode.com/bar \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;), }, // 正则表达式写法：http://localhost:5173/fallback/ -\u0026gt; http://jsonplaceholder.typicode.com/ \u0026#39;^/fallback/.*\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/fallback/, \u0026#39;\u0026#39;), }, // 使用 proxy 实例 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, configure: (proxy, options) =\u0026gt; { // proxy 是 \u0026#39;http-proxy\u0026#39; 的实例 } }, // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u0026gt; ws://localhost:5174/socket.io // 在使用 `rewriteWsOrigin` 时要特别谨慎，因为这可能会让代理服务器暴露在 CSRF 攻击之下 \u0026#39;/socket.io\u0026#39;: { target: \u0026#39;ws://localhost:5174\u0026#39;, ws: true, rewriteWsOrigin: true, }, }, }, }) 官方文档链接：开发服务器选项 | Vite 官方中文文档\n2.配置axios请求 在src/config下创建request.ts用于配置axios。\n配置内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import axios from \u0026#39;axios\u0026#39; export const BASE_URL = \u0026#39;http://localhost:1222\u0026#39; const request = axios.create({ baseURL: BASE_URL, timeout: 60000, withCredentials: true }) // 请求拦截器 request.interceptors.request.use( function (config) { // Do something before request is sent return config }, function (error) { // Do something with request error return Promise.reject(error) } ) // 响应拦截器 request.interceptors.response.use( function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data const { data } = response // 未登录 if (data.code === 40100) { // 不是获取用户信息接口，并且不是登录页面，则跳转到登录页面并保存当前页面的路径 if ( !response.request.responseURL.includes(\u0026#39;user/get/login\u0026#39;) \u0026amp;\u0026amp; !window.location.pathname.includes(\u0026#39;/user/login\u0026#39;) ) { window.location.href = `/user/login?redirect=${window.location.href}` } } return response }, function (error) { // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error return Promise.reject(error) } ) export default request BASE_URL务必换成自己后端的地址（如果前端开了代理则为前端的地址），真实上线时请修改为真实的请求地址！\nwithCredentials: true请务必开启，否则cookie会有问题。\n3. Umijs/openapi 在有些时候，我们可能已经有了一份openapi格式的接口文档。（如：后端已经开发完成则可以使用swagger或knife4j自动生成接口文档）\n这时可以使用umijs/openapi自动生成请求代码。\n需要在src/config下新建openapi.config.js配置如下：\n1 2 3 4 5 6 7 import { generateService } from \u0026#39;@umijs/openapi\u0026#39; generateService({ requestLibPath: \u0026#34;import request from \u0026#39;@/config/request\u0026#39;\u0026#34;, schemaPath: \u0026#39;http://localhost:1221/api/v2/api-docs\u0026#39;, serversPath: \u0026#39;./src\u0026#39; }) 然后在package.json中增加如下运行脚本\n1 \u0026#34;openapi\u0026#34;: \u0026#34;node src/config/openapi.config.js\u0026#34; 4.Pinia存储用户登录态样例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { defineStore } from \u0026#39;pinia\u0026#39; import type { Ref } from \u0026#39;vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; import { getLoginUserUsingGet } from \u0026#39;@/api/userController\u0026#39; import type { AxiosResponse } from \u0026#39;axios\u0026#39; import roleEnums from \u0026#39;@/access/roleEnums\u0026#39; export const useUserStore = defineStore(\u0026#39;USER_LOGIN_STATE\u0026#39;, () =\u0026gt; { const loginUser: Ref\u0026lt;API.LoginUserVO\u0026gt; = ref({ userName: \u0026#39;未登录\u0026#39; }) async function fetchLoginUser() { const res: AxiosResponse\u0026lt;API.BaseResponseLoginUserVO_\u0026gt; = await getLoginUserUsingGet() if (res.data.code === 200 \u0026amp;\u0026amp; res.data.data) { loginUser.value = res.data.data } else { loginUser.value = { userName: \u0026#39;未登录\u0026#39;, userRole: roleEnums.PUBLIC } } } function setLoginUser(newUser: API.LoginUserVO) { loginUser.value = newUser } return { loginUser, fetchLoginUser, setLoginUser } }) ","date":"2024-10-28T19:39:49+08:00","permalink":"https://ColaBlack.github.io/p/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/","title":"常用配置类"},{"content":"初次发布于我的个人文档\n参考：\n1,MINIO在java中的使用\n2.MinIO Linux官方文档\n1.利用1panel安装minio 图片上传等服务依赖于对象存储服务，本文就以开源对象储存minio为例简单介绍。\n推荐使用linux版本的minio，只需在1panel应用商城傻瓜式安装即可。\n记得记好你的root账户用户名和密码，另外minio不支持弱密码弱用户名！\n1panel基于容器部署，记得开启外部访问权限。\n2.安装java sdk 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/io.minio/minio --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.minio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;minio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 或\n1 2 // https://mvnrepository.com/artifact/io.minio/minio implementation(\u0026#34;io.minio:minio:8.5.13\u0026#34;) 3.配置minio连接 在applicantion.yml添加如下配置。\n1 2 3 4 minio: endpoint: http://你的minio主机:9000 accesskey: 你的ak secretkwy: 你的sk 注意，minio默认9000端口是上传文件的端口，9001是其web控制台端口，ak‘和sk都可以在那里获取。\n然后新增配置类：\n先配置如何在applicantion.yml中读取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package edu.zafu.teaai.config; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * 获取minio的配置信息 * * @author ColaBlack */ @Data @Component @ConfigurationProperties(prefix = \u0026#34;minio\u0026#34;) // 此处说明了要读取minio.*的配置信息 public class MinioProps { /** * minio的url */ private String endpoint; /** * minio的ak */ private String accesskey; /** * minio的sk */ private String secretkwy; } 然后是真正着手配置minio\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package edu.zafu.teaai.config; import io.minio.MinioClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.annotation.Resource; /** * minio配置类 * * @author ColaBlack */ @Configuration public class MinioConfig { @Resource private MinioProps props; /** * 获取 Minio客户端对象 * * @return MinioClient */ @Bean public MinioClient minioClient() { return MinioClient.builder() .endpoint(props.getEndpoint()) .credentials(props.getAccesskey(), props.getSecretkwy()) .build(); } } 最后是在minio上传文件的工具类。\n这也是重点中的重点。\n对象存储以存储桶为基本单位，你可以粗略得认为存储桶就是一个“数据库”，下面来介绍一下如何创建存储桶。\n当然，事实上这个存储桶应该由管理员在minio web界面上创建而不是用java程序创建。不过无妨，这里也讲讲。\n我们要通过刚刚配置的minio客户端对minio进行操作，所以要先通过依赖注入获取客户端。\n1 2 @Resource private MinioClient client; 然后再写一个方法创建指定名称的存储桶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 创建桶 * * @param bucketName 桶名称 */ public void createBucket(String bucketName) { boolean found = client.bucketExists( BucketExistsArgs.builder(). bucket(bucketName) .build() ); if (!found) { client.makeBucket( MakeBucketArgs.builder() .bucket(bucketName) .build()); } } 第一段代码是通过客户端的bucketExists方法判断指定名称的存储桶是否存在。\n但是我们还得给他传一个查询参数才行，这就是括号里面传的参数了。\n通过\n1 BucketExistsArgs.builder().bucket(bucketName).build() 即可得到一个查询桶名称为字符串bucketName内容的桶。\n如果存在这样的桶则found=true，反之为false。\n下一段则是说，如果桶不存在，那就通过client.makeBucket创建桶。\n当然，你可能会发现idea报error说方法可能抛出两个异常，你可以通过try catch手动捕获异常进行处理，也可以加上lombok的@SneakyThrows交由lombok自动处理。\n最后上传文件的工具方法就变成了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Resource private MinioClient client; /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } 删除桶啊什么的自己看文档吧，实际上暂时只有上传文件和获取文件的URL会用到。\n上传文件则需要文件的输入流stream等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 * @param type 文件类型 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize, String type) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .contentType(type) .build()); } 需要注意的是，一般而言文件类型minio可以自己根据后缀名自己识别，在这里可以不给出。\n常见的文件类型\ntext/plain: 文本文件（.txt） text/html: HTML文件（.html, .htm） application/json: JSON文件（.json） application/xml: XML文件（.xml） image/jpeg: JPEG图片（.jpg, .jpeg） image/png: PNG图片（.png） image/gif: GIF图片（.gif） application/pdf: PDF文件（.pdf） application/zip: ZIP文件（.zip） 所以最简单的上传方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } 还有一个需要的是获取文件的外链，也就是外部可以访问的URL信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 获取文件在minio在服务器上的外链 * * @param bucketName 桶名称 * @param objectName 文件名 * @return 外链 */ @SneakyThrows public String getObjectUrl(String bucketName, String objectName) { return client.getPresignedObjectUrl( GetPresignedObjectUrlArgs.builder() .method(Method.GET) .bucket(bucketName) .object(objectName) .build()); } 其他的方法可以自己查询文档获取，使用率并不高。\n最终整个工具类的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package edu.zafu.teaai.utils; import io.minio.GetPresignedObjectUrlArgs; import io.minio.MinioClient; import io.minio.PutObjectArgs; import io.minio.http.Method; import lombok.SneakyThrows; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.io.InputStream; /** * minio操作类 * * @author ColaBlack */ @Component public class MinioUtils { @Resource private MinioClient client; /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } /** * 获取文件在minio在服务器上的外链 * * @param bucketName 桶名称 * @param objectName 文件名 * @return 外链 */ @SneakyThrows public String getObjectUrl(String bucketName, String objectName) { return client.getPresignedObjectUrl( GetPresignedObjectUrlArgs.builder() .method(Method.GET) .bucket(bucketName) .object(objectName) .build()); } } 4.编写工具类和service层代码 本文以头像上传为例进行简介。\n首先编写service层接口代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package edu.zafu.teaai.service; import edu.zafu.teaai.model.dto.file.UploadFileRequest; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; /** * minio文件服务接口 * * @author ColaBlack */ public interface MinioService { /** * 上传文件 * * @param file 上传的文件 * @param uploadFileRequest 上传文件请求 * @param request 请求对象 * @return 上传结果 */ String uploadImage( MultipartFile file, UploadFileRequest uploadFileRequest, HttpServletRequest request); /** * 验证文件 * * @param file 文件 */ void validFile(MultipartFile file); } 接着在编写实现类时会遇到几个常量， 在此提前给出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 文件上传相关常量 * * @author ColaBlack */ public interface FileConstant { /** * 上传文件最大大小1MB */ int MAX_FILE_SIZE = 1048576; /** * 允许上传的图片类型 */ List\u0026lt;String\u0026gt; ALLOW_IMAGE_TYPES = Arrays.asList(\u0026#34;jpg\u0026#34;, \u0026#34;jpeg\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;svg\u0026#34;, \u0026#34;webp\u0026#34;, \u0026#34;bmp\u0026#34;); } 这两个常量都是用于验证头像信息的。\n然后是编写实现类，首先是验证图片信息的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 校验文件 * * @param file 文件 */ @Override public void validFile(MultipartFile file) { ThrowUtils.throwIf(ObjectUtils.isEmpty(file), ErrorCode.PARAMS_ERROR, \u0026#34;文件不能为空\u0026#34;); // 文件大小 long fileSize = file.getSize(); if (fileSize \u0026gt; FileConstant.MAX_FILE_SIZE) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件大小不能超过 1M\u0026#34;); } // 文件后缀 String fileSuffix = FileUtil.getSuffix(file.getOriginalFilename()); if (!FileConstant.ALLOW_IMAGE_TYPES.contains(fileSuffix)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件类型错误\u0026#34;); } } 主要是对文件大小和文件类型进行了限制。\n然后是重头戏，操作minio上传文件。\n在上传文件前需要根据业务进行一些检查，例如只有已登录用户才能上传头像等等，在此只调用刚刚写的validFile方法。\n1 2 // 校验文件 validFile(file); 然后是对用户上传的头像进行重命名，避免两个不同的用户上传了同一名字的图片导致异常覆盖。\n本文以：业务名_当前时间戳_随机uuid_文件原始名称为重命名模版。\n1 2 3 //重命名文件 FileUploadBizEnum fileUploadBizEnum = FileUploadBizEnum.getEnumByValue(biz); String fileName = biz + \u0026#34;_\u0026#34; + System.currentTimeMillis() + \u0026#34;_\u0026#34; + UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); 然后调用minioUtils的方法上传文件即可。\n1 2 3 4 //使用minio上传文件 minioUtils.putObject(FileConstant.BUCKET_NAME, fileName, file.getInputStream(), file.getSize()); //获取外链 return minioUtils.getObjectUrl(FileConstant.BUCKET_NAME, fileName); 最后minio服务实现类的代码就是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package edu.zafu.teaai.service.impl; import cn.hutool.core.io.FileUtil; import edu.zafu.teaai.common.ErrorCode; import edu.zafu.teaai.common.exception.BusinessException; import edu.zafu.teaai.common.exception.ThrowUtils; import edu.zafu.teaai.constant.FileConstant; import edu.zafu.teaai.constant.UserConstant; import edu.zafu.teaai.service.MinioService; import edu.zafu.teaai.utils.MinioUtils; import lombok.SneakyThrows; import org.apache.commons.lang3.ObjectUtils; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.UUID; /** * Minio文件服务实现类 * * @author ColaBlack */ @Service public class MinioServiceImpl implements MinioService { @Resource private MinioUtils minioUtils; /** * 上传文件 * * @param file 上传的文件 * @param biz 业务类型 * @param request 请求对象 * @return 上传结果 */ @SneakyThrows @Override public String uploadImage(MultipartFile file, String biz, HttpServletRequest request) { // 校验文件 validFile(file); //登录用户才能上传文件 Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE); ThrowUtils.throwIf(ObjectUtils.isEmpty(attribute), ErrorCode.NOT_LOGIN_ERROR, \u0026#34;用户未登录\u0026#34;); //重命名文件 String fileName = biz + \u0026#34;_\u0026#34; + System.currentTimeMillis() + \u0026#34;_\u0026#34; + UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); //使用minio上传文件 minioUtils.putObject(FileConstant.BUCKET_NAME, fileName, file.getInputStream(), file.getSize()); //获取外链 return minioUtils.getObjectUrl(FileConstant.BUCKET_NAME, fileName); } /** * 校验文件 * * @param file 文件 */ @Override public void validFile(MultipartFile file) { ThrowUtils.throwIf(ObjectUtils.isEmpty(file), ErrorCode.PARAMS_ERROR, \u0026#34;文件不能为空\u0026#34;); // 文件大小 long fileSize = file.getSize(); if (fileSize \u0026gt; FileConstant.MAX_FILE_SIZE) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件大小不能超过 1M\u0026#34;); } // 文件后缀 String fileSuffix = FileUtil.getSuffix(file.getOriginalFilename()); if (!FileConstant.ALLOW_IMAGE_TYPES.contains(fileSuffix)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件类型错误\u0026#34;); } } } 最后提醒一下，别忘了service层实现类要有Service注解。\n5.编写controller层代码 在编写前需要先针对项目的业务编写枚举类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package edu.zafu.teaai.model.enums; import lombok.AllArgsConstructor; import lombok.Getter; import org.apache.commons.lang3.ObjectUtils; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; /** * 文件上传业务类型枚举 * * @author ColaBlack */ @Getter @AllArgsConstructor public enum FileUploadBizEnum { /** * 用户头像上传 */ USER_AVATAR(\u0026#34;用户头像\u0026#34;, \u0026#34;user_avatar\u0026#34;), /** * 业务类型名称 */ private final String text; /** * 业务类型值 */ private final String value; /** * 获取值列表 */ public static List\u0026lt;String\u0026gt; getValues() { return Arrays.stream(values()).map(item -\u0026gt; item.value).collect(Collectors.toList()); } /** * 根据 value 获取枚举 */ public static FileUploadBizEnum getEnumByValue(String value) { if (ObjectUtils.isEmpty(value)) { return null; } for (FileUploadBizEnum anEnum : FileUploadBizEnum.values()) { if (anEnum.value.equals(value)) { return anEnum; } } return null; } } 在controller层，先注入minioService，然后进行简单的校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Resource private MinioService minioService; @PostMapping(\u0026#34;/upload/avatar\u0026#34;) public BaseResponse\u0026lt;String\u0026gt; uploadAvatar(@RequestPart(\u0026#34;file\u0026#34;) MultipartFile file, UploadFileRequest uploadFileRequest, HttpServletRequest request) { //登录用户才能上传文件 Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE); ThrowUtils.throwIf(ObjectUtils.isEmpty(attribute), ErrorCode.NOT_LOGIN_ERROR, \u0026#34;用户未登录\u0026#34;); // 校验业务类型 String biz = uploadFileRequest.getBiz(); FileUploadBizEnum fileUploadBizEnum = FileUploadBizEnum.getEnumByValue(biz); ThrowUtils.throwIf(!Objects.equals(fileUploadBizEnum, FileUploadBizEnum.USER_AVATAR), ErrorCode.PARAMS_ERROR, \u0026#34;上传业务类型不正确\u0026#34;); // 上传文件 String res = minioService.uploadImage(file, biz, request); return ResultUtils.success(res); } 然后调用service层代码即可。\n","date":"2024-10-27T19:40:47+08:00","permalink":"https://ColaBlack.github.io/p/minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-%E5%9B%BE%E7%89%87-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E5%A4%B4%E5%83%8F/","title":"Minio对象存储 图片 图片上传 头像"},{"content":"初次发布于我的个人文档\n参考：缓存雪崩，缓存击穿，缓存穿透 Caffeine本地缓存\n在一些场景下可以引入缓存加速，利用redis实现缓存通常是一个不错的选择，但有时为了避免系统变得复杂可以使用本地缓存。 Caffeine就是一个高效的本地缓存组件。使用方式如下：\n1.安装依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.创建用于缓存的key-value键值对 1 2 3 4 5 6 Cache\u0026lt;String, String\u0026gt; answerCacheMap = Caffeine.newBuilder() //初始化缓存键值对容量 .initialCapacity(1024) // 设置缓存有效期为一天 .expireAfterAccess(1L, TimeUnit.DAYS) .build(); 利用缓存是为了提高速度，但是缓存的数据并不会及时更新，所以需要设置有效期，即 超时是为了保证数据的有效。缓存有效期需要根据业务的不同自行设置。\n3.新增和读取缓存 1 2 3 4 5 6 7 8 9 // 从刚刚的缓存键值对中读取缓存的cacheKey对应的数据 String cache = answerCacheMap.getIfPresent(cacheKey); // 如果没有命中缓存，则取出的cache字符串为空 if (StringUtils.isEmpty(cache)) { // 未命中缓存，走正常的业务逻辑 cache = work(); // 缓存结果 answerCacheMap.put(cacheKey, json); } 4.缓存的问题 无论用什么方式实现缓存都需要注意以下几个问题：\n缓存击穿 缓存击穿指在某一个时间有大量同一个key对应的缓存键值对过期或redis、caffeine等缓存中间件故障，与此同时客户端直接向业务系统（如数据库）发起请求，从而导致业务系统接着崩溃。\n解决方法有： 预防性缓存更新：在热点数据即将过期时，提前异步刷新缓存。通过检测热点数据的访问频率，当即将过期时触发自动更新操作，避免过期瞬间的击穿问题。 双缓存机制：可以采用双层缓存策略：一个主要缓存层负责缓存大部分数据，另一个次缓存层保存上次的缓存数据。在主要缓存失效时，可以直接从次缓存层读取数据，避免直接打到业务系统。 加锁保证同时只有少量请求能够构建缓存和访问业务系统\n缓存雪崩 缓存雪崩指在某一个时间有大量不同的key对应的缓存键值对过期或redis、caffeine等缓存中间件故障，与此同时客户端直接向业务系统（如数据库）发起请求，从而导致业务系统接着崩溃。\n解决方法有： 将过期时间进行一定范围内的随机化 使用多级缓存 加锁保证同时只有少量请求能够构建缓存和访问业务系统 使用redis高可用集群等确保缓存尽量少得故障。\n缓存穿透 缓存穿透指用户恶意查询业务系统中本不可能存在的key导致每次请求都直接穿过缓存机制访问业务系统，如果恶意用户进行大量这样的查询则会导致业务系统因压力过大而崩溃。 解决方法： 缓存空结果：如果查询的某个键在业务系统中不应该存在，则将该键的查询结果（如 null 或空值）缓存起来，并设定一个较短的过期时间，防止该键反复查询打到业务系统。 阻止非法请求（使用黑名单机制）：在查询请求进入业务系统前，进行严格的参数校验和过滤，避免不合法的请求查询业务系统（避免黑名单内的请求进入）。 使用白名单机制：使用布隆过滤器对所有可能存在的数据进行标记（设为白名单），所有请求先经过布隆过滤器进行校验，只有布隆过滤器认为存在的数据（白名单的数据），才会去查询缓存或数据库。这样可以有效拦截掉绝大多数不存在的请求，防止这些请求绕过缓存直接打到数据库。\n","date":"2024-10-23T19:43:38+08:00","permalink":"https://ColaBlack.github.io/p/caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/","title":"Caffeine本地缓存和缓存雪崩 缓存击穿 缓存穿透"},{"content":"初次发布于我的个人文档\n参考:java操作163邮箱\n本文以163邮箱为例，介绍如何用java发送邮箱。\n1.获取邮箱授权码 进入163邮箱-设置-POP3/SMTP/IMAP-开启POP3/SMTP服务\n记录得到的授权码\n2.安装依赖 1 2 3 4 // https://mvnrepository.com/artifact/jakarta.activation/jakarta.activation-api implementation(\u0026#34;jakarta.activation:jakarta.activation-api:2.1.3\u0026#34;) // https://mvnrepository.com/artifact/org.apache.commons/commons-email implementation(\u0026#34;org.apache.commons:commons-email:1.6.0\u0026#34;) 注意，参考文章年代有些久远，有几个库已经合并更新换了新的名字。\n3.编写通用邮件发送工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package edu.zafu; import org.apache.commons.mail.EmailException; import org.apache.commons.mail.SimpleEmail; /** * 邮件工具类 * * @author ColaBlack */ public class MailUtils { /** * 发送邮件 * * @param targetEmail 目标用户邮箱 * @param header 邮件的标题 * @param message 要发送的消息 */ public static void sendEmail(String targetEmail, String header, String message) { try { // 创建邮箱对象 SimpleEmail mail = new SimpleEmail(); // 设置发送邮件的服务器，以163邮箱为例 mail.setHostName(\u0026#34;smtp.163.com\u0026#34;); // 输入发送邮件的邮箱号+授权码 mail.setAuthentication(\u0026#34;用于发送的邮箱号\u0026#34;, \u0026#34;授权码\u0026#34;); // 注意：一个邮箱账号可能有多个邮箱，要注意这个区分。 // 如QQ邮箱就支持同一个邮箱账号持有@qq.com @foxmail.com两个邮箱 // 发送邮件 \u0026#34;你的邮箱号\u0026#34;+\u0026#34;发送时用的昵称\u0026#34; mail.setFrom(\u0026#34;用于发送邮箱的邮箱号\u0026#34;, \u0026#34;昵称\u0026#34;); // 使用SSL安全链接 mail.setSSLOnConnect(true); // 接收用户的邮箱 mail.addTo(targetEmail); // 邮件的主题(标题) mail.setSubject(header); // 邮件的内容 mail.setMsg(message); // 发送 mail.send(); } catch (EmailException e) { // 邮件发送失败，记录日志(此处应该换成项目统一的日志记录方式) System.out.println(\u0026#34;邮件发送失败：\u0026#34; + e.getMessage()); } } } 4.调用工具类——以发验证码为例 编写发送验证码工具类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package edu.zafu; import java.util.Random; /** * 发送验证码工具类 * * @author ColaBlack */ public class SendCode { /** * 发送验证码 * * @param targetEmail 目标邮箱 */ public static void send(String targetEmail) { // 生成验证码 int code = new Random().nextInt(899999) + 100000; // 发送验证码 MailUtils.sendEmail(targetEmail, \u0026#34;验证码\u0026#34;, \u0026#34;您的验证码为:\u0026#34; + code + \u0026#34;(1分钟内有效)\u0026#34;); } } 可以使用如下代码测试\n1 2 3 4 5 6 7 8 9 10 11 12 package edu.zafu; /** * 测试邮箱发送 * * @author ColaBlack */ public class TestMail { public static void main(String[] args) { SendCode.send(\u0026#34;你的第二个邮箱\u0026#34;); } } 5.引入缓存机制 上面的验证码用户可以通过疯狂发送请求而恶意消耗邮箱发送资源，我们也没有让验证码及时过期。\n可以引入缓存机制解决，在上文Caffeine本地缓存和缓存雪崩，缓存击穿，缓存穿透中我们介绍了如何利用caffeine实现本地缓存，本文就选择用 Redis 实现分布式缓存。\n6.安装Redisson 为了在java中操作redis需要安装依赖\n1 2 // https://mvnrepository.com/artifact/org.redisson/redisson implementation(\u0026#34;org.redisson:redisson:3.37.0\u0026#34;) 7.调整验证码工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package edu.zafu; import org.redisson.Redisson; import org.redisson.api.RMapCache; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import java.util.Random; import java.util.concurrent.TimeUnit; /** * 发送验证码工具类 * * @author ColaBlack */ public class SendCode { /** * 发送验证码 * * @param targetEmail 目标邮箱 */ public static void send(String targetEmail) { Config config = new Config(); config.useSingleServer() // 使用单机模式 // 设置要连接的数据库 .setDatabase(0) // 设置redis服务器地址 .setAddress(\u0026#34;redis://127.0.0.1:6379\u0026#34;) // 设置redis密码 .setPassword(\u0026#34;password\u0026#34;); // 创建Redisson客户端 RedissonClient redisson = Redisson.create(config); // 获取缓存的map RMapCache\u0026lt;Object, Object\u0026gt; codeCache = redisson.getMapCache(\u0026#34;code\u0026#34;); // 判断目标邮箱是否已存在验证码 if (codeCache.containsKey(targetEmail)) { // 验证码已存在，直接返回 return; } // 验证码不存在，生成验证码并存入缓存 // 生成验证码 int code = new Random().nextInt(899999) + 100000; // 存入缓存,设置1分钟过期 codeCache.put(targetEmail, code, 1, TimeUnit.MINUTES); // 发送验证码 MailUtils.sendEmail(targetEmail, \u0026#34;验证码\u0026#34;, \u0026#34;您的验证码为:\u0026#34; + code + \u0026#34;(1分钟内有效)\u0026#34;); // 校验验证码是否正确时也从redis中拿去对应邮箱的验证码，这样就能实现验证码的超时过期 } } 关于使用缓存机制可能引发的缓存击穿、缓存雪崩、缓存穿透的问题请参考上文Caffeine本地缓存和缓存雪崩，缓存击穿，缓存穿透\n","date":"2024-10-23T19:41:34+08:00","permalink":"https://ColaBlack.github.io/p/java%E6%93%8D%E4%BD%9C%E9%82%AE%E7%AE%B1-%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81-redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-redisson%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/","title":"Java操作邮箱 邮箱发送验证码 Redis分布式缓存 Redisson分布式缓存"}]
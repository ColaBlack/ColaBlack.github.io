[{"content":"上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。\n在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。\n本系列就专门针对这种多元以上的情况进行分析。\n第一个部分就是对《概率论与数理统计》的拓展，在这门课里最常见的统计方法就是参数估计以及各种假设检验，还有什么方差分析啊云云。\n第一期就从参数估计开始。\n那要唠参数估计的话首先就得有参数吧。\n这个的话直接把一元的扩展出来就可以了。\n多元统计的参量 在多元情况呢，随机变量的维数就不是简单的一维了，所以我们不能用数字来表示随机变量而是要把随机变量化为随机向量。\n一般地，n维随机变量就要用一个n维向量表示即$X=\\begin{pmatrix} x_1 \\ x_2 \\ \u0026hellip;\\x_n \\end{pmatrix}$。\n","date":"2024-12-22T16:31:40+08:00","permalink":"https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%901-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","title":"多元统计分析(1) 参数估计"},{"content":"上次讲了线性方程组求解的迭代法，这次理所应得地就是来聊聊直接求解了。\n约当消去法和高斯消去法 其实线性方程组咱们在线性代数/高等代数里都聊过的，我自己也出了专门的线性方程组求解的专利而且还重制了一版，各位观众应该是比较熟悉了的才对。(线性方程组专栏链接在这里)\n这两个方法其实就是我们之前就会的，什么用初等行变换把矩阵化成行阶梯型行最简型甚至相抵标准型之类的。\n就是回带的时间不一样而已，绝当消去法是直接一把梭，消元到行最简型然后直接就能观察出解了，而高斯消去法只消到行阶梯型然后回代解一元一次方程。\n所以这两个方法我觉得无需多言（啊，看见这四个字又想玩梗了）。\n本文的重点在于利用矩阵分解来求解方程组。\nLU分解 这一切的基石来源于LU分解。\n不过在这里我要澄清一个观念。\n在线性代数/高等代数里我们强调过，矩阵乘法的几何意义是矩阵对应的线性变换的乘法（也就是复合），所以在这种意义上，所谓的矩阵分解应该是把一个矩阵分解成若干个矩阵的乘积。\n而在上文中，我曾经说把一个矩阵A分解为上三角U、下三角L、对角阵D使得A=D-L-U，这不是我们这里说的矩阵分解。这里所谓的分解只是从代数的角度或者说凑数的角度看把一个矩阵拆分成三个矩阵的和，是没有几何意义的。\n好，我们现在澄清完了可以开始LU分解的内容了。\nLU分解也是一种直接求解的方法，他是这样想的。\n我们对AX=b的系数矩阵A进行预处理，把他分解成下三角矩阵L和上三角矩阵U的乘积。\n即找一个下三角矩阵L和上三角矩阵U使得A=LU\n然后AX=b就是LUX=b，也就是L(UX)=b。\n为什么要这么做呢？\n因为这样我们可以换元，令y=UX\n则Ly=b是轻易求解的，UX=y也是轻易求解的。\n例如\n$ A=\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 5 \u0026amp; 2 \\ 3 \u0026amp; 1 \u0026amp; 5 \\end{pmatrix},b=\\begin{pmatrix} 14 \\ 18 \\ 20 \\end{pmatrix} $\n我们可以进行LU分解\n$ A=\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 5 \u0026amp; 2 \\ 3 \u0026amp; 1 \u0026amp; 5 \\end{pmatrix}=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ 3 \u0026amp; -5 \u0026amp; 1 \\end{pmatrix}\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 0 \u0026amp; 1 \u0026amp; -4 \\ 0 \u0026amp; 0 \u0026amp; 24 \\end{pmatrix}$\n显然前面那个矩阵就是L，后面那个是U。\n我们先解Ly=b，从上往下看第一个方程$y_1=14$直接解出来了。\n第二个方程$2y_1+y_2=18$，很容易解出$y_2=-10$。\n然后是第三个方程$3y_1-5y_2+y_3=20$，解出$y_3=-72$。\n果然容易求解吧。\n然后求解UX=y\n也就是\n$\\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\ 0 \u0026amp; 1 \u0026amp; -4 \\ 0 \u0026amp; 0 \u0026amp; 24 \\end{pmatrix}X=\\begin{pmatrix} 14 \\ -10 \\ -72 \\end{pmatrix}$\n从下往上看，第一个方程$24x_3=-72,x_3=3$，\n第二个方程$x_2-4x_3=-10,x_2=2$，\n第三方程$x_1+2x_2+3x_3=14,x_1=1$。\n现在就很轻易地解出了方程。\n但是问题来了，怎么进行LU分解呢？\n我们以分解$A=\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 2 \u0026amp; 2 \u0026amp; -2 \\ -2 \u0026amp; -3 \u0026amp; 13 \\end{pmatrix}$为例，先进行初等行变换。\n但是这里我们只能做把某一行的k倍加到另一行，从而把A化成上三角矩阵。\n$A=\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 2 \u0026amp; 2 \u0026amp; -2 \\ -2 \u0026amp; -3 \u0026amp; 13 \\end{pmatrix}$\n首先，第一行的一半加到第三行，然后第一行的-0.5倍加到第二行，然后你给4 2 -2这三个元素画圈。\n你会首先得到矩阵\n$\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 0 \u0026amp; 1 \u0026amp; -1 \\ 0 \u0026amp; -2 \u0026amp; 12 \\end{pmatrix}$\n然后再把第二行的2倍加到第三行，给1 -2画圈。\n得到\n$\\begin{pmatrix} 4 \u0026amp; 2 \u0026amp; -2 \\ 0 \u0026amp; 1 \u0026amp; -1 \\ 0 \u0026amp; 0 \u0026amp; 10 \\end{pmatrix}$\n这个就是U了，当然最后记得给10画圈。\n那L呢？\n我们只做了初等行变换对吧，我们知道给矩阵做初等行变换等价于在左边左乘一系列初等矩阵，L就是这些初等矩阵的乘积。\n为了保证这些初等矩阵的乘积是下三角矩阵所以我们才要求你只能做把某一行的k倍加到另一行这一种变换。\n那么这个L要不要自己手动去整理一下找到我们乘了哪些初等矩阵然后再计算乘积呢？不用这么麻烦。\n前面不是让你画圈了吗？\n你把画圈的元素拼起来，得到\n$\\begin{pmatrix} 4 \u0026amp; 0 \u0026amp; 0 \\ 2 \u0026amp; 1 \u0026amp; 0 \\ -2 \u0026amp; -2 \u0026amp; 10 \\end{pmatrix}$\n这个矩阵，还不是L啊哈哈。\n我们得到的L比这个还要强其实。\n我们的L是一个单位下三角！\n你要做的是，每一列乘以某个数把他变成单位下三角，也就是第一列除以4，第二列除以1，第三列除以10得到\n$\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ \\frac{1}{2} \u0026amp; 1 \u0026amp; 0 \\ -\\frac{1}{2} \u0026amp; -2 \u0026amp; 1 \\end{pmatrix}$\n这个才是L。\n我们这里分解出来的L是单位下三角，其实你也可以分解出单位上三角。\n换言之，LU分解是不唯一的。你也可以分解成两个普通的上下三角矩阵。\n所以为了保证分解的唯一性，我们会要求L或者U的其中一个是单位上下三角。\n如果L是单位下三角这样的分解叫Doolittle分解，U是单位上三角则这样的分解是Crout分解。\nCholoesky分解 除了LU分解之外还有办法。\n不过我们得给矩阵A加一些条件了。我们要求A是正定阵。\n如果A是正定矩阵我们会得到特殊的结论。\n先对A进行一次LU分解，A=LU\u0026rsquo;，接着如果我们对U\u0026rsquo;再次进行LU分解，你会得到$U’=DL^T$。\n所以正定矩阵A可以分解为$LDL^T$。\n这个就是Choloesky分解。\n其中D很特殊，D是一个对角阵，也就是说$U\u0026rsquo;$的LU分解分解出的下三角矩阵是一个对角阵而L是单位下三角矩阵。\n所以你应该意识到，两次LU分解进行的是不同的LU分解，第一次把L分解为单位下三角，也就是进行Doolittle分解，此时U‘是一般的上三角矩阵。\n然后对U\u0026rsquo;进行Crout分解，把分解出来的上三角化为单位上三角并且这个单位上三角刚好是$L^T$，此时下三角矩阵刚好是对角阵。\n所以如果是正定矩阵，你可以对A先进行一次LU分解，得到L，那么他的Choloesky分解里就只有对角阵D不知道了。\n而对角阵D其实也是很容易就知道的。\n因为U’你是知道的，而$U\u0026rsquo;=DL^T$，我们可以用这个关系得到D。\n例如$A=\\begin{pmatrix} 3 \u0026amp; 2 \u0026amp; 3 \\ 2 \u0026amp; 2 \u0026amp; 0 \\ 3 \u0026amp; 0 \u0026amp; 12 \\end{pmatrix}$\n进行一次LU分解得到\n哦对了，这个是这个网站计算得到的。（网址https://matrixcalc.org/zh-CN/)\n然后我们知道L和U\u0026rsquo;了\n由于U\u0026rsquo;=DL，你可以先用待定系数法求D。\n自己试试看，然后你就会发现好像不用那么麻烦了。\n因为\n$U\u0026rsquo;=\\begin{pmatrix} d_{11} \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; d_{22} \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; d_{33} \\end{pmatrix}\\begin{pmatrix} 1 \u0026amp; \\frac{2}{3} \u0026amp; 1 \\ 0 \u0026amp; 1 \u0026amp; -3 \\ 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix}$\n我们只算U’的对角元。\n第一行乘第一列，就是$d_{11}$\n第二行乘以第二列就是$d_{22}$\n第三行乘以第三列就是$d_{33}$\n所以D的对角元是啥？不就是U‘的对角元？所以D也可以直接看出来。\n平方根法（平方分解） 由Cholesky分解还可以进一步得到平方分解。\n对于正定矩阵A它可以分解为$LDL^T$\n但是D也可以进一步拆分啊。\n再构造一个对角阵$D\u0026rsquo;=diag(\\sqrt{d_{11}},\\sqrt{d_{22}},\u0026hellip;,\\sqrt{d_{nn}})$\n那么D就可以看作是$D\u0026rsquo;D\u0026rsquo;^T$\n所以$A=LDL^T=LD\u0026rsquo;D\u0026rsquo;^TL^T=(LD\u0026rsquo;)(LD\u0026rsquo;)^T$\n如果我设$L\u0026rsquo;=LD\u0026rsquo;$则$A=L\u0026rsquo;L\u0026rsquo;^T$\n此时我们说$L\u0026rsquo;=\\sqrt A$\n这就是A的平方根分解。\n只不过，相比于上一种方法这个方法其实计算量更大。\n这个叫平方根法，前面那种方法我们叫改进平方根法。\n啊哈哈，这次反而是先推出改进版的方法。\n追赶法 之前我们就说过，三对角矩阵可以用追赶法来求解。\n现在重要可以来唠唠追赶法了。\n追赶法其实就是对三对角矩阵的LU分解。\n但是三对角矩阵的LU分解也是特殊的。\n例如计算\n$A=\\begin{pmatrix} 2 \u0026amp; -1 \\ -1 \u0026amp; 2 \u0026amp; -1 \\ \u0026amp; -1 \u0026amp; 2 \u0026amp;-1 \\\u0026amp; \u0026amp; -1 \u0026amp;2 \u0026amp;-1\\\u0026amp; \u0026amp; \u0026amp; -1 \u0026amp;2 \\end{pmatrix}$\n它的L一定是这样的形式\n$L=\\begin{pmatrix} \\alpha_1 \u0026amp; \\ -1 \u0026amp; \\alpha_2 \\ \u0026amp; -1 \u0026amp; \\alpha_3 \\\u0026amp; \u0026amp; -1 \u0026amp;\\alpha_4 \\\u0026amp; \u0026amp; \u0026amp; -1 \u0026amp;\\alpha_5 \\end{pmatrix}$\n其中最下面那排-1啊，是和A的最下面那排一样的。\nA的U啊，是单位上三角\n$U=\\begin{pmatrix} 1 \u0026amp; \\beta_1 \\ \u0026amp; 1 \u0026amp; \\beta_2 \\ \u0026amp; \u0026amp; 1 \u0026amp;\\beta_3 \\\u0026amp; \u0026amp; \u0026amp;1 \u0026amp;\\beta_4\\\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\end{pmatrix}$\n那么关键就是证明求$\\alpha_i$和$\\beta_i$了呗。\n方法是直接把LU相乘，毕竟LU=A嘛\nL的第一行乘以U第一列得到$\\alpha_1=2$\n然后我们再算$\\beta_1$\n也就是L的第一行乘以U的第二列，得到$\\beta_1$\n然后我们算$\\alpha_2$\n用L的第二行乘以U的第二列。\n以此类推。\n你会发现我们是先算$\\alpha_i$再算$\\beta_i$\n所以形象的说就是有个追赶的过程。\n因此这个方法的名字叫追赶法。\n至于你说，我不想用矩阵乘法这么麻烦来算，其实这玩意儿有公式，但是我个人觉得反而更麻烦了，而且公式很难记忆，想知道的话还是自己上网查吧。\n到这里呢，常见的数值计算方法就罗列得差不多了，剩下来还有一个函数逼近的，什么最小二乘啊之类的，这个有空再更新吧，该换换胃口了。\n天天搞这个我会疯掉的。\n","date":"2024-12-22T15:06:59+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%955-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B3%95/","title":"数值计算方法(5) 矩阵分解与线性方程组求解的直接法"},{"content":"还是继续数值计算方法的讨论。本文想简要介绍一下如何用迭代法计算方程和方程组的根。这一次的难度低了很多，我写着也是轻松了不少。\n迭代法求解方程最核心的是利用不动点进行不动点迭代。\n不动点迭代 在高中阶段你可能学习过这样的叫蛛网图的东西：\n蛛网图迭代的极限就是函数的不动点。\n所谓不动点迭代就是利用了这样的性质。\n一般地，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，那么g(X)的不动点就是f(x)的零点。\n而g(x)的不动点又是蛛网图迭代的极限。\n如果用代数语言表示的话，就是迭代公式\n$$x_{k+1}=g(x_k)$$这就是不动点迭代求方程的根的方法。\n当然，如果要更严谨化的说明的话，就是下面的压缩映像原理：\n设g(x)在[a,b]上具有连续的一阶导数，且满足以下条件：\n1.$\\forall x \\in [a,b],g(x) \\in [a,b]$\n2.$\\exist 0 \\le L \u0026lt;1,s.t. \\forall x\\in [a,b],|g\u0026rsquo;(x)|\\le L$\n则迭代过程\n$x_{k+1}=g(x_k)$收敛，且有误差估计式：\n$|x^*-x_k|\\le \\frac{L^k}{1-L}|x_1-x_0|$\n这个是简化版的压缩映像原理了，如果你学过《泛函分析和实变函数》那么你见到的压缩映像原理应该是这样的：\n设(X,d)是完备的距离空间，T是其中自身到自身的映射即X→X，如果$\\forall x,y\\in X,\\exist L\\in(0,1), d(Tx,Ty) \\le Ld(x,y)$（满足这样条件的映射称为压缩映射），则存在唯一的$x^$使得$Tx^=x^*$\n用一句话来说就是，完备的距离空间上到自身的压缩映射必有唯一不动点。\n别扯那么多了，还是看简化版的吧。简化版还有误差估计式嘞。\n从简化版的误差估计式看，k越大估计值$x_k$会离准确值$x^*$越来越近。\n这就足以为不动点迭代法背书了。\n但是这里需要注意的是，无论是泛函分析里加强版的压缩映像原理还是我们这里的简化版压缩映像原理，它都是不动点存在的充分条件而不是必要条件。也就是说，如果你找到一个函数他不满足上面的条件，你其实是不能判定他不存在不动点的。在这里我也看到某些教材在这个地方出现了纰漏。\n如果严格按照定理的说法只使用定理的话，我们是没有办法判定某个函数不具备不动点的。\n除此之外，还有一个更重要的问题也更严重的问题。\n无论是简化版的压缩映像原理还是加强版的，我们都要求你找到一个严格大于0，严格小于1的常数L，可是在实践中经常有人把这个条件简化为$g\u0026rsquo;(x)\\le1$这也是不对的。\n不动点迭代的收敛速度 收敛性是已经知道了的，毕竟误差估计式都给出来了。但是各个不动点迭代的收敛速度还是有差别的。\n我们来考虑第k次迭代后的迭代误差$e_k=x^*-x_k$，如果下一次迭代的迭代误差在k趋于无穷大时和$e_k$的p次方是同阶无穷小我们就说这个迭代是p阶收敛的。\n特别的，p=1称为线性收敛，p=2是平方收敛。\n那我怎么知道一个迭代方法是几阶收敛的呢？其实很简单，我们要求解的是x=g(x)嘛，你在$x=x_k$处把$x^*$泰勒展开一下。\n$g(x_k)=g(x^)+g\u0026rsquo;(\\alpha)(x^-x_k)+\\frac{g\u0026rsquo;\u0026rsquo;(\\alpha)}{2}(x_k-x^*)^2+\u0026hellip;$\n因为我们求解的是x=g(x)，所以$e_k=x^-x_k=g(x^)-g(x_k)=g\u0026rsquo;(\\alpha)(x^-x_k)+\\frac{g\u0026rsquo;\u0026rsquo;(\\alpha)}{2}(x_k-x^)^2+\u0026hellip;$\n所以如果g(x)在不动点$x^*$附近的1阶导，2阶导，3阶导，\u0026hellip;，p-1阶导都是0，而p阶导不为0，不就说明它是p阶收敛的了？\n这不就结了。\n接下来的迭代方法都是基于不动点迭代得出的，所以他们的收敛速度也是用这个方法求解的，就不多嘴了。\n迭代法的加速 现在我们分析出了不动点迭代的收敛速度，那么问题就来了，有些时候这个收敛速度非常慢，有没有办法加快？\n可以的，我们还是用误差事后估计的方法加速，这个方法好像每一节都有的样子你应该也熟悉了吧。\n针对迭代公式$x_{k+1}=g(x_k)$，它与准确值的误差$x^-x_{k+1}=g(x^)-g(x_k)=g\u0026rsquo;(\\alpha)(x^*-x_k)$\n又是拉格朗日中值定理，how old are U？（怎么老是你？）\n我们还是认为g(x)的导数值变化不大，是一个常数L，则我们估计出了$x_{k+1}$的误差，从而可以得到更好的近似值也就是把$x^*$解出来，得到\n$x^*\\approx \\frac{1}{1-L}x_{k+1}-\\frac{L}{1-L}x_k$\n这是一个更好的近似值，接下来再用这个更好地近似值进行迭代这就实现了加速。\n埃特金算法 但是上面的加速方法还可以优化一下，其最大的问题就是这个L取啥。\n其实这个问题也很简单，我们直接不想了啊哈哈。\n直接解决掉问题本身，解决掉提出问题的人。\n额我的意思是，我们把L消了。\n你再迭代一次得到$x_{k+1}\u0026rsquo;=g(x_{k+1})$，然后再用拉格朗日中值定理得到\n$x^-x_{k+1}\u0026rsquo;\\approx L(x^-x_{k+1})$\n和前面第一次迭代得到的$x^-x_{k+1}=L(x^-x_k)$相除就消掉L了，这样就不用考虑了。\n然后我们把$x^$解出来，得到$x^=x_{k+1}\u0026rsquo;-\\frac{(x_{k+1}\u0026rsquo;-x_{k+1})^2}{x_{k+1}\u0026rsquo;-2x_{k+1}+x_{k}}$\n这又是更好的近似值，然后把这个近似值代入原来的迭代公式进行迭代，这也实现了加速。这就是埃特金算法。\n牛顿迭代法 我们说了这么多其实都是基于已经将这个方程转化为x=g(x)，然后用迭代公式$x_{k+1}=g(x_k)$求解。\n但是我们不知道如何把方程转化为x=g(x)，牛顿迭代法就是解决了这个问题。\n思路其实也非常简单，我们知道微分有dy=f\u0026rsquo;(x)dx，于是$f(x)-f(x_k) \\approx f\u0026rsquo;(x_k)(x-x_k)$。\n从而$f(x)=f(x_k)+f\u0026rsquo;(x_k)(x-x_k)=0$\n那么$x=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$，完成啦！\n我们把f(x)=0转化为了x=g(x)的形式了，从而再使用不动点迭代得到f(X)根的迭代公式：\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这就是牛顿迭代法。\n用前面的收敛速度的计算方法可以得到在f(x)=0只有单根的情况下，在单根附近牛顿迭代法是平方收敛的。\n牛顿下山法 注意，我说的是在f(x)=0只有单根的情况下，在单根附近牛顿迭代法是平方收敛的。\n很多时候函数有多根结论就未必是这样的。\n更有甚者，你的初值点离根太远，牛顿迭代法可能会发散。\n所以就有了牛顿下山法，为我们选择一个合适的初值点。\n牛顿下山法是下山法+牛顿法。所谓下山法，就是在不动点迭代的基础上要求每次迭代函数值的绝对值都要下降，也就是要求$|f(x_{n+1})|\\le|f(x_k)|$，显然这样的话每次迭代函数值都更接近0，也就有很大的概率是更接近方程的根的。\n但是事情往往不是那么美妙，因为咱们暂时还没有科学的方法找到下一个迭代的点。\n这时可以把牛顿法引入进来，我们先用牛顿法进行一次迭代得到\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n然后把这个$x_{k+1}$和$x_k$加权平均作为新的$x_{k+1}'$\n也就是$x_{k+1}\u0026rsquo;=\\lambda x_{k+1} + (1-\\lambda)x_k=x_k-\\lambda\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这里$0\u0026lt;\\lambda \\le1$被称为下山因子，我们就是每次迭代找这么一个合适的下山因子。\n而下山因子怎么找呢？二分呗。\n诶等等二分法？\n二分法不也可以求方程的根？\n所以很多时候我们也会用二分法先得到一个精确解的范围，然后把初值定在里面，然后再用牛顿法或者牛顿下山法。\n弦截法 到这里看起来已经非常完美了，至少我是这么认为的。\n但是实际上，有极少部分函数的导数是很难求解的，所以我们要用差商估计导数，这就是弦截法了。\n用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_0)}{x_k-x_0}$代入牛顿迭代法，就是弦截法了。\n如果用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$代入牛顿迭代法，就是快速弦截法了。\n线性方程组迭代的收敛性 前面说的都是非线性方程，那线性方程呢？一元的情况确实不用费心了，我口算都给你解了。\n但是现实里的线性方程组往往阶数非常高，所以也需要一个高效的求解方法。我们还是先介绍迭代法。方法其实和前面是类似的所以一并讲解。\n线性方程组AX=b如果我们可以将其化为X=BX+f，那么用前面所说的不动点迭代法就有迭代公式\n$X_{k+1}=BX_k+f$\n这是我们线性方程组迭代法的基石。\n它的误差：\n$e_{k+1}=|x^-x_{k+1}|=|BX^+f-(BX_{k}+f)|=B|X^*-X_k|=Be_k$\n从而，$e_k=B^ke_0$\n那么如果$B^k$能收敛于0的话该迭代法就收敛了，用线性代数或者高等代数的知识就能明白这等价于B的谱半径（最大特征值）小于1。\n现在我们有了对于所有矩阵的收敛性判别法，而对于一些特殊的矩阵不用这么麻烦。\n比如，对角占优方程组他的雅可比迭代和高斯-赛德尔迭代都是收敛的。\n这两种迭代方法我们等下讲，但因为这个话题在这了嘛所以我就先说了。\n证明的话因为没说迭代方法，所以也讲不了，其实你也可以等下自己试试看能不能证出来。\n我只在这里说一下什么是对角占优方程组。\n它指的是系数矩阵是对角占优矩阵的方程组。\nOK，说了和没说一样。\n所谓对角占优矩阵说的是，主对角线上的元素的绝对值＞同行其他元素的绝对值之和的矩阵。\n这就明白了吧。\n而且这个名字现在看着是不是很直观？主对角线上的元素绝对值比你一整行其他元素绝对值的和都大，那是在这一行绝对的制霸啊。\n这样的矩阵其实一定是可逆阵，这个你也可以证明看看。\n雅可比迭代 现在的问题还是和前面一样的，不动点迭代法说的轻巧，但是你怎么把AX=b转化成X=BX+f呢？\n其中的一种方法就是雅可比迭代法了。\n对方程组AX=b，我们将A分解为对角阵D，下三角矩阵L，上三角矩阵U使得\nA=D-L-U。\n（值得一提的是，这个分解是相当容易的，D就是A的对角元，L取A的下三角去掉主对角线，U取A的上三角去掉主对角线即可）\n那么AX=b就是\n(D-L-U)X=b\n然后移项得\nDX=(L+U)X+b\n从而$X=D^{-1}(L+U)X+D^{-1}b$\n完事了，已经变成X=BX+f的形式了，所以就有迭代公式\n$X_{k+1}=D^{-1}(L+U)X_k+D^{-1}b$\n这就是雅可比迭代法了。\n但是这个方法可以稍微变一下，我们移项的时候不一定要把L和U全部移走，这就是高斯-赛德尔迭代法了。\n高斯-赛德尔迭代法 还是安装雅可比迭代的步骤我们得到，(D-L-U)X=b移项但是只移U得到\n(D-L)X=UX+b\n然后得到$X=(D-L)^{-1}UX+(D-L)^{-1}b$\n于是就有迭代公式$X_{k+1}=(D-L)^{-1}UX_k+(D-L)^{-1}b$\n但是我们一般不会这么使用，而是再等式两边再乘以D-L得到\n$(D-L)X_{k+1}=UX_k+b$\n从而$DX_{k+1}=LX_{k+1}+UX_k+b$\n所以$X_{k+1}=D^{-1}LX_{k+1}+D^{-1}UX_k+D^{-1}B$\n这才是我们一般最爱用的高斯-赛德尔迭代公式。\n其实到这里，你应该也能自己造出第三个迭代公式了吧。高斯-赛德尔迭代只移了U，那我只移动L行不行？当然也行啊，反正思路就是这么个思路，怎么折腾随便你。\n","date":"2024-12-21T20:10:44+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%954-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/","title":"数值计算方法(4) 迭代法求解方程"},{"content":"上一期讲了数值积分方法，这一次自然是要讲数值微分方法的，不然太不完善了。\n更何况数值微分方法其实是基于数值积分方法得到的。\n我们先从比较简单的估计导数值来开篇。\n差商方法 估计函数的导数值意义其实没有前面积分那么大，因为基本初等函数都能很容易地求导，有准确值了近似值的意义就没有那么大了。\n不过还是来试试吧。\n近似导数的最简单的方法就是用导数的定义。\n你看一阶差商$\\frac{f(a+h)-f(a)}{h}$，当h趋于0时根据这就是导数的定义啊，所以反过来我们可以让h非常小，这样就是导数的近似值了。\n这种差商在这里有一个名字叫向前差商。\n有向前自然就有向后$\\frac{f(a)-f(a-h)}{h}$。\n其实还有中心差商$\\frac{f(a+h)-f(a-h)}{2h}$。\n中心差商还有一个名字叫中点方法，其实这玩意也能看做是向前差商和向后差商的平均值。\n如果是我们手算的话，其实这样就很好了。\n我们手算的话h越小误差越小，但这么麻烦的东西自然是不可能手算的。\n但是一旦交给计算机算啊，h如果太小，计算机计算的误差就会增加（计算机进行浮点数运算是不准确的，这是由浮点数的存储方式决定的，计算机的浮点数大多都按照IEEE的规范设计的，是存在舍入误差的）。\n总之，现在这个h如果太大，从数学上看的误差会变大（我们称为截断误差），h如果太小计算机计算的时候舍入误差会太大。\n那么又来了，步长h应该怎么选呢？\n这情况和龙贝格算法一模一样啊。\n还是用理查德森外推法。\n我们可以导出一个一模一样的加速公式。\n$G_n(h)=\\frac{4^nG_{n-1}(\\frac{h}{2})-G_{n-1}(h)}{4^n-1}$\n然后画一模一样的表就可以了。\n这里确实没太大区别。\n我们先用泰勒公式计算余项：\n$G(h)-f\u0026rsquo;(a)=\\alpha_1 h^2+\\alpha_2h^4+\u0026hellip;+\\alpha_nh^{2n}+\u0026hellip;$\n把步长折半\n$T(\\frac{h}{2})-f\u0026rsquo;(a)=\\alpha_1 \\frac{h^2}{4}+\\alpha_2\\frac{h^4}{16}+\u0026hellip;+\\alpha_n\\frac{h^{2n}}{4^n}+\u0026hellip;$\n然后消掉h²项得到更好的$f\u0026rsquo;(a)$的误差估计，每次都这样计算，整理出来的递推公式就是上面的那个式子，由于余项的形式和龙贝格算法是一样的所以最终的递推式也是一样的。（详情还是回到上一节看一下详细的理查德森外推法吧）\n插值型求导公式 前面我们说插值是对函数的拟合，所以这里自然可以用插值多项式替代函数f(x)，用插值多项式的导数作为f(x)导数的近似，但是这玩意儿没那么靠谱，因为插值多项式在函数值上比较接近，但是他们的导数值可能差得很远，所以这条路子没那么靠谱，也就没那么多理论了。你就当是半破产了吧。而且操作起来也不难，就是无脑用插值多项式替代f(x)而已，所以不多说了。\n接下来才是重点，唠唠怎么求解微分方程。\n微分方程数值解 微分方程数值解的求法主要是利用了数值求积方法，在此我们以标准的微分方程初值问题为例介绍几个方法。\n在《常微分方程》这门课程中（注意是一门课，不是高等数学的那个章节），你应该听过皮卡逐步逼近定理。\n它这里的微分方程近似解是一个多项式，而我们这里说的微分方程数值解不是这样的东西。\n针对这样的初值问题，你给我一个步长h，我求出微分方程的解g(x)在x+h，x+2h,\u0026hellip;等处的函数值，我们这里说的数值解是这样的东西。\n当然，为了保证初值问题有且只有唯一的解，我们仍然要求f(x,y)关于y满足利普希茨条件。（没听过不用管，这是因为你没上过《常微分方程》这门课，总之就是要保证解存在且唯一而已，这个条件后文不会使用）\n好接下来开始推导。\n对微分方程\n$\\frac{dy}{dx}=f(x,y)$\n我们两边同时积分得到\n$\\int_{x_n}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n也就是\n$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n从而\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n而如果我们可以用数值方法求出这个积分，不就解出了这个微分方程？\n例如，我们直接用左矩形公式求积分，得到\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_n,y_n)$\n这就是欧拉格式。(注意，数值微分里我们称为格式而不是公式，这里没有打错字)\n你可能会发现我这里给的欧拉格式和网上一般的不一样，其实你只要设$h=x_{n+1}-x_n$（当我设了h就默认等步长了）就能得到一般的欧拉格式了。\n$y_{n+1}=y_n+hf(x_n,y_n)$\n同样地，我们可以用右矩形公式得到\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_{n+1},y_{n+1})$\n类似地，我们设$h=x_{n+1}-x_n$就有，\n$y_{n+1}=y_n+hf(x_{n+1},y_{n+1})$\n这就是隐式欧拉格式了。\n那如果我用中矩形公式，还能得到两步欧拉格式：\n对微分方程\n$\\frac{dy}{dx}=f(x,y)$\n我们两边同时积分得到\n$\\int_{x_n-1}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n-1}^{x_{n+1}}f(x,y)dx$\n注意，这次是从$x_{n-1}$积到$x_n$，并且我们要求步长为h，则$x_n$是积分区间中点。\n有$y_{n+1}-y_{n-1}=2hf(x_n,y_n)$\n从而，$y_{n+1}=y_{n-1}+2hf(x_n,y_n)$\n这就是两步欧拉格式。\n还可以用梯形公式来求积分得到梯形格式。\n$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+\\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]$\n注意力好的人应该已经发现了，梯形格式恰好是显式欧拉格式和隐式欧拉格式的算术平均。\n预报-矫正系统与改进欧拉 前面扯了这么久感觉非常平淡啊，就是套用一下求积公式，下面来点有意思的。\n你看梯形格式里是不是说需要$f(x_{n+1},y_{n+1})$？\n你有没有想过这玩意儿哪里来？\n是不是前面看得特爽但是这个最基本的东西没发现。\n$f(x_{n+1},y_{n+1})$明明是下一次的东西，你怎么能让我现在就给出来呢？\n其实是这样的，我们先用前面的一个显式格式预报一个$f(x_{n+1},y_{n+1})$出来，然后再用隐式格式得到一个矫正后的$y_{n+1}$，这样精度会更高。\n例如，使用显式欧拉格式预报$y_{n+1}=y_n+hf(x_n,y_n )$\n然后再把这个预报的$y_{n+1}$代入隐式欧拉，这就是改进欧拉格式了。\n这样的一套系统我们称为预报-矫正系统。\n你其实是可以任意组合的。\n但是这样的方法仍然没有脱离求积公式的桎梏，而下面的方法就是重新开了一个方向了。\n龙格-库塔方法 这个龙格-库塔方法从另一个角度看问题，他是这么说的。\n函数f的一阶差商$\\frac{f(x_{n+1})-f(x_{n})}{x_{n+1}-x_n}$，因为我们微分方程数值解指的是你给我一个步长h，我求出微分方程的解g(x)在x+h，x+2h,\u0026hellip;等处的函数值，所以分母就是步长h，分子则可以运用拉格朗日中值定理，从而$\\frac{f(x_{n+1})-f(x_{n})}{h}=f\u0026rsquo;(\\alpha)$\n于是，$f(x_{n+1})=f(x_n)+hf\u0026rsquo;(\\alpha)$\n你们呐，折腾这么多其实就是在估计$f\u0026rsquo;(\\alpha)$！\n这个$f\u0026rsquo;(\\alpha)$被称为函数f在区间内的平均斜率。\n你可以试试看，显式欧拉就是用函数在左端点的斜率值估计平均斜率，改进欧拉是用两个端点处的斜率的平均值估计斜率。\n这些估计方式对平均斜率的估计显然精度没有那么高，所以这些方法在计算数值解时的精度自然也不高。\n那我如果多用一些点来估计函数的平均斜率，精度不就提高了？\n龙格-库塔方法就是这样的方法。\n我们在$x_n,x_{n+1}$之间取p个不同点的斜率，计算他们的加权平均，把这个当做平均斜率的估计。\n那取哪些点呢？这个就是龙格-库塔方法精度高的精髓了。\n我们以二阶龙格-库塔方法为例进行推导。\n在这里，龙格-库塔方法的阶数指的就是用的点的数量。\n在这里我们设要取的点的斜率为$k_1,k_2$，要计算他们的加权平均，所以还需要假设权。\n所以我们再设平均斜率$k^*=(1-\\lambda)k_1+\\lambda k_2$\n我们先取其中一个端点为左端点$x_n$试试水，那么就有$k_1=f(x_n,y_n)$了。\n接下来我们要找第二个点$x_{n+p}=x_n+ph,p \\in(0,1]$然后计算他的斜率为$k_2$。\n那怎么找呢？似乎没有头绪了，其实我也没有。不过好在数学家想到了，可以继续用预报-矫正系统啊。\n我们先用显式欧拉预报一个$y_{n+p}=y_n+phk_1$，那么$k_2=f(x_{n+p},y_{n+p})=f(x_{n+p},y_n+phk_1)$了。\n呕吼，搞了一圈合着还是俩未知量，一个没消啊。\n这个方法里真正消元的方法是泰勒展开+比较系数。\n我们先对$k_2=f(x_{n+p},y_n+phk_1)$进行泰勒展开，由于$x_{n+p}=x_n+ph$，所以$k_2$实际上是一个二元函数$f(x,y)$的泰勒展开。\n这个二元函数的泰勒展开，好像只有数学分析介绍了，如果你只学过高等数学的话你应该不知道，所以我这边给一下结论。\n如果函数f在点$P(x_0,y_0)$的邻域U(P)内有n阶连续的偏导数，则对U(P)内的任意一点$(x_0+h,y_0+k)$，存在$\\theta \\in (0,1)$，使得\n$f(x_0+h,y_0+k)=\\sum_{p=0}^n\\frac{1}{p!}(h\\frac{\\partial}{\\partial x}+k\\frac{\\partial}{\\partial y})^pf(x_0,y_0)+o(\\rho),\\rho^n=\\sqrt{h^2+k^2}$\n这是二元函数的n阶泰勒公式。\n现在我们来展开一下但是这里只需要展开两项，\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+(ph\\frac{\\partial}{\\partial x}+phk_1\\frac{\\partial}{\\partial y})f(x_n,y_n)+o(\\rho ^2)$\n现在只是单纯的代入了公式，我们来进行计算。\n先关注偏导数部分。\n$(ph\\frac{\\partial}{\\partial x}+phk_1\\frac{\\partial}{\\partial y})f(x_n,y_n)$\n这里前面一个括号写的是偏微分算子，其实我们直接把函数$f(x,y)$乘进去就可以了。\n也就得到$ph\\frac{\\partial}{\\partial x}f(x_n,y_n)+phk_1\\frac{\\partial}{\\partial y}f(x_n,y_n)$\n由于没有给出f(x,y)具体的表达式，所以这里就不能计算f(x,y)的偏导了。\n把这个结果代入就是最后的展开式了。\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phk_1\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n等等，$k_1$是啥？\n回到前面看看，$k_1=f(x_n,y_n)$\n而我们解的微分方程是啥来着？$\\frac{dy}{dx}=f(x,y)$\n$x_n,y_n$既然是微分方程解上的点自然也就满足这个微分方程了喽，所以$k_1=f(x_n,y_n)=\\frac{dy}{dx}|_{x=x_n}$\n这么写有点难看，我们把式子弄得漂亮一点。微分方程最后的解是一个关于x的函数，我们设为$y(x)$，那么他的导数就是$y\u0026rsquo;(x)$，他在$x_n$处的导数自然就是$y\u0026rsquo;(x_n)$了。\n所以$k_1=y\u0026rsquo;(x_n)$\n也因此\n$k_2=f(x_n+ph,y_n+phk_1)=f(x_n,y_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n再等等，刚刚是不是还说了$k_1=f(x_n,y_n)=y\u0026rsquo;(x_n)$来着？\n这下不是又能代入了？\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+[ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]+o(\\rho ^2)$\n这时候有些注意力比较集中的人就发现了。\nk2的式子里面啊，中括号的内容是$ph\\frac{\\partial f(x_n,y_n)}{\\partial x}+phy\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}$\n我们把ph提出来，就是$ph[\\frac{\\partial f(x_n,y_n)}{\\partial x}+y\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}]$\n你看中括号里面的东西。\n额，也许你看不出来。我给个提示。\n观察二元函数f(x,y)，这里我们已经假设了y是关于x的函数y(x)，所以这时候我们可以求f(x,y)关于x的全导数，利用复合函数求导法则就可以了。\n或者画个路径图。\nf(x,y)首先是关于x,y的二元函数，y又是关于x的一元函数，\n所以f(x,y)关于x的全导数$\\frac{df(x,y)}{dx}=\\frac{\\partial f}{\\partial x}+\\frac{\\partial f}{\\partial y}\\frac{dy}{dx}$\n我把式子写全\n$\\frac{df(x,y)}{dx}=\\frac{\\partial f(x,y)}{\\partial x}+\\frac{\\partial f(x,y)}{\\partial y}\\frac{dy(x)}{dx}$\n我取f(x,y)在点$(x_n,y_n)$的全导数，\n这特么，不就是括号里的$\\frac{\\partial f(x_n,y_n)}{\\partial x}+y\u0026rsquo;(x_n)\\frac{\\partial f(x_n,y_n)}{\\partial y}$吗？\n所以又能化简了。\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+ph\\frac{df(x_n,y_n)}{dx}+o(\\rho ^2)$\n我再问一遍，我们要求解的微分方程是什么？\n$\\frac{dy}{dx}=f(x,y)$\n所以，$f(x_n,y_n)=\\frac{dy(x_n)}{dx}$\n那$f(x_n,y_n)$再对x求一阶导是啥？\n不就是$y(x)$在$x_n$处的二阶导$y\u0026rsquo;\u0026rsquo;(x_n)$吗？\n所以又能化简了。\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+phy\u0026rsquo;\u0026rsquo;(x_n)+o(\\rho ^2)$\n最后还有个小尾巴，$o(\\rho^2)$是啥？\n回去看看泰勒公式，$\\rho^2=(ph)^2+(phk_1)^2$，它和$h^2$是同阶无穷小，所以$o(\\rho^2)=o(h^2)$\n所以到了最后，\n$k_2=f(x_n+ph,y_n+phk_1)=y\u0026rsquo;(x_n)+phy\u0026rsquo;\u0026rsquo;(x_n)+o(h^2)$\n$k_1$我们说了是$f(x_n,y_n)=f\u0026rsquo;(x_n)$\n代入我们的迭代格式$y_{n+1}=y_n+h[(1-\\lambda)k_1+\\lambda k_2]$\n得到\n$y_{n+1}=y_n+hy\u0026rsquo;(x_n)+\\lambda ph^2y\u0026rsquo;\u0026rsquo;(x_n)+o(h^3)$\n而$y_{n+1}$实际上是y(x)在$x_{n+1}$的取值$y(x_{n+1})=y(x_n+h)$\n这时候我们还可以把一元函数$y(x)$泰勒展开，展开三项得到\n$y_{n+1}=y(x_n+h)=y(x_n)+hy\u0026rsquo;(x_n)+\\frac{h^2}{2}y\u0026rsquo;\u0026rsquo;(x_n)+o(h^3)$\n由于泰勒展开是唯一的，所以我们前后得到的两个泰勒展开应该是一样的才对，也就是$\\lambda p=\\frac{1}{2}$\n总之，最终结论是$2\\lambda p=1$，并且二阶龙格-库塔方法的阶段误差是$h^3$这个数量级的。\n也就是说，只要满足$2\\lambda p=1$的迭代格式都是二阶龙格-库塔格式，误差都是$h^3$这个数量级的。\n我们取$p=1,\\lambda = \\frac{1}{2}$得到的迭代格式就是改进欧拉格式，取$p=\\frac{1}{2},\\lambda=1$得到的迭代格式我们称为变形的欧拉格式，或者也称为中点格式。\n$y_{n+1}=y_n+hk_2$\n$k_1=f(x_n,y_n)$\n$k2=f(x_{n+\\frac{1}{2}},y_n+\\frac{h}{2}k_1)$\n如果我们令$p=\\frac{2}{3},\\lambda=\\frac{3}{4}$，得到的就是休恩公式。\n如果进一步增加点就可以得到三阶、四阶乃至更高阶的龙格-库塔迭代格式不过这个迭代式子啊比较难看了而且也没有什么规律，想了解的话可以自己上网搜寻。他的推导思路倒是和二阶的没什么区别。\n龙格-库塔方法的问题呢已经很小了。不过我们还是可以吹毛求疵出来，在计算$y_{n+1}$的时候我们已经算出了$y_1,y_2,\u0026hellip;,y_n$而龙格-库塔方法没有充分地利用这些已经算出来的数据。\n亚当姆斯方法 如果要利用这些信息你就得到了亚当姆斯方法。\n亚当姆斯方法可以当做龙格-库塔方法的推广继续用泰勒展开得到，但是你懂的，这非常麻烦。\n我们换一个简单的方法——利用插值多项式得到。\n针对微分方程$\\frac{dy}{dx}=f(x,y)$，我们两边积分（熟悉的开局）\n但是这次积分区间不一样，看你想用几个历史信息点了，比如说我想用r+1个历史信息，那就从$x_{n-r+1}$积到$x_{n+1}$，那么左边是函数值的差，右边是一个积分。\n这个积分呢，我用一个r次插值多项式来近似。\n那插值节点选哪r个呢？答案是任意。如果我选择包含$x_{n+1}$的前r+1个插值节点得到的就是r+1阶隐式亚当姆斯格式，我选择$x_n$开始的r+1个插值节点得到的就是r+1阶显式亚当姆斯格式。\n例如，我想得到2阶隐式亚当姆斯方法，我就从$x_n$积到$x_{n+1}$\n得到$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$\n再用过$x_{n+1},x_n$的线性插值多项式$\\frac{x-x_{n+1}}{x_n-x_{n+1}}f(x_n,y_n)+\\frac{x-x_n}{x_{n+1}-x_{n}}f(x_{n+1},y_{n+1})$近似替代f(x,y)然后算出积分就可以了。\n结果是$y_{n+1}=y_n+\\frac{h}{2}(f_n+f_{n+1})$\n那如果我取插值节点是$x_n,x_{n-1}$就能得到二阶显式亚当姆斯格式，结果是$y_{n+1}=y_n+\\frac{h}{2}(3f_n-f_{n-1})$\n亚当姆斯预报-矫正系统 很经典的场景出现了。\n我们同时有显式和隐式迭代格式，而隐式格式里需要提前知道$y_{n+1}$，那$y_{n+1}$哪里来呢？\n可以由同阶显式迭代格式预报得来。\n这就是亚当姆斯预报-矫正系统，没啥花头。\n前面说了这么多都是关于迭代格式，也就是算法的讨论，那这部分有没有理论呢？\n迭代格式的收敛性和数值稳定性 其实有的。\n一个最严重的问题是收敛性问题，也就是我们叭了叭叭bb了老半天，你迭代的$y_n$是否真的趋于准确值。\n这些方法我都拿出来讲了你应该明白，肯定是收敛的。\n这玩意儿的证明又涉及到了利普希茨条件，又要搞泰勒展开的，比较麻烦，我就给个文章吧。\n知乎的@123456写的关于一阶显式和隐式方法收敛性的理论分析，地址https://zhuanlan.zhihu.com/p/515389776，当然你去网上找其他资料也可以。\n我这里只给个结论。\n显式欧拉格式的全局截断误差$|y(x_n)-y_n|\\le e^{L(b-a)}|y(x_0)-y_0|+\\frac{Mh}{2L}(e^{L(b-a)-1})$，其中$M=\\sup|y\u0026rsquo;\u0026rsquo;(x)|$\n这个全局截断误差有两项，我们说后一项是局部截断误差的累计，而在前一项里，$|y(x_0)-y_0|$是初值条件的误差称为条件误差，e^{L(b-a)}$是条件误差放大倍数，他只于初值问题本身的利普希茨系数L有关。当这个L很大的时候，注意，哪怕是微小的条件误差也会导致显式欧拉格式有很大的全局截断误差，这种情况我们称原问题数值稳定性差。\n当然，这只是定性的说法，如果要定量的话是这样说的。\n我们给一个扰动$\\delta$，如果迭代格式产生的各个节点的误差均在$\\delta$以内，我们就说这个迭代方法是稳定的。\n但是这个稳定性问题是非常复杂的，这个问题在其他学科还有一个名字叫混沌。\n2021年的诺贝尔物理学奖就颁给了混沌相关的研究，咱们就不蹚这深水了。\n我可以告诉你的是，显式欧拉格式是条件稳定的，只有当步长h比较小的时候才稳定。\n关于方程组和边值问题 我们扯了那么多，都是在说微分方程的初值问题。那方程组呢？\n方程组的话其实迭代格式不用改变的，方程组的初值问题不就是$\\frac{d\\vec{y} }{dx}=f(x,\\vec{y})$嘛，你看写成向量不就熟悉了？\n迭代格式不用发生任何变化。\n总之，这样就能求解常微分方程组了。\n而如果是高阶常微分方程，我们知道可以通过换元的方法转化成方程组的求解所以也解决了。\n而微分方程的边值问题的数值解，上面的方法都用不了，而且求解起来比较复杂。\n甚至哪怕是上了《常微分方程》课程的人也未必知道微分方程的边值问题是啥吧。\n所以我就只给个名词了，可以用差商法、有限元法、打靶法等方法求解。\n","date":"2024-12-21T15:45:47+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%953-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值计算方法(3) 数值微分方法"},{"content":"上一期讲了插值方法，这一次自然是要运用一下插值方法了。所以这一期的主题是用插值方法计算定积分。\n机械求积方法 下面我们来介绍一下怎么用插值法来得到数值方法计算函数积分。\n对于大部分函数，我们其实都是很难求其积分的，甚至很多函数例如$e^{x^2}$这样的函数压根就没有初等原函数。所以我们需要寻找数值方法来计算他们的积分。\n对于大多数函数，我们不仅很难求积分，也许微分也很难求，所以我们希望的数值方法一定是不能包含这俩的。\n为了简化问题，我们最终的求积公式就用函数值的线性组合试试看了。\n这种最简单的求积公式就是机械求积。\n也就是找到某些点的函数值，用这些点的函数值的某个线性组合来近似积分值。\n即机械求积公式认为$\\int_a^b f(x)dx \\approx \\sum_{k=0}^n A_k y_k$\n所以关键点就是点的选取和组合系数$A_k$的选择了。\n一种可能的思路就是用上一期提的插值多项式来近似替代这个函数。而且我们是已知了差值余项的，余项的积分就是我们数值积分方法的误差。\n而这些都是多项式啊，都很好计算的。\n这种求积分的数值方法得到的积分公式我们都叫做差值型的求积公式。\n而在插值方法里，点的选择是任意的，那我们就暂且也让大家任意选择。\n这样只需要知道组合系数$A_k$就知道怎么求积了。\n而对于插值型求积公式，我们很容易就能得到$A_k$。\n插值型求积公式就是用f(x)的插值多项式近似f(x)，从而有\n$\\int_a^bf(x)dx \\approx \\int_a^bp_n(x)dx$\n再把拉格朗日插值公式代入得\n$\\int_a^bf(x)dx \\approx \\int_a^b \\sum_{k=1}^n y_k l_k(x)dx$\n$=\\sum_{k=1}^n y_k\\int_a^bl_k(x)dx$\n而我们的机械求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$，从而\n$A_k=\\int_a^b l_k(x)dx$\n代数精度 你也许会觉得这个办法非常粗糙，确实！我们可以来分析一下他的精度。余项么，自然就是拉格朗日插值余项的积分了，这个没啥好说的。\n我们在机械求积里其实最关注代数精度了。\n我们拿多项式函数来表彰一个求积公式的精度。\n取多项式$p(x)=a_nx^n+a_{n-1}x^{n-1}+\u0026hellip;+a_0$\n由于多项式函数总是很容易求出积分的准确值的。\n我们就来看看你的求积公式是从几次多项式开始才变得不准确的。这个次数就是求积公式的代数精度。\n事实上，我们前面那种求积方式的代数精度是很容易看出来的。\n你用n次多项式插值f(x)而我们代入验证的f(x)是m次多项式。\n如果n=m，那么你的插值多项式就是我们代入验证的m次多项式。\n如果n比m还大呢？求积公式的插值多项式会退化为m次多项式，所以积分自然也还是准确的。\n因此，n次插值多项式得到的求积公式至少具有n次代数精度。\n我这里是用的任意n次多项式来进行验证，不过你在外面看到的定义可能是说用$x^n$代入验证，事实上我们俩说的是等价的。\n其他人的说法是你代入$1,x,x^2,\u0026hellip;,x^n$，一直到$x^{n-1}$次方，你都发现求积公式是准确的，但n次方开始不准确了，这时说求积公式有n-1次代数精度。\n显然，他们的定义是我说的定义的特殊情况，所以满足我的定义的，自然满足他们的定义。\n而满足他们定义的求积公式，对$x^{n-1}$都准确。\n则我取任意的n-1次多项式，$p(x)=a_{n-1}x^{n-1}+\u0026hellip;+a_0$\n求积分$\\int_a^bp(x)dx=a_{n-1}\\int_a^bx^{n-1}dx+a_{n-2}\\int_a^bx^{n-2}dx+\u0026hellip;+a_0\\int_a^b1dx$\n$1,x,x^2,\u0026hellip;,x^{n-1}$的积分准确，那么p(x)的积分也就是准确的了。\n所以我们俩的代数精度的定义是等价的，只不过我这个看起来要强一些而已。\n牛顿-科特斯公式 前面我们给的机械求积公式略显粗糙，但也能取得至少n次代数精度，接下来我们会对求积公式进行加强，对它有更高的要求。\n组合系数$A_k$是死的了，所以下面的加强都是从插值点入手。\n例如牛顿-科特斯公式就是进一步要求，插值点的间距相等（步长为h），然后得到一个特殊的结论。\n我们竟然将区间长度提出来了，\n$\\int_a^b f(x)dx=(b-a)\\sum_{k=0}^n C_k f(x_k)$\n并且，$C_k$竟然还是常数。\n我们称$C_k$为科特斯系数，可以直接查科特斯系数表得到，与具体的函数f(x)无关，只和你插值多项式的次数n有关!\n这就是牛顿-科特斯公式。\n其中n=1得到的求积公式被称为梯形公式，n=2的是辛普森公式。\n一般我们也就只用到辛普森公式为止，这是因为前面我们说过插值多项式有龙格现象，也就是会过拟合。我们这里也是一样，你用的求积公式次数太高，插值多项式在区间端点附近疯狂震荡，而且这时候你稍微变一下计算用的数值最后的计算结果差距会非常大（这种情况我们称为数值稳定性差）。\n所以记住常用的求积公式，三个矩形公式，也就是\n左矩形公式：把f(x)直接当做常函数f(a)求矩形的面积$\\int_a^bf(x)dx=(b-a)f(a)$\n还有右矩形公式：$\\int_a^bf(x)dx=(b-a)f(b)$\n以及中矩形公式：$\\int_a^bf(x)dx=(b-a)f(\\frac{a+b}{2})$\n梯形公式，把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积,当然也是什么的n=1时的牛顿科特斯公式$\\int_a^bf(x)dx=(b-a)\\frac{1f(b)+1f(a)}{1+1}$\n既然梯形公式是把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积你其实大可不必用上面我写的复杂的式子，直接上底+下底再乘高除2就完事了。\n我也这样是为了让你记住辛普森公式。\n辛普森公式涉及三个点，然后是等距的，这里假定求a,c的积分，b就是a和c的中点，从而\n$\\int_a^cf(x)dx=(c-a)\\frac{1f(a)+4f(b)+1*f(c)}{1+4+1}$\n重点在系数1,4,1，记住这个就可以了。\n这也是上面的牛顿-科特斯系数表不把$\\frac{4}{6}$化简的原因。\n这里也点出了牛顿-科特斯系数表的性质即每一行的和为1。\n好了，总之这样你应该就记住了这几个公式了。\n但是问题来了，这玩意儿啊都是用的低阶插值，所以代数精度不也就低了。\n左右矩形公式只用了1个点，所以是0阶插值的结果，有0阶代数精度。\n梯形公式两个点，是线性插值的结果，只有1阶代数精度。\n辛普森公式3个点，是抛物插值的结果，2阶代数精度，这不就完全垮了啊！\n你应该能想到应该怎么做，分段呗，继续分段。\n复化方法 这种分段的方法在前面分段低次插值和样条插值里你已经见过了，只不过在这里叫复化方法。\n对应的求积公式叫复化求积公式。\n我们将区间[a,b]n等分，然后用低阶求积公式求每一段的积分值，然后累加就是整个区间的积分值了，复化方法就是这么简单。\n但是我一写公式你又头晕了。\n记住上面那一句话的本质即可，公式你对照着本质看就能看懂了。\n我们将[a,b]按步长h等分成n份，分点就是$x_k=a+kh,k=0,1,2,\u0026hellip;,n$，没毛病吧。区间有n个，所以要n+1个分点，这里下标从0开始，所以k最多取n。\n然后求出这n段的积分$I_k$，注意，分点是0到n，有n+1个分点，区间有n个，如果下标还是从0开始那么k最多到n-1。\n然后将这n个积分求和就是$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}I_k$。\n到这里是最一般的复化求积公式，没错哈。\n然后我们再用低阶求积公式求具体的$I_k$。\n例如，用梯形公式求区间$[x_k,x_{k+1}]$的积分。注意哈k从0开始，而$x_0=a$，而这边是$[a,a+h],[a+h,a+2h]$这样分区间的，所以区间是k到k+1。\n好，来用梯形公式得到$I_k=h*\\frac{f(x_k)+f(x_{k+1})}{2}$\n再试试用辛普森公式求解，$I_k=h*\\frac{f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})}{6}$\n这里$x_{k+\\frac{1}{2}}$指的是$x_k$和$x_{k+1}$的中点。\n接下来要把$I_k$代入复化求积公式了哈。\n这样就得到复化梯形公式$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}h*\\frac{f(x_k)+f(x_{k+1})}{2}$\n复化辛普森公式$\\int_a^b f(x)dx=\\sum_{k=0}^{n-1}h*\\frac{f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})}{6}$\n不过你在外面看到的式子可能不是这样的，我们来化简一下。\n首先把常数提出去。\n复化梯形公式$\\int_a^b f(x)dx=\\frac{h}{2}\\sum_{k=0}^{n-1}f(x_k)+f(x_{k+1})$\n复化辛普森公式$\\int_a^b f(x)dx=\\frac{h}{6}\\sum_{k=0}^{n-1}f(x_k)+4*f(x_{k+\\frac{1}{2}})+f(x_{k+1})$\n接下来，注意一下哈，$x_k,x_{k+1}$都是区间的分点，所以我在累加的时候除了两端的分点只加了一次，其他分点都加了两次，而$f(x_{k+\\frac{1}{2}})$是区间分点的中点也只加了一次。\n所以式子可以再化简一下这样就是常见的两个复化求积公式了。\n复化梯形公式$\\int_a^b f(x)dx=\\frac{h}{2}[f(a)+2\\sum_{k=1}^{n-1}f(x_k)+f(b)]$\n复化辛普森公式$\\int_a^b f(x)dx=\\frac{h}{6}[f(a)+2\\sum_{k=1}^{n-1}f(x_k)+\\sum_{k=0}^{n-1}4*f(x_{k+\\frac{1}{2}})+f(b)]$\n再来解析一下，f(a)和f(b)是区间的端点，只加了一次，所以系数是1，而$f(x_{k+\\frac{1}{2}})$是区间分点的中点也只加了一次，所以系数也不变。\n式子里的$2\\sum_{k=1}^{n-1}f(x_k)$是区间的内分点，都加了两次所以前面系数带了2。\n总之，复化方法就是这样。但是复化方法有一个不好的地方，就是他的步长h依然是我们随便选取的，我们能不能让他自己找到一个合适的步长h？\n梯形公式递推化 基于这样的想法就有了递推化梯形公式。\n原本我们将区间[a,b]进行n等分，有n+1个分点，可以得到近似公式$T_n$，如果$T_n$精度不够，我们就把步长折半，也就是把区间2n等分，得到$T_{2n}$。\n梯形公式递推化就是简化了$T_{2n}$的计算。\n我们是可以按复化梯形公式重新计算$T_{2n}$的，但是这样比较麻烦。\n梯形公式递推化注意到了我们把区间2n等分时其实新增的分点是原来分点的中点，而原来的n+1个分点可以继续利用。由此得到了一个$T_n$到$T_{2n}$的递推公式。\n$T_{2n}=\\frac{T_n}{2}+\\frac{b-a}{2n}\\sum_{k=1}^nf[a+(2k-1)\\frac{b-a}{2n}]$\n额呵呵，这公式一看就不是什么人话。\n我们说人话，简单点。\n来个例子就秒懂了。\n计算$\\int_0^1\\frac{\\sin x}{x}dx$\n首先用梯形公式不等分计算$T_1=\\frac{f(0)+f(1)}{2}=0.9207355$\n然后用递推公式计算$T_2=\\frac{T_1}{2}+\\frac{1}{2}f(\\frac{1}{2})$\n好，观察一下前面的式子，前面的$\\frac{T_1}{2}$在任何时候都是一样的，它永远是上一个值的一半。\n然后后面的项$\\frac{1}{2}f(\\frac{1}{2})$你先别管$\\frac{1}{2}$。[0,1]二等分增加了1个分点$\\frac{1}{2}$，所以后面是新增加分点$f(\\frac{1}{2})$的和。\n那么下一次呢，把$[0,\\frac{1}{2}],[\\frac{1}{2},1]$再二等分增加分点$\\frac{1}{4},\\frac{3}{4}$，所以之后就是$f(\\frac{1}{4})+f(\\frac{3}{4})$\n那这个系数$\\frac{1}{2}$是怎么递推的？\n这个系数是$\\frac{b-a}{2n}$，分子是积分区间长度b-a，分母是2,4,6,8,10以此类推。\n这下秒懂了吧。\n但是递推化梯形公式还是有问题的，就是梯形公式收敛速度太慢了。\n龙贝格算法 这就要龙贝格算法解决了。\n龙贝格算法其实也是一种事后估计方法。但我想说的是，龙贝格算法更是一种理查德森外推。\n这个理查德森外推是一种通用的数值方法，龙贝格算法是他的特例，之后你还会遇见的。\n他是这样的，如果你有一个数值公式$T(h)$，h是某个参数，不一定是步长，任何参数都可以。我们这个方法是一个非常通用的方法。\n你对$T(h)$进行泰勒展开得到误差估计\n$T(h)-I=\\alpha_1 h+\\alpha_2h^2+\u0026hellip;+\\alpha_nh^n+\u0026hellip;$\n接下来我想提高这个数值公式的精度为$h^2$应该怎么做？\n答案是把h折半，也就是把$\\frac{h}{2}$代入公式得到\n$T(\\frac{h}{2})-I=\\alpha_1 \\frac{h}{2}+\\alpha_2\\frac{h^2}{4}+\u0026hellip;+\\alpha_n\\frac{h^n}{2^n}+\u0026hellip;$\n然后我们把h的一次方消掉，也就二式乘以2减去1式得到\n$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}-I=-\\frac{1}{2}\\alpha_2 h^3-\u0026hellip;$\n也就是说，左边那个$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}$与精确值I的误差是$h^2$阶的，所以$\\frac{2T(\\frac{h}{2})-T(h)}{2-1}$是精度更高的近似值，我们记作$T_1(h)$\n然后如法炮制可以把精度依次提高到h的三次方、四次方、五次方\u0026hellip;\u0026hellip;\n而且不难推算出通用的递推公式\n$T_m(h)=\\frac{2^mT_{m-1}(\\frac{h}{2})-T_{m-1}(h))}{2^m-1}$\n它的误差是h的m+1次方阶的。\n龙贝格算法就是理查德森外推法在求积公式里的特例或者说运用。\n只不过在求积公式里$T(h)$的泰勒展开是\n$T(h)-I=\\alpha_1 h^2+\\alpha_2h^4+\u0026hellip;+\\alpha_nh^{2n}+\u0026hellip;$\n也就是没有奇数阶，所以我要升阶的话折半一次是\n$T(\\frac{h}{2})-I=\\alpha_1 \\frac{h^2}{4}+\\alpha_2\\frac{h^4}{16}+\u0026hellip;+\\alpha_n\\frac{h^{2n}}{4^n}+\u0026hellip;$\n那么每次都是下式乘以4减去上式，\n导致递推公式是\n$T_m(h)=\\frac{4^mT_{m-1}(\\frac{h}{2})-T_{m-1}(h))}{4^m-1}$\n并且误差阶每次加2而不是加1。\n当然，这是我的讲法，更常见的讲法是按误差的事后估计法来推导的，也就是下面这样：\n我们先来计算一下误差，有误差才能事后估计嘛。\n从简单的梯形公式开始。\n按照拉格朗日插值余项，梯形公式的误差$I-T_n=\\sum_{k=0}^{n-1}-\\frac{h^3f\u0026rsquo;\u0026rsquo;(\\alpha_k)}{12}$\n而这里为了消掉中值，我们认为h很小，从而$hf\u0026rsquo;\u0026rsquo;(\\alpha_k) \\approx f\u0026rsquo;(x_{k+1})-f\u0026rsquo;(x_k)$\n也因此梯形公式的误差$I-T_n=\\sum_{k=0}^{n-1}-\\frac{h^3f\u0026rsquo;\u0026rsquo;(\\alpha_k)}{12}\\approx \\frac{-h^2}{12} [f\u0026rsquo;(b)-f\u0026rsquo;(a)]$\n这个误差和$h^2$是一个数量级的。\n类似地，可以推出辛普森公式$S_n$的误差和$h^4$一个数量级，而在牛顿-科特斯公式里n=3的时候得到的三次插值公式对应的求积公式我们称为科特斯公式是$h^6$数量级的。（科特斯公式前面没让你用，但是这里确实需要了，你想记的话也可以回去记啦）\n基于此我们进行误差事后估计。\n对了，在这里$T_n,S_n,C_n$的角标n指的是复化公式里区间的段的数量。\n我们这里说要变步长其实就是变区间的段数嘛。\n复化梯形公式误差和$h^2$是一个数量级的，所以步长变为原来的一半也就是区间分段分为原来的2倍，则误差大概变成了原来的四分之一。\n所以$\\frac{I-T_{2n}}{I-T_n}\\approx\\frac{1}{4}$\n熟悉的式子。\n我们又可以得到更精确的$T_{2n}$的估计值$I=\\frac{4}{3}T_{2n}-\\frac{1}{3}T_n$了。\n不过这里我要把式子写成\n$S_n=\\frac{4^1}{4^1-1}T_{2n}-\\frac{1}{4^1-1}T_n$\n没错，熟悉的结果，对复化梯形公式进行事后估计得到了复化辛普森公式。\n接下来你应该都猜得到结果了。\n$C_n=\\frac{4^2}{4^2-1}S_{2n}-\\frac{1}{4^2-1}S_n$\n$R_n=\\frac{4^3}{4^3-1}C_{2n}-\\frac{1}{4^3-1}C_n$\n额，这里$R_n$是复化龙贝格公式啦。\n总之，现在按这样的方法进行加工，就可以逐步提高求积精度，这就是龙贝格算法。\n你应该也能想到我要掏出这样的图了。\n现在这样步长h是可以随着计算折半的，其实我也觉得到这里就很完美了。\n高斯求积公式 谁知道高斯求积公式出现了。\n高斯求积公式彻底解决了插值点的选取问题，用这个方法选取的一定是最优插值点，而且代数精度是最高的。\n选取适当的$x_0,x_1,\u0026hellip;,x_n$这n+1个点，高斯求积公式可以达到至少2n+1的代数精度。\n这里选择的这些插值点被称为高斯点。\n如果选取了n个高斯点得到的高斯公式称为n点高斯公式。（注意我前面说的是n+1个点有2n+1阶代数精度，那n个点就有2n-1阶代数精度）\n1点高斯公式就是中矩形公式。\n我们来试着求求看两点公式高斯。\n注意，在高斯公式里，我们只能求[-1,1]的积分。\n如果你想求解[a,b]的积分，可以先换元。\n做一个简单的变换，令$x=\\frac{b-a}{2}t+\\frac{a+b}{2}$，就可以把积分区间变成[-1,1]了。\n现在想求两点高斯公式就是要找组合系数$A_1,A_2$和合适的分点$x_1,x_2$使得\n$\\int_{-1}^1f(x)dx=A_1f(x_1)+A_2f(x_2)$\n并且两点高斯公式具有2*2-1阶代数精度，所以他对$1,x,x^2,x^3$都精确成立。\n这样你会得到一个四元三次方程组，根本求解不来啊亲。\n还好，有数学家已经“注意到”高斯点的求解了。\nn点高斯公式的n个高斯点，就是n次勒让德多项式的零点。\n所以真正实用的求积方法是，想用n点高斯公式先写出n次勒让德多项式，再求出其零点，然后零点就是求积点。现在已知了求积节点，不就回到了最开始的机械求积方法了？用那里的方法求出$A_k$就可以了。\n那么这些结论都是怎么来的？\n我们等下再说，因为下面我们要直接来一个加强版的。\n反正到高斯求积公式这里我们的结论就是高斯点是n次勒让德多项式的零点，有了高斯点就可以用机械求积的方法得出组合系数$A_k$了。\n带权高斯求积公式 所谓高斯求积公式的加强版就是增加了权函数的机制。\n这是因为现实里有些函数啊他可能长这样：\n$\\int_{a}^bxe^{x^2}dx$\n如果直接用高斯求积公式是可以求解的，但是效率不高。\n于是又提出了带权高斯求积公式。\n这里我们把x看做权函数$\\rho(x)$，$e^{x^2}$看做要求的积分$f(x)$，于是我们要求的就相当于是带权函数的积分$\\int_{a}^b\\rho (x)f(x)dx$了。\n我们前面说的高斯求积公式其实就是权函数为1，区间为[-1,1]的特殊情况，所以这确实是一个加强版的公式。\n那么这个加权的想法是怎么来的呢？\n其实还是从线性代数的角度想出来的。\n在[快乐数学]傅里叶变换和拉普拉斯变换，链接https://www.bilibili.com/opus/953797131335893047?spm_id_from=333.1387.0.0里我们提到，区间上的连续函数的全体构成线性空间，并且我们可以定义内积结构使之变为内积空间，在那里我们说：\n可以定义内积$\\int_a^bf(x)g(x)dx$为f(x)和g(X)的内积。\n但其实，这个内积条件是可以加强的，我们可以定义带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$，这样也能得到一个内积空间。\n基于此就可以想到给高斯求积公式也整个带权版。\n为啥呢？这是由高斯求积公式的性质决定的。事实上高斯求积公式和其对应的内积空间密切相关。\n我们设$x_i$是n点带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，那么可以定义一个n次多项式$\\omega_n=(x-x_1)(x-x_2)\u0026hellip;(x-x_n)$，这个多项式就是由带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的一个正交多项式。\n也就是说:\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n我们来证明一下。\n先假设$x_0,x_1,x_2,..,x_n$这n+1个点是带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，那么带权高斯公式$\\int_{-1}^1\\rho (x)f(x)dx=\\sum_{k=0}^nA_kf(x_k)$就应该有2n+1次代数精度。\n这是带权高斯公式能达到的最低代数精度嘛，没问题的。\n这也就意味着，这个带权高斯公式对任意次数不小于2n+1的多项式都严格成立，没有任何误差。\n那我就取$f(x)=P_m(x)$了，这里的$P_m(x)$就是定理里说的任意次数小于等于n的多项式。\n既然$P_m(x)$次数小于等于n，而$\\omega(x)$次数是n+1(这里有n+1个高斯点，所以次数是n+1而不是前面说的n)，那么$\\omega(x)P_m(x)$次数就小于等于2n+1，刚好在带权高斯公式严格成立的范围内。\n现在要证明的是$\\omega(x)$与之带权正交，所以就是要算一下内积呗。\n由于带权高斯公式严格成立没有误差所以$\\int_{a}^b\\rho (x)\\omega(x)P_m(x)dx=\\sum_{k=0}^nA_k\\omega(x_k)P_m(x_k)$\n由于$\\omega(x)$的零点刚好就是$x_k$，所以等式右边是0，这也就意味着$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n那反过来，如果我找到了若干点$x_k$把他拼成$\\omega(x)$，并且满足$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交，只要能证明求积公式$\\int_{a}^b\\rho (x)P_m(x)dx=\\sum_{k=0}^nA_kP_m(x_k)$有至少2n+1次代数精度就说明$x_k$是高斯点了。\n这是可以证明的。\n我们用$\\omega(x)$除以$P_m(x)$，得到$P_m(x)=\\omega(x)q(x)+r(x)$，由于r(x)是余项所以他的次数小于除式$\\omega(x)$的次数n+1也就是小于等于n，而被除式$P_m$次数小于等于2n+1，所以商式的次数小于等于2n+1-除式次数(n+1)=n。\n那么我们把这个带余除法的式子代入就有\n$\\int_{a}^b\\rho (x)P_m(x)dx=\\int_{a}^b\\rho(x)\\omega(x)q(x)dx+\\int_{a}^b\\rho(x)r(x)dx$\n我们条件里说$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交，而q(x)次数小于等于n并且前一个积分恰好就是$\\omega_(x)$与q(x)的带权内积，所以前一个积分是0。\n接着看后一个积分，由于高斯求积公式还是插值型的求积公式，所以后一个积分仍然至少有n次代数精度，而后一个积分的被积函数次数小于等于n所以他的求积公式仍然是准确的，因此有$\\int_{a}^b\\rho(x)r(x)dx=\\sum_{k=0}^nA_kr(x_k)$\n注意哦，你看我们的带余除法的式子：\n$P_m(x)=\\omega(x)q(x)+r(x)$\n你把$x_k$代入$\\omega(x_k)$是0，所以$P_m(x_k)=r(x_k)$因此\n$\\int_{a}^b\\rho (x)P_m(x)dx=\\int_{a}^b\\rho(x)\\omega(x)q(x)dx+\\int_{a}^b\\rho(x)r(x)dx=\\sum_{k=0}^nA_kr(x_k)=\\sum_{k=0}^nA_kP_m(x_k)$\n也就是说，现在我们的求积公式有至少2n+1阶代数精度，所以$x_k$就是高斯点。\n有这层关系在我们才有了求高斯点的方法。\n在带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间中总是有基函数$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$。\n虽然这组基不是正交基但是我们在高等代数里学过如何用一组基得出正交基，甚至得出标准正交基。\n这个方法就是施密特正交化。\n如果我们取权函数$\\rho(x)=1$，区间[a,b]为[-1,1]，这就是最开始说的高斯求积公式嘛，对基函数$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$进行施密特正交化就能得到新的一组正交基，然后再进行标准化就能得到标准正交基，而这组标准正交基就是所谓的勒让德多项式了。\n对于线性空间的一组正交基来说，它与任意其他基之间都是正交的。\n而你从中选一个n次多项式$P_n(x)$出来，再从内积空间中随便选一个次数小于n的多项式g(x)，它肯定不是由这个$P_n(x)$线性表出的嘛，所以他一定与$P_n(x)$线性无关，从而$P_n(x)$就与任意次数小于n的多项式正交了。\nOK，你现在再回去看定理。\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n而内积空间中的正交基中的任意一个n+1次多项式都和次数小于n+1也就是次数小于等于n的多项式带权正交。\n由于$\\omega(x)=(x-x_1)(x-x_2)\u0026hellip;(x-x_n)$的最高次系数是1，所以这个$\\omega(x)$是啥啊？\n不就是你从内积空间中的标准正交基里次数为n+1次的多项式吗？\n终于结束了。\n也就是说，你想求n+1点带权高斯公式$\\int_{a}^b\\rho (x)f(x)dx$的高斯点，就是要找$\\omega(x)$的零点，而$\\omega(x)$就是由带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基里的n+1次多项式$P(x)$，所以要找高斯点就是找$P_(x)$ 的零点。\n对于前面说的$\\rho(x)=1$这样的特例带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基就是勒让德多项式，我从勒让德多项式里取次数为n+1 的多项式，求他的零点，就得到高斯点了。\n那如果是最一般的带权高斯公式呢？\n方法一样的，我还是先找到带权内积$\\int_a^b\\rho (x)f(x)g(x)dx$诱导的内积空间的标准正交基。那怎么找呢？\n高等代数里已经学习过了，将基$1,x,x^2,\u0026hellip;,x^n,\u0026hellip;$进行施密特正交化得到一组正交基。\n然后呢，我再进行标准化，就得到标准正交基了。\n然后再取标准正交基里次数为n+1的多项式，再求他的零点即可。\n但是你仔细想想，真的需要标准化吗？\n其实不用，所谓的标准化就是在原来正交基的基础上给基除以其长度嘛。\n但是我只要求零点就可以了，你基缩放个常数倍影响零点吗？不影响的。\n所以其实根本就不用什么标准化，只需要正交化然后算零点就可以了。\n那反过来$\\rho(x)=1$的情况我一定要去记整个勒让德多项式吗？\n其实也不用的。\n勒让德多项式是什么$\\frac{n!}{(2n)!}\\frac{d^n}{dx^n}[(x^2-1)^n]$\n前面有一个系数$\\frac{n!}{(2n)!}$，这玩意存不存在影响零点吗？不影响的，这是标准化添加的额外的系数，我只求零点的话不要也罢。\n所以如果我想求n点高斯公式的高斯点，只要计算多项式$\\frac{d^n}{dx^n}[(x^2-1)^n]=0$的零点就可以了。\n这样记忆量会下降一点。\n但是话又说回来了，真的每次都要这么麻烦吗？\n其实也不用。\n其实啥也不用记。\n我们可以直接利用刚刚的性质求解高斯点。\n例如我想找$\\int_0^1\\sqrt xf(x)dx$的两点高斯求积公式。\n我们是要构造$\\omega(x)=(x-x_1)(x-x_2)$求零点的嘛，显然$\\omega(x)$是一个首项系数为1的二次多项式，我们直接设为$x^2+bx+c$。\n然后回去看看性质。\n$x_0,x_1,x_2,\u0026hellip;x_n$这n+1个点为高斯点当且仅当$\\omega_n$与任意次数小于等于n的多项式$P(x)$带权正交。\n所以$\\omega(x)$与多项式1，x带权正交。\n而这里权函数是$\\sqrt x$，既然$\\omega(x)$与1，x带权正交的话就有：\n$\\int_0^1\\sqrt x \\omega(x)1dx=0$\n$\\int_0^1\\sqrt x \\omega(x)xdx=0$\n这不是个含有两个未知量的两个方程吗？我直接解方程不就完事了。\n解得$b=-\\frac{10}{9},c=\\frac{5}{21}$\n然后求$x^2-\\frac{10}{9}x+\\frac{5}{21}=0$的根就得到两个高斯点为$0.821162,0.289949$了。\n接下来你可以用前面的方法求解系数$A_1,A_2$了。\n","date":"2024-12-21T13:49:00+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%952-%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值计算方法(2) 数值积分方法"},{"content":"初次发布于我的个人文档\n之前有一期简单介绍了一下拉格朗日插值和数值积分微分方法，我感觉有点太简单了。所以这次打算开个系列，好好唠一唠。\n什么是插值 在小学阶段，有一种题目叫找规律。\n什么1,2,6,7,10要你填下一个数。但是经常去论坛逛的人会发现，网友啊总是会给一个惊为天人的答案，什么114514啊之类的。\n然后抛出一个多项式，说你看这个114514啊是这个多项式在n=6的取值，前面的几个数也满足。所以这个找规律题下一个是114514。\n事实上，这就是完成了一次数学上的插值任务。\n他呢，相当于是已知若干点（在我前面的例子是已知(1,1),(2,2),(3,6),(4,7),(5,10),(6,114514))要找一个多项式恰好过这些点。\n这就是一个插值问题。\n当然，到了高中上了大学，你应该听说过导数这个玩意儿，所以有的时候我们还会要求多项式在某点的某阶导数是多少。\n这也是插值问题。\n我们也可以综合起来，既要求函数值又要求导数值，这样综合的插值问题我们也有办法解决。\n我们先看最简单的，也是你们一定了解过的。\n泰勒插值 看到名字不知道你想起泰勒公式了没有，没错泰勒插值就是泰勒多项式。\n你可以回去翻翻泰勒公式的引入。\n我给你看看百度百科是怎么介绍的。\n在数学中，泰勒公式（英语：Taylor\u0026rsquo;sFormula）是一个用函数在某点的信息描述其附近取值的公式。这个公式来自于微积分的泰勒定理（Taylor\u0026rsquo;s theorem），泰勒定理描述了一个可微函数，如果函数足够光滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这个多项式称为泰勒多项式（Taylor polynomial）。泰勒公式还给出了余项即这个多项式和实际的函数值之间的偏差。\n你看哈，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这不就是插值问题吗？\n也就是说，泰勒公式事实上是已知某一点的各阶导数，然后找了一个多项式，它的各阶导数值恰好是所给的导数值。\n很显然，这就是我们前面说的给导数型的插值问题。其解就是泰勒多项式。\n并且我们知道，泰勒多项式是唯一的。这个证明非常简单，并且我们可以进一步如果你要求到了函数的无穷阶导数恰好是f(x)的各阶导，那么我们知道，你得到的是泰勒级数，也就是函数f(x)的泰勒展开式。这里我们一并证明了。\n我们假设，除了泰勒公式之外还有一个多项式（对级数的情况就是另一个幂级数）$p(x)=\\sum_{n=0}^{+\\infty}a_n(x-x_n)^n$它也满足要求，\n对级数的情况，所谓的满足首先得满足p(x)收敛吧。所以还得要求p(x)在$x_0$附近内闭一致收敛于f(x)。\n在这种情况下，不管是n有限的泰勒插值，还是n趋于无穷大的泰勒插值，最终的p(x)都可以逐项求导。\n我们求n阶导看看，\n$p^{(n)}(x)=n!a_n+(n+1)n*\u0026hellip;32a_{n+1}(x-x_0)+\u0026hellip;$\n再取$x=x_0$就有$a_n=$泰勒多项式对应项的系数，从而插值问题的泰勒多项式是唯一的，函数的泰勒展开式也是唯一的。\n当然，泰勒展开不是本文关心的，我们只关心插值问题的泰勒多项式是唯一的。\n既然如此，我们不禁要问，那已知n个点的函数值的插值问题其解是不是唯一的呢？\n已知函数值的插值问题的唯一性 看标题就知道了，当然是唯一的。\n我们假设$p(x)=a_0+a_1x+a_2x+\u0026hellip;+a_nx^n$\n这里有n+1个系数，所以我们需要给定n+1个不同的点，或者说n+1个点需要用n次插值多项式插值。\n如果我们将这n+1个点代入就能得到\n$a_0+a_1x_i+a_2x_i+\u0026hellip;+a_nx_i^n=y_i$\n显然，这是一个线性方程组，并且还有更令人兴奋的，\n它的系数矩阵的行列式就是范德蒙德行列式。\n从而，其系数矩阵的行列式是$x_i-x_j$的乘积，又由于这n+1个点是不同的，所以它的系数矩阵的行列式不为0。\n那么根据克莱姆法则，这个线性方程组就有唯一解。\n所以插值多项式是唯一的。\n下一个问题自然就是怎么求解了。\n拉格朗日插值 你是可以硬解刚刚的方程组啦，但是这有点痛苦。\n拉格朗日插值的方法是，这样的：\n你不是要求$p(x_i)=y_i$吗？\n如果我能找到一系列多项式$l_k(x)$在$x_k$处取1，其他地方（指$x_1,x_2,x_3,\u0026hellip;,x_n$但不包含$x_k$)取0,\n那么p(x)不就是$y_i l_k(x)$$吗？\n这就是拉格朗日插值法的思想。\n其中$l_k(x)$被称为插值基函数。\n那么我们怎么找到插值基函数呢？\n其实很简单，$l_k(x)$在其他点取0从而其他点都是插值基函数的零点，所以插值基函数$l_k(x)$有因子\n$\\prod_{i \\neq k}(x-x_i)$\n那么我们怎么保证$l_k(x)$在$x_k$处取1呢？\n很简单啊，把$x_k$代入刚刚的可能的因子，把代入的结果除掉不就行了？\n也就是说$l_k(x)=\\frac{\\prod_{i \\neq k}(x-x_i)}{\\prod_{i \\neq k}(x_k-x_i)}$\n这就是拉格朗日插值基函数了。\n则拉格朗日插值多项式就是\n$p(x)=\\sum_{k=1}^n y_k l_k(x)$\n这就是拉格朗日插值公式了。\n关于插值公式，这个插值公式呢他是一个多项式。\n前面我们说过，n+1个节点要用n次多项式来插值，有时我们也说这样的插值是n次的。或者说，进行了n次插值。\n特殊的，如果是一次插值和二次插值，有时我们会说成是线性插值和抛物插值。\n接下来，如果我们把拉格朗日插值进一步优化，你就能得到埃特金插值。\n埃特金插值 当然，这个埃特金插值说的优化但其实不是优化公式本身，而是给计算过程进行了优化。\n前面我们说的拉格朗日插值有个很大的问题，就是他不具备承袭性。所谓承袭性也就是说我们已知n个点的插值多项式了，现在又加了一个点$x_{n+1}$，我们能在前面得到的插值多项式的基础上直接优化改进，直接以很小的计算量算出新的插值多项式。\n埃特金插值源于这样的观察，首先我们要画一张这样的差值表\n第一列是已知的点的横坐标，第二列是纵坐标。\n我们在表的最上面一项和其他项之间进行线性插值，你会发现得到了第三列，也就是两个节点的线性插值。\n如果在第三列的基础上再进行这样的线性插值得到的刚好是三个点的二次插值。\n进一步地，如果在n次插值的基础上再进行线性插值就会得到n+1次插值多项式。\n因此，想计算$x_0,x_1,x_2,x_3$的三次插值多项式，可以按表的方式计算到第五列。\n如果接下来增加了$x_4$这个点，只需要计算表最下面一列就可以得到新的四次插值多项式了。\n这就是埃特金插值，也称为埃特金逐次插值法。\n牛顿插值 不过我更建议大家用牛顿插值。\n因为牛顿插值在前面两种方法的基础上进一步优化，他也保证了承袭性，并且我们可以直接掏出一个公式。\n牛顿插值源于对拉格朗日插值基函数的观察。\n你看哈\n$l_0(x)=y_0$\n$l_1(x)=y_0\\frac{x-x_1}{x_0-x_1}+y_1\\frac{x-x_0}{x_1-x_0}$\n有没有什么联系？\n似乎很难看出来，但如果是这样的式子呢？\n$l_1(x)=y_0\\frac{x-x_1}{x_0-x_1}+y_1\\frac{x-x_0}{x_1-x_0}=y_0+\\frac{y_1-y_0}{x_1-x_0}(x-x_0)$\n这下一眼就看出来了吧。\n$l_1(x)=l_0(x)+\\frac{y_1-y_0}{x_1-x_0}(x-x_0)$\n更进一步地，可以发现\n$l_2(x)=l_1(x)+\\frac{\\frac{y_1-y_0}{x_1-x_0}-\\frac{y_2-y_1}{x_2-x_1}}{x_2-x_0}(x-x_0)(x-x_1)$\n大佬这注意力真是恐怖如斯啊！！！\n反正这个式子交给我我是不可能注意到的。\n但是现在结论已经公之于众了，而且结论非常漂亮。\n现在大家不难注意到，$l_{n+1}(x)=l_n(x)+$一个式子。\n而这个式子有特征的，它的因子恰好是$(x-x_0)(x-x_1)\u0026hellip;(x-x_{n-1})$\n而前面那个分式，分母是$x_{n-1}-x_0$，分子是两个式子作差，而减式和被减式的结构还是这个式子原本的结构（递归了）。\n前面那个分式就被我们称为差商。\n我们现在递归定义差商，\n参照百度百科的定义就是\n不过我肯定是不能直接抛给你这玩意儿的，虽然很严谨没错，但是你很难看懂。\n我们真正计算差商的方式是列差商计算表。\n这个还是百度百科的图。\n但是单看这个表你可能还是不容易理解，所以我又找了一张图。\n这张图来自B站UP主@泰勒猫爱丽丝的视频，BV号BV1du411a7qB。\n这其实就是差商计算表但是他上了个色，现在就简洁好看多了。\n第一列还是插值点的横坐标，第二列是纵坐标。\n纵坐标其实就是对应点$x_i$的0阶差商$f[x_i]$。（归纳奠基）\n接着相邻两项作差当1阶差商的分子。\n我们用下一项-上一项，例如$f[x_1,x_2]$的分子就是$f[x_2]-f[x_1]$\n那么分母呢？\n你看泰勒猫爱丽丝上的色，你先找到我们在分子里说的下一项也就是$f[x_2]$，然后找到他的颜色绿色，再回到第一列找到绿色的点的横坐标$x_2$，这就是分母的前一项了，类似地你找到$f[x_1]$的颜色红色，再回到第一列找到红色点的横坐标$x_1$，作差$x_2-x_1$就是分母了。\n所以$f[x_1,x_2]=\\frac{f[x_2]-f[x_1]}{x_2-x_1}$\n类似地，你会发现$f[x_i,x_{i+1},\u0026hellip;,x_j]=\\frac{f[x_{i+1},x_{i+2},\u0026hellip;,x_j]-f[x_i,x_{i+1},\u0026hellip;,x_{j-1}]}{x_j-x_i}$。\n分母刚好就是左边[]记号内的两个端点的差。分子则是比他低一阶差商的差。并且你会发现，分子的前一项缺了$x_i$，后一项缺了$x_j$，这是直接从式子里看出差商规律的办法。\n当然，自己手动计算的话我还是建议用刚刚说的那种上色+差商计算表的方法。\n拉格朗日插值余项 现在我们有插值的计算公式了，但是很多时候插值做的其实是拟合的工作而不是前面说的找规律问题，那么我就要问了，我拟合的插值多项式和真实的f(x)的误差是多少，也就是要求余项$R_n=f(x)-p_n(x)$。\n下面简单给个拉格朗日插值余项的结论，其定理的证明网上到处都是，我也没必要再赘述了。\n关于拉格朗日插值的误差，有如下的拉格朗日插值余项定理，\n设[a,b]上有插值节点$x_0,x_1,\u0026hellip;,x_n$，f(x)在[a,b]上有连续的直到n+1阶导数，且希望$f(x_i)=y_i$，\n那么就有当$x \\in [a,b]$时，有\n余项$R_n(x)=f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\prod_{k=0}^n(x-x_k)$\n其中$\\xi \\in [a,b]$\n这就是拉格朗日插值的余项了。由于插值多项式是唯一的，所以其他的插值方法的余项也是这个。\n聪明的你肯定越看越熟悉啊，这余项怎么感觉和泰勒公式的拉格朗日余项差不多？\n其实还真有关系。我们现在探究的插值任务要么只有导数信息，要么只有函数值信息，如果二者混合呢？\n艾尔米特插值 还有，你看那个差商的定义，你不觉得和导数是差不多的么？\n现在如果我令插值点具有等间距h，并且令间距h趋于0，所谓的各阶差商就刚好是泰勒公式的系数了。\n再次借用泰勒猫爱丽丝的视频\n他的视频实在是太优秀了，希望大家都可以去观摩一下。\n总之，我们按这样的情况推广牛顿插值就能得到兼容函数值信息和导数信息二者是艾尔米特插值方法了。\n例如，已知$x_0$的函数值和一阶导数值，$x_1$的函数值。\n那么就有\n横坐标 零阶差商(函数值) 一阶差商 二阶差商 $x_0$ $f(x_0)$ $x_0$ $f(x_0)$ $f\u0026rsquo;(x_0)$ $x_1$ $f(x_1)$ $\\frac{f(x_0)-f(x_1)}{x_0-x_1}$ $\\frac{f\u0026rsquo;(x_0)-\\frac{f(x_0)-f(x_1)}{x_0-x_1}}{x_0-x_1}$ 从而$p(x)=f(x_0)+f\u0026rsquo;(x_0)(x-x_0)+\\frac{f\u0026rsquo;(x_0)-\\frac{f(x_0)-f(x_1)}{x_0-x_1}}{x_0-x_1}(x-x_0)(x-x_0)$\n你可以把式子化简一下，不过我这里化简了反而不利于观察出式子的来历，所以就不动了。\n你可以验证一下，这个插值多项式就是满足$x_0$的函数值和一阶导数值，$x_1$的函数值的艾尔米特插值结果了。\n误差的事后估计：回看埃特金插值 现在插值体系已经比较完备了，这里我想做的是其他的事，就是让你也看出埃特金插值。\n额，牛顿插值你想直接看出来的话我也没有什么太好的办法，没法分享了。\n我提供一个通过误差的事后估计看出埃特金插值的办法。\n假定我们已知了3个节点$x_0,x_1,x_2$，在$x_0,x_1$和$x_1,x_2$之间进行一次线性插值，可以得到两个插值多项式。\n例如，我们对$f(x)=\\sqrt{x}$进行插值，取$x_0=100,x_1=121,x_2=144$，现在我们来求$\\sqrt{115}$的近似值。\n先用$x_0,x_1$进行线性插值得到$\\sqrt{115}\\approx10.71428$，然后再用$x_1,x_2$进行线性插值再把$x\u0026rsquo;=115$代入得到$\\sqrt{115}\\approx10.68182$。\n接下来我们有办法用这两个近似值得到精度更高的近似值。\n现在我们的情况是，通过两次线性插值得到了两个近似值$y\u0026rsquo;_1,y\u0026rsquo;_2$。\n那么依据拉格朗日余项定理，有\n$f(x\u0026rsquo;)-y\u0026rsquo;_1=\\frac{f\u0026quot;(\\alpha)}{2}(x\u0026rsquo;-x_0)(x\u0026rsquo;-x_1)$\n$f(x\u0026rsquo;)-y\u0026rsquo;_2=\\frac{f\u0026quot;(\\beta)}{2}(x\u0026rsquo;-x_1)(x\u0026rsquo;-x_2)$\n如果我们认为f的二阶导变化不大，也就是$f\u0026rsquo;\u0026rsquo;(\\alpha)\\approx f\u0026rsquo;\u0026rsquo;(\\beta)$，然后两式相除就有，\n$\\frac{f(x\u0026rsquo;)-y\u0026rsquo;_1}{f(x\u0026rsquo;)-y\u0026rsquo;_2}=\\frac{x\u0026rsquo;-x_1}{x\u0026rsquo;-x_2}$\n把分子分母颠倒一下就是\n$\\frac{f(x\u0026rsquo;)-y\u0026rsquo;_2}{f(x\u0026rsquo;)-y\u0026rsquo;_1}=\\frac{x\u0026rsquo;-x_2}{x\u0026rsquo;-x_1}$\n再分离常数就有\n$1+\\frac{y_1\u0026rsquo;-y_2\u0026rsquo;}{f(x\u0026rsquo;)-y_1\u0026rsquo;}=1+\\frac{x_1-x_2}{x\u0026rsquo;-x_1}$\n从而两边同时减去1，\n$\\frac{y_1\u0026rsquo;-y_2\u0026rsquo;}{f(x\u0026rsquo;)-y_1\u0026rsquo;}=\\frac{x_1-x_2}{x\u0026rsquo;-x_1}$\n因此，\n$f(x\u0026rsquo;)-y_1\u0026rsquo;=\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$\n也就是说，我们估计出了一个准确的误差$f(x\u0026rsquo;)-y_1\u0026rsquo;\\approx\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$\n这样的话，我已经知道估计出准确值和近似值的误差了，我再把误差补回去不就是一个更精确的近似值了？\n所以我们可以得到更精确的近似值为$y_1\u0026rsquo;+\\frac{x\u0026rsquo;-x_1}{x_2-x_1}(y_2\u0026rsquo;-y_1\u0026rsquo;)$，对本例就是10.7228。\n你会发现，这个近似值就是抛物插值的结果，这就是误差的事后估计法。\n也就是说，我们通过误差的事后估计法可以使得插值的次数+1，这不就也是埃特金插值？\n龙格现象和过拟合 现在你可能有一个大概的印象，就是说插值点越多，插值次数越高精度越高。\n但其实并不是这样的。在机器学习领域有一个叫过拟合的词，说的是你啊用这种方式拼命堆数据大力出奇迹，结果反而会变差。\n例如，你搞了一个分辨叶子的模型，然后给他喂了一万张叶子图片，结果里面的叶子都是带锯齿的，所以模型学习到了带锯齿的东西是叶子，从而你给他一个没锯齿的叶子他会判否，给他个有锯齿的其他东西他却说是叶子。\n我们插值也有类似的过拟合现象。\n插值点越多，插值次数越高，插值多项式的次数也越高，而$x^100$次方，你x稍微变一下，y就会差很多，从而会导致你的插值多项式在端点处震荡地非常离谱，导致精度反而下降了。这就是龙格现象，我个人觉得也是一种过拟合。\n参考百度百科的图，\n你会看到，高次插值多项式在两个端点处疯狂震荡，这样反而会导致精度下降。\n分段低次插值 那么怎么解决这个问题呢？答案是用多次低次插值来拟合函数。\n你给了我1,2,3,4,5,6,7,8,9,10这10个点的信息，我怎么做呢？\n我拼一个分段函数给你，x在[i,i+1]的时候，表达式就是i和i+1的线性插值。\n当然，也可以是x在[i-1,i+1]的时候，表达式是i-1,i,i+1的二次插值等等。\n总之就是给你这样的分段函数，并且他们的插值次数都不高。\n这就是分段低次插值。\n但是这样的插值还是有问题，他在分界点往往不可导，这是我们不希望看到的。\n样条插值 所以样条插值应运而生。\n其实理论说起来也比较简单。\n例如还是已知1,2,3,4,5,6,7,8,9,10的信息。\n我把他分成[1,2],[2,3],\u0026hellip;,[9,10]这样的9段。\n每一段我都用一个三次函数拟合（这个函数被称为样条函数，这样的样条插值被称为三次样条插值，当然你也可以通过改变段的分法来改变样条函数的次数）。\n在这里每一段只有两个点，按道理线性插值就足以了啊，为什么要用三次函数呢？\n这是因为我要强行加条件了，我要求这个样条函数在分界点连续，即2,3,4,5,6,7,8,9处函数值相等。\n这是附加了8个条件。\n而原本有9个三次函数，每个三次函数有4个系数，也就是需要36个条件。\n现在只用了8个，还绰绰有余呢。\n现在我再加强条件，要求样条函数在分界点一阶可导，即要求分界点左右导数相等，这又是8个条件。\n进一步，我还要求二阶可导，又是8个条件。\n这才用了24个条件。还剩下12个条件。\n当然，我自然是需要要求函数在1到10每个点上函数值等于所给的需要插值的函数值的，所以还有2个条件。\n这两个条件给1和10这两个最后的边界点，可以是规定边界点的一阶导或者二阶导都可以，反正把这两个条件用了就可以了。\n然后用计算机来求解就ok了。\n额，你不会觉得36元一次方程组我要手算吧，不会吧不会吧。\n真的有那个毅力手算的朋友，告诉你一下，最后的线性方程组是一个三对角方程组，后面我会介绍追赶法求解三对角方程组的方法的，这种方程最好用那个方法解。\n","date":"2024-12-21T10:12:41+08:00","permalink":"https://ColaBlack.github.io/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%951-%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95/","title":"数值计算方法(1) 插值方法"},{"content":"在异步与资源调度-以浏览器事件循环为例我们以浏览器为例简单的介绍了一下资源的调度和事件循环，在那一期我们就留了一个坑。这一期我们就来填上，介绍一下什么是进程、线程、协程，以及他们的区别和联系。\n硬件资源调度 今天我们讲的这些概念都来自于操作系统，是操作系统为了充分利用硬件资源的机制。\n我们先来设想一个最简单的资源调度方案。这也是在IBM7094这样的上古机器里使用的资源调度方案。\n在当时像IBM7094这样的计算机，造价在250万美元以上，非常昂贵因此我们希望充分利用计算机，尽可能地利用上计算机提供的算力资源。\n这台计算机使用的就是批处理方法，计算机没有额外动作只会一个一个地执行任务。用户在磁带上编程，然后计算机不停的执行磁带上的代码，当完成了一个任务或者这个任务出现了异常，那么计算机就执行下一个任务。\n这样的资源调度非常简单，但是后来人们还是发现了一些问题。\n我们还是以现代计算机执行的任务为例，有的时候我可能会写这样的代码\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(){ int a = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); return 0; } 这个代码的问题在于，当程序执行到scanf的时候计算机会等待用户输入，CPU啊之类硬件的就停止工作了。这太浪费了啊！\n这种任务被我们称为是IO密集型任务，当CPU在执行这样的任务的时候我们希望CPU能在IO阻塞的时候执行其他任务。\n那怎么弄呢？\n很简单其实，类似于计算机网络中使用的时分复用，我们可以让多道程序交替执行从而提高效率。\nA程序先执行需要CPU的任务，接着进入需要磁盘IO的任务，CPU就切换到任务B的执行，同时\n磁盘放在继续完成任务A。\n这样的多道程序交替执行就是现代计算机资源调度的一个核心。\n这种方式也被称为并发，并发本质上只有一个CPU在干活，但是他交替执行多个程序，这样不仅提高了CPU利用率而且在用户看来，他会感觉是多个任务同时执行。\n但是我们怎么才能做到这样的并发呢？\n熟悉计算机硬件的人可能会说，只需要修改PC寄存器就行了。（也就是修改CPU正在执行的指令）\n但是\n如果程序A是\n1 2 3 mov ax, 1 mov bx, 1 add ax,bx 也就是ax寄存器存1，bx寄存器存1，执行1+1\n程序B是\n1 2 3 mov ax, 10 mov bx, 10 add ax, bx ax寄存器存10，bx寄存器存10，执行10+10\n我们这样生硬的切换PC就会出现问题了。\n程序A可能已经把ax改成1了，接着你进入了程序B，把ax改成了10，接着B执行完了又回到A则ax还是10，程序A最后就会输出10+1=11了。\n这就出了问题。\n因而，我们需要一个数据结构来存储程序A执行到哪里了，执行的时候各种变量是多少。在操作系统中，这个数据结构被称为PCB。\n但是这样会导致运行中的程序需要额外记录PCB，这就导致运行中的程序和其他程序不一样了。\n所以我们又抽象了一个概念，叫做进程，它的意思就是进行中的程序。\n进程 再次重复一遍，进程就是运行中的程序。现在我们对硬件资源的调度就是对进程的调度。\n为了更好地管理进程，我们还会根据进程的状态对进程进行分类。\n当我创建进程的时候我们说进程处于新建态，\n接着进程会等待CPU的执行，这时是就绪态，通俗的说就是进程已经准备就绪了，随时可以被CPU执行。\n执行中的进程进入了运行态，而执行完成的进程就进入了终止态。\n前面我们还说了磁盘IO会阻塞进程，这时的经常处于阻塞态。\n进程的调度策略，我们前面已经以浏览器为例介绍了一种方案了就不再详细说明了。\n前面我们说我们对硬件资源的调度就是对进程的调度，多道程序交替执行就是现代计算机资源调度的一个核心，那么计算机是如何实现多个进程的交替执行呢？\n这个我们暂时只讲一半。\n因为进程的切换涉及到两块。\n第一块我们之后再说。就是这样的：\n操作系统为了防止进程之间相互影响，例如：\n进程A设置内存地址为100的内存数据为1，进程B却来设置这块内存为2，这可能会导致进程A报错打架。所以操作系统引入了内存映射表，引入了虚拟内存的机制。\n思路很简单，进程A看到的内存100，其实是在真实的内存里可能是1100，但是进程B看到的内存100在真实内存里是2100。每次看到一个进程访问内存100，我就先去内存映射表里看看这个内存地址100在真实的内存里到底是哪个地址然后再执行指令。（但是虚拟内存的存在导致了不同进程之间的资源是不共享的）\n所以，进程之间的切换还要照顾到虚拟内存和内存映射表的切换，这一部分等我们以后有机会讲操作系统的内存调度的时候再说吧。\n进程切换的另一块是不同进程之间指令序列的切换，我们来讲这个。\n进程的指令切换 不过我更想做的是我们自己写个函数调用来实现一下进程间的指令切换。有没有办法呢？\n可以的。\n我们来试试看：\n假如进程1是这样的代码\n1 2 3 4 5 6 7 8 内存地址100:A(){ B(); 内存地址104 } 内存地址200:B(){ yield(); 内存地址204 } 进程2是\n1 2 3 4 5 6 7 8 内存地址300:C(){ D(); 内存地址304 } 内存地址400:D(){ yield(); 内存地址404 } 我们先启动进程1，先进入地址100的A函数，然后A函数调用B函数，B函数执行yield函数。yield函数的意思是切换到另一个进程。\n那么CPU会执行C函数，然后C函数调用了D函数，D函数再切换到进程1，接着函数就开始返回了。\n但是我们来分析看看现在的函数调用栈。\nA调用B，104入栈。\nB调用yield，204入栈，\nC调用D，304入栈，\nD调用yield，404入栈。\n接着开始返回了，此时我们在进程1，但是出栈的时候出的是进程2的404，这不就炸了。\n你明明要运行进程1啊，怎么出了人家的东西。\n这个问题只需要稍加修改就行了，我们给进程1和2分别维护一个栈。\n这样进程1的栈只有104和204了，然后204出栈，104出栈。\n但是现在入栈的过程又不太一样了。\n还是\nA调用B，104入栈。\nB调用yield，204入栈\n但是现在要切换到进程2去了，我们要换一个栈，因此需要一个指针来指向当前的栈，还需要给两个栈分别申请内存空间。\n栈的信息存储在一个叫TCB的数据结构中，而esp是指向当前栈的指针变量。\n那么yield函数是做了什么呢？\n将当前栈的信息存起来，然后切换esp为下一个进程的栈。就这么两句简单的语句。\n现在我们来看看新建线程的时候要做什么，就是要申请一个新的栈然后先把当前的第一个语句入栈再等待执行。（注意C语言基础，语句是在出函数调用栈的时候执行的）\n出栈的时候你会发现我只说了线程1的出栈而没有说线程2的出栈。这是因为线程1已经结束了然而他没有切换到线程2。\n但是这个无伤大雅，因为\n线程2完成阻塞的任务之后会进入就绪态，当CPU空闲的时候操作系统会按一定规则唤醒一个就绪态的线程，这个就等以后有时间我们聊聊真实完整的操作系统的任务调度吧。\n像我们这样实现的所谓的进程，只实现了指令序列的切换而资源没有切换，并且没有进入操作系统内核，一直在用户态进行操作，这种所谓的进程就是协程（也称为纤程或者用户级线程）。\n这个协程呢，没有涉及到操作系统内核也就没有涉及到系统调用，甚至你自己可以在任何高级编程语言上实现。\n现在Python、kotlin、Java等高级编程语言已经有一套官方的标准库来实现协程了。（啊哈哈，还在用java 8的可以试试参考上面的方法自己手动实现一个，俺们jdk 21先跑了）\n用户级线程的问题 用户级线程始终没有进入操作系统内核但是有没有问题呢？\n有的，因为这样的线程只在用户态并发，但是在内核态什么也没做，那么操作系统怎么可能会知道你创建了多个用户级线程呢？\n试想这样的一个场景：\n进程A开了用户级线程1 用户级线程2\n用户级线程1进入了操作系统内核，也就是进入了内核态并发生了阻塞。\n那么操作系统为了高效利用CPU会将CPU的使用权交给其他进程而不是用户级线程2（这是因为在操作系统眼里只有进程A一整个进程而没有两个用户级线程，所以他在调度的时候自然不会考虑这些）。从而你会发现，用户级线程2跟着用户级线程1阻塞了，此时用户就会感到卡顿了。\n所以要想真正实现并发，必须要操作系统介入，实现内核级的线程。这就是真正的线程了。\n线程之间仍然不切换虚拟内存的内存映射表，从而线程之间是共享资源的。\n而要实现内核级线程，首先他在用户态和用户级线程没有区别需要维护两个栈。\n那么在内核态呢？\n你会发现，无非不还是栈啊什么的切换，无非还是一些函数调用，所以在内核态也还是要维护这样的两个栈。\n因此每一个线程都要在用户态和内核态维护两套不同的栈。\n当用户态通过系统调用调用了操作系统的接口说我要切换线程了，会发生什么呢？\n在用户态，我们的线程应该做和用户态线程一样的操作，入栈接下来要运行的代码。\n而在内核态，我们还是要把这个线程在内核态的信息入栈，接下来和前面类似，完成内核态的栈的切换（代码和前面其实是一样的），再从内核态离开进入另一个线程的用户态执行代码。\n如果要说的高大上一点就是，线程1将从线程2返回后要执行的代码入用户态的栈，然后通过中断（对x86架构的计算机就是执行汇编命令int 0x80）进入内核态，内核态的栈再将切换线程的代码出栈执行线程切换的代码（schedule）将执行的线程切换为线程2，然后线程2在内核态的栈再出栈执行汇编命令iret回到用户态，接着用户态的栈出栈执行线程2的代码。\n总结 总之，运行中的程序叫做进程，进程与进程之间资源是不共享的。\n而我们只在用户态实现的资源共享的利用两个栈实现的用户级线程就是协程。\n而操作系统利用两套栈实现的资源共享的并发结构就是线程。\n他们的区别是进程资源不共享，切换的时候需要切换资源也要切换指令序列。而线程只切换指令序列。\n但是相比于轻巧的协程，线程的切换开销要大，不过协程在执行需要进行系统调用的指令的时候还是会有阻塞的问题。\n但是在实际编程的时候你可能又会发现，协程是用户级实现的，不受操作系统调度的影响，程序员可以随意把控当前运行的协程是哪一个自由度更高。（以后你会看到，操作系统在进行资源调度的时候会对线程进行时间分片，程序员无法直接把控什么时候切换切出线程，当前在执行哪个线程从而会带来一些并发问题）\n","date":"2024-12-04T18:37:49+08:00","permalink":"https://ColaBlack.github.io/p/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/","title":"进程线程与协程"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文想简要介绍和推导一下拉格朗日插值和数值积分方法。\n什么是插值？ 所谓的插值就是已知几个离散点的信息视图求一个满足这些信息的函数的过程。\n如拉格朗日插值和牛顿插值就是已知f(x)在若干点的函数值希望找一个多项式函数穿过这些点。\n而艾尔米特插值则更进一步要求函数在各个点的各阶导数值都等于指定的值。\n本文只介绍最基础的拉格朗日插值和牛顿插值。\n插值的唯一性 这两种插值方法都是已知一系列点$(x_i,y_i)$，找一个多项式p(x)它穿过了这些点。\n其实这个问题你应该很容易就能找到第一个方法，待定系数法嘛。\n我们假设$p(x)=a_0+a_1x+a_2x+\u0026hellip;+a_nx^n$\n这里有n+1个系数，所以我们需要给定n+1个不同的点，或者说n+1个点需要用n次插值多项式插值。\n如果我们将这n+1个点代入就能得到\n$a_0+a_1x_i+a_2x_i+\u0026hellip;+a_nx_i^n=y_i$\n显然，这是一个线性方程组，并且还有更令人兴奋的，\n它的系数矩阵的行列式就是范德蒙德行列式。\n从而，其系数矩阵的行列式是$x_i-x_j$的乘积，又由于这n+1个点是不同的，所以它的系数矩阵的行列式不为0。\n那么根据克莱姆法则，这个线性方程组就有唯一解。\n所以插值多项式是唯一的。\n拉格朗日插值 那么怎么求插值多项式呢？\n你是可以硬解刚刚的方程组啦，但是这有点痛苦。\n拉格朗日的方法是，这样的：\n你不是要求$p(x_i)=y_i$吗？\n如果我能找到一系列多项式$l_k(x)$在$x_k$处取1，其他地方（指$x_1,x_2,x_3,\u0026hellip;,x_n$但不包含$x_k$)取0,\n那么p(x)不就是$y_i l_k(x)$吗？\n这就是拉格朗日插值法的思想。\n其中$l_k(x)$被称为插值基函数。\n那么我们怎么找到插值基函数呢？\n其实很简单，$l_k(x)$在其他点取0从而其他点都是插值基函数的零点，所以插值基函数$l_k(x)$有因子\n$$\\prod_{i \\neq k}(x-x_i)$$那么我们怎么保证$l_k(x)$在$x_k$处取1呢？\n很简单啊，把$x_k$代入刚刚的可能的因子，把代入的结果除掉不就行了？\n也就是说$l_k(x)=\\frac{\\prod_{i \\neq k}(x-x_i)}{\\prod_{i \\neq k}(x_k-x_i)}$\n这就是拉格朗日插值基函数了。\n则拉格朗日插值多项式就是\n$$p(x)=\\sum_{k=1}^n y_k l_k(x)$$这就是拉格朗日插值公式了。\n把拉格朗日插值进一步优化，你就能得到埃特金插值和牛顿插值。\n这个就不多介绍了，比较复杂而且插值公式是唯一的，你用任何方法得到的插值公式都是一样的。而且市面上大把的直接计算插值的软件和库，他们直接内置了其他的插值方法。\n拉格朗日插值余项 下面简单给个拉格朗日插值余项的结论，其定理的证明网上导出都是，我也没必要再赘述了。\n关于拉格朗日插值的误差，有如下的拉格朗日插值余项定理，\n设[a,b]上有插值节点$x_0,x_1,\u0026hellip;,x_n$，f(x)在[a,b]上有连续的直到n+1阶导数，且希望$f(x_i)=y_i$，\n那么就有当$x \\in [a,b]$时，有\n余项$R_n(x)=f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\prod_{k=0}^n(x-x_k)$\n其中$\\xi \\in [a,b]$\n这就是拉格朗日插值的余项了。由于插值多项式是唯一的，所以其他的插值方法的余项也是这个。\n数值积分方法 下面我们来介绍一下怎么用插值法来得到数值方法计算函数积分。\n对于大部分函数，我们其实都是很难求其积分的，甚至很多函数例如$e^{x^2}$这样的函数压根就没有初等原函数。所以我们需要寻找数值方法来计算他们的积分。\n一种可能的思路就是用刚刚的插值多项式来近似替代这个函数。而且我们是已知了差值余项的，余项的积分就是我们数值积分方法的误差。\n而这些都是多项式啊，都很好计算的。\n这种求积分的数值方法得到的积分公式我们都叫做差值型的求积公式。\n前面我说这只是数值求积的一种思路，其最本真的思路其实是取函数的部分函数值，用他们的线性组合来近似积分。\n也就是最一般化的求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$。\n只需要知道$A_k$就知道怎么求积了。\n而对于插值型求积公式，我们很容易就能得到$A_k$。\n插值型求积公式就是用f(x)的插值多项式近似f(x)，从而有\n$\\int_a^bf(x)dx \\approx \\int_a^bp_n(x)$\n再把拉格朗日插值公式代入得\n$\\int_a^bf(x)dx \\approx \\int_a^b \\sum_{k=1}^n y_k l_k(x)dx$\n$=\\sum_{k=1}^n y_k\\int_a^bl_k(x)dx$\n而我们最一般的求积公式是$\\int_a^b f(x)dx=\\sum_{k=0}^n A_k y_k$，从而\n$A_k=\\int_a^b l_k(x)dx$\n牛顿-科特斯公式 如果我们进一步要求，插值点的间距相等（步长为h），我们可以得到一个特殊的结论。\n我们竟然将区间长度提出来了，\n$\\int_a^b f(x)dx=(b-a)\\sum_{k=0}^n C_k y_k$\n并且，$C_k$竟然还是常数。\n我们称$C_k$为科特斯系数，可以直接查科特斯系数表得到，与具体的函数f(x)无关，只和你插值多项式的次数n有关!\n这就是牛顿-科特斯公式。\n其中n=1得到的求积公式被称为梯形公式，n=2的是辛普森公式。\n对牛顿-科特斯公式的玩法有很多，例如复化得到复化梯形公式和复化辛普森公式，还有递推化得到龙贝格公式等等。\n还有变步长使得精度尽可能高的高斯公式等等玩法。\n数值微分方法 有了积分当基石我们就可以用数值方法求解微分方程。\n我们以标准的微分方程初值问题为例介绍几个简单的方法。\n对微分方程\n$$\\frac{dy}{dx}=f(x,y)$$我们两边同时积分得到\n$$\\int_{x_n}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n}^{x_{n+1}}f(x,y)dx$$也就是\n$$y_{n+1}-y_n=\\int_{x_n}^{x_{n+1}}f(x,y)dx$$从而\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)dx$$而如果我们可以用数值方法求出这个积分，不就解出了这个微分方程？\n例如，我们直接用积分区间左端点得到的矩形的面积来近似积分（这个叫做左矩形求积公式）\n得到\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_n,y_n)$$这就是欧拉格式。(注意，数值微分里我们称为格式而不是公式，这里没有打错字)\n你可能会发现我这里给的欧拉格式和网上一般的不一样，其实你只要设$h=x_{n+1}-x_n$（当我设了h就默认等步长了）就能得到一般的欧拉格式了。\n$$y_{n+1}=y_n+hf(x_n,y_n)$$同样地，我们可以用积分区间右端点得到的矩形面积（右矩形公式）近似积分得到\n$$y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_{n+1},y_{n+1})$$类似地，我们设$h=x_{n+1}-x_n$就有，\n$$y_{n+1}=y_n+hf(x_{n+1},y_{n+1})$$这就是隐式欧拉格式了。\n那如果我用区间中点的矩形，还能得到两步欧拉格式：\n对微分方程\n$$\\frac{dy}{dx}=f(x,y)$$我们两边同时积分得到\n$$\\int_{x_n-1}^{x_{n+1}}\\frac{dy}{dx}=\\int_{x_n-1}^{x_{n+1}}f(x,y)dx$$注意，这次是从$x_{n-1}$积到$x_n$，并且我们要求步长为h，则$x_n$是积分区间中点。\n有$y_{n+1}-y_{n-1}=2hf(x_n,y_n)$\n从而，$y_{n+1}=y_{n-1}+2hf(x_n,y_n)$\n这就是两步欧拉格式。\n还可以用刚刚说的梯形公式来求积分得到梯形格式，或者引入预报-矫正系统得到改进的欧拉格式。\n以及另外一个思路可以得到一整套的龙格-库塔方法和亚当姆斯方法。\n","date":"2024-11-30T15:26:27+08:00","permalink":"https://ColaBlack.github.io/p/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86/","title":"拉格朗日插值和数值微积分"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文想简要介绍一下如何用计算机是如何用迭代法计算方程和方程组的根的。\n不动点迭代 在高中阶段你可能学习过这样的叫蛛网图的东西：\n蛛网图迭代的极限就是函数的不动点。\n所谓不动点迭代就是利用了这样的性质。\n一般地，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，那么g(X)的不动点就是f(x)的零点。\n而g(x)的不动点又是蛛网图迭代的极限。\n如果用代数语言表示的话，就是迭代公式\n$$x_{k+1}=g(x_k)$$这就是不动点迭代求方程的根的方法。\n当然，如果要更严谨化的说明的话，就是下面的压缩映像原理：\n设g(x)在[a,b]上具有连续的一阶导数，且满足以下条件：\n1.$\\forall x \\in [a,b],g(x) \\in [a,b]$\n2.$\\exist 0 \\le L \u0026lt;1,s.t. \\forall x\\in [a,b],|g\u0026rsquo;(x)|\\le L$\n则迭代过程\n$x_{k+1}=g(x_k)$收敛，且有误差估计式：\n$|x^*-x_k|\\le \\frac{L^k}{1-L}|x_1-x_0|$\n从误差估计式看，k越大估计值$x_k$会离准确值$x^*$越来越近。\n这就足以为不动点迭代法背书了。\n牛顿迭代法 将不动点迭代进一步推广就能得到牛顿迭代法。\n前面我们知道，我们想求解方程f(x)=0，如果我们可以将这个方程转化为x=g(x)，然后用迭代公式$x_{k+1}=g(x_k)$求解。\n但是我们不知道如何把方程转化为x=g(x)，牛顿迭代法就是解决了这个问题。\n思路其实也非常简单，我们知道微分有dy=f\u0026rsquo;(x)dx，于是$f(x)-f(x_k) \\approx f\u0026rsquo;(x_k)(x-x_k)$。\n从而$f(x)=f(x_k)+f\u0026rsquo;(x_k)(x-x_k)=0$\n那么$x=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$，完成啦！\n我们把f(x)=0转化为了x=g(x)的形式了，从而再使用不动点迭代得到f(X)根的迭代公式：\n$x_{k+1}=x_k-\\frac{f(x_k)}{f\u0026rsquo;(x_k)}$\n这就是牛顿迭代法。\n弦截法 对于某些函数其导数不便于求解，所以我们可以用差商替代导数，这就是弦截法了。\n用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_0)}{x_k-x_0}$代入牛顿迭代法，就是弦截法了。\n如果用$f\u0026rsquo;(x) \\approx \\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$代入牛顿迭代法，就是快速弦截法了。\n雅可比迭代法 对于线性方程组，方法其实是类似的。\n线性方程组AX=b如果我们可以将其化为X=BX+f，那么用不动点迭代就有迭代公式\n$X_{k+1}=BX_k+f$\n这是我们线性方程组迭代法的基石。\n它的误差：\n$e_{k+1}=|x^-x_{k+1}|=|BX^+f-(BX_{k}+f)|=B|X^*-X_k|=Be_k$\n从而，$e_k=B^ke_0$\n那么如果$B^k$能收敛于0的话该迭代法就收敛了，可以演算得到这等价于B的谱半径（最大特征值）小于1。\n但是还是一样的，不动点迭代法说的轻巧，但是你怎么把AX=b转化成X=BX+f呢？\n其中的一种方法就是雅可比迭代法了。\n对方程组AX=b，我们将A分解为对角阵D，下三角矩阵L，上三角矩阵U使得\nA=D-L-U。\n（值得一提的是，这个分解是相当容易的，D就是A的对角元，L取A的下三角去掉主对角线，U取A的上三角去掉主对角线即可）\n那么AX=b就是\n(D-L-U)X=b\n然后移项得\nDX=(L+U)X+b\n从而$X=D^{-1}(L+U)X+D^{-1}b$\n完事了，已经变成X=BX+f的形式了，所以就有迭代公式\n$X_{k+1}=D^{-1}(L+U)X_k+D^{-1}b$\n这就是雅可比迭代法了。\n但是这个方法可以稍微变一下，我们移项的时候不一定要把L和U全部移走，这就是高斯-赛德尔迭代法了。\n高斯-赛德尔迭代法 还是安装雅可比迭代的步骤我们得到，(D-L-U)X=b移项但是只移U得到\n(D-L)X=UX+b\n然后得到$X=(D-L)^{-1}UX+(D-L)^{-1}b$\n于是就有迭代公式$X_{k+1}=(D-L)^{-1}UX_k+(D-L)^{-1}b$\n但是我们一般不会这么使用，而是再等式两边再乘以D-L得到\n$(D-L)X_{k+1}=UX_k+b$\n从而$DX_{k+1}=LX_{k+1}+UX_k+b$\n所以$X_{k+1}=D^{-1}LX_{k+1}+D^{-1}UX_k+D^{-1}B$\n这才是我们一般最爱用的高斯-赛德尔迭代公式。\n","date":"2024-11-29T14:11:03+08:00","permalink":"https://ColaBlack.github.io/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"方程求根的迭代法"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本文简要介绍一下主成分分析和因子分析的原理，但是不涉及具体代码实现。这是因为现在已经有很多现成的软件或库实现了这两个算法，读者只需要一两句简单的命令就可以使用了，所以没有必要在这里讲解。而且你可能会在Python R MATLAB SPSS等多种不同的软件中使用，无论选哪个软件的代码实现都没有特别强的代表性。\n主成分分析 如果你手上有一组数据，例如是大家的语文数学英语成绩。但是现在有一个问题，咱们的试卷出得有那么一点点不好，大家的成绩都集中在一起了，也就是试卷的区分度不大。现在，我们有没有办法补救呢？\n注意：这只是一个例子而已，自然是不考虑我们进行各种变换之后的现实问题，例如这样搞成绩会不公平啊什么的。\n总之，我们的核心问题是，有没有办法对现有数据进行变换，使得数据的每一个个体尽可能被分开。\n这就是主成分分析的一个可以选择的切入点。\n那我们要选择什么样的变换呢？以及有没有办法将一个群体之间的不同个体距离拉远。\n以p维正态分布为例进行可行性探索 嗯，对我们先拿p维正态分布探索一下我们想法的可行性。\n我们假设p维随机向量X服从协方差阵为$\\Sigma$，均值向量为$\\mu$的p维正态分布。\n那么X的概率密度函数就是$P(x)=\\frac{1}{(2\\pi)^{\\frac{p}{2}}|\\Sigma|^{\\frac{1}{2}}}e^{-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)}$，我们来观察其概率密度等高线，显然，这里只有e的指数是变量，所以概率密度等高线满足：\n$$-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=C_1$$也就是$(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=C_2$\n我们可以对$\\Sigma $进行谱分解。\n谱分解说明：\n根据线性代数的知识我们可以知道，任意实对称阵A可以正交相似对角化，即\n$\\forall 实对称矩阵A,\\exist正交阵Q和对角阵\\Lambda，使得A=Q\\Lambda Q^T$\n如果我们已知A的特征值$\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n$和对应的特征向量$e_1,e_2,\u0026hellip;,e_n$，则\nQ=($e_1,e_2,\u0026hellip;,e_n$)，$\\Lambda =diag(\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)$\n这意味着:\n$$A=Q\\Lambda Q^T$$$$=(e_1,e_2,...,e_n)diag(\\lambda_1,\\lambda_2,...,\\lambda_n)(e_1,e_2,...,e_n)^T$$$$=(\\lambda_1 e_1,\\lambda_2 e_2,...,\\lambda_n e_n)(e_1,e_2,...,e_n)^T$$$$=\\lambda_1 e_1 e_1^T + \\lambda_2 e_2 e_2^T +...+ \\lambda_n e_n e_n^T$$$$=\\sum_{i=1}^n\\lambda_i e_i e_i^T$$这就是谱分解了。\n我们假设$\\Sigma$的特征值为$\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_p$，对应的特征向量为$e_1,e_2,\u0026hellip;,e_p$，那么$\\Sigma$就可以谱分解为\n$\\Sigma=\\sum_{i=1}^p\\lambda_i e_i e_i^T$，将他代入概率密度等高线方程就有，\n$(x-\\mu)^T{(\\sum_{i=1}^p\\lambda_i e_i e_i^T)}^{-1}(x-\\mu)=C_2$\n也就是，\n$$\\sum_{i=1}^p\\frac{[e_i(x-\\mu)]^T[e_i(x-\\mu)]}{C_2}=1$$这是p维的类似椭圆的方程，当p=2时这就是椭圆方程。\n这意味着，概率密度等高线是同样有着长轴和短轴。\n因而，这意味着如果我们将原始变量X进行正交变换将坐标轴旋转到长轴上就可以达成我们的目标将一个群体之间的不同个体距离拉远。\n演算 接下来，我们有了方向就可以进行推演了。\n我们要将原始变量X进行正交变换得到新的一组变量，这从几何看就是进行坐标轴旋转。\n总之，从代数角度看就是，设p维随机向量X=$(x_1,x_2,\u0026hellip;,x_p)$的协方差阵为$\\Sigma$。\n那么我们就是要找一组新的变量Z=$(z_1,z_2,\u0026hellip;,z_p)$使得（新变量被称为主成分）\n$$z_1=a_{11}x_1+a_{12}x_2+...+a_{1p}x_p=a_1^TX$$$$z_2=a_{21}x_1+a_{22}x_2+...+a_{2p}x_p=a_2^TX$$\u0026hellip;\n$$z_p=a_{p1}x_1+a_{p2}x_2+...+a_{pp}x_p=a_p^TX$$而此时，$var(z_j)=a_j^T\\Sigma a_j,cov(z_j,z_k)=a_j^T\\Sigma a_k$\n我们前面说了，我们希望将一个群体之间的不同个体距离拉远，也就是要最大化新变量Z的方差，与此同时我们自然希望各个新变量之间无关也就是：\n最大化$var(z_j)$，希望$cov(z_j,z_k)=0$\n对于$z_1$来说就是希望最大化$a_1^T\\Sigma a_1$，但是显然我们可以通过无限扩大$a_1$的长度来实现最大化$z_1$的方差，这是我们不期望看到的。\n所以我们再额外要求$z_1$的长度是1即$a_1^Ta_1=1$。\n这样的话其实我们就是在最大化$a_1^T\\Sigma a_1=\\frac{a_1^T\\Sigma a_1}{a_1^Ta_1}$（注意哦，现在分母为1所以除了等于没除）。\n类似地，我们对$z_2$会要求$a_2^Ta_2=1$，并且$cov(z_2,z_1)=a_2^T\\Sigma a_1=0$\n最大化$a_2^T\\Sigma a_2$。\n以此类推，但是到最后一个变量$z_p$我们只能要求最小化$a_p^T\\Sigma a_p$了，因为这个对应的是前面说的高维椭圆的短轴，是最小的。\n那么，怎么进行最小化呢？\n一般的教材这里就是上拉格朗日乘数法了，计算比较复杂我就不说了。给个结论吧。\n$\\forall a \\in R^p,\\Sigma \\in M_p且\\Sigma为对称矩阵。$\n设$(\\lambda_j,e_j)$为$\\Sigma$的特征值、单位特征向量。\n$$a\\neq 0, a⊥e_1,e_2,...,e_{j-1},$$$$max \\frac{a^T\\Sigma a}{a^T a}=\\lambda_j在a=e_j时取到最大。$$ 利用上述结论就可以知道，X的第j个主成分$z_j=e_j^TX$\n且$var(z_j)=e_j^T\\Sigma e_j$\n注意$(\\lambda_j,e_j)$为$\\Sigma$的特征值、单位特征向量。\n所以$\\Sigma e_j =\\lambda_j e_j,e_j^Te_j=1$\n因而$var(z_j)=e_j^T\\Sigma e_j=e_j^T \\lambda_j e_j=\\lambda_j e^T_je_j=\\lambda_j$。\n所以，X的第j个主成分$z_j$是其协方差矩阵$\\Sigma$的第j个单位特征向量乘以原始变量X，并且第j个主成分的方差就是$\\Sigma$第j个特征值$\\lambda_j$。\n这就是主成分分析的结论。\n更进一步的，如果我们对原始变量进行标准化然后再进行主成分分析，可以证明这相当于对原始变量的相关系数矩阵R进行对应的主成分分析。\n降维 从上面的推导我们可以看到对p维向量进行主成分分析只能得到p个主成分，似乎不能降维啊。那么我们一般说的降维是怎么回事？\n前面我们知道，第j个主成分的方差就是$\\Sigma$第j个特征值$\\lambda_j$。\n如果我们将全部的主成分的方差求和，那就是对$\\Sigma$全部的特征值的求和，也就是$\\Sigma$的迹，也就是X各个分量的方差的和。\n所以到现在为止我们还没有损失任何一点点方差。\n如果降维的话就会损失方差了，这是因为所谓的降维就是将各个特征值从大到小排列，然后去掉比较小的特征值和对应的主成分。\n这样的话就会损失方差了，也就损失了部分信息。这就是所谓的利用主成分分析进行降维。\n因子分析 那么因子分析是什么？\n还是看学生成绩数据吧，从学生的成绩上我们可以看到，优秀的学生似乎各科成绩都很好。也许你还会发现，各科成绩高度相关，这意味着他们可能由某一个潜在变量决定（智商）。\n因子分析就是由原始数据寻找这样的潜变量。\n由于潜变量的数量往往少于原始变量的数量，所以因子分析也是一种降维方法。\n因子分析建立了一个因子模型，它认为原始变量Y是各个潜变量的线性组合，即\n$$Y_i=l_{i1}F_1+l_{i2}F_2+...+l_{im}F_m+\\epsilon_i$$其中，$F_j$是潜变量也叫公共因子，我们假设有m个，当然一般要求m不大于原始变量的个数p。\n系数$l_ij$被称为因子载荷，$Y_i$则是原始变量而$\\epsilon_i$是类似误差的特殊因子。\n我们还对公共因子提了一些基础的要求，首先$F_i,F_j$不相关（正交），$F_i,\\epsilon_j、\\epsilon_i,\\epsilon_j$不相关，来保持各个变量之间的独立性。\n当然，因子模型用矩阵表示更简洁，就是\n$Y=AF+\\epsilon$\n那前面说的那些要求用矩阵表示就是：\n$m \\le p$ cov(F,$\\epsilon$)=0 $D_F=var(F)=单位阵I_m$ $D_\\epsilon=var(\\epsilon)=diag(\\sigma_1^2,\\sigma_2^2,\u0026hellip;,\\sigma_p^2) $ 而因子模型最重要的新增是协方差阵的矩阵分解：\n$var(X)=\\Sigma=cov(AF+\\epsilon,AF+\\epsilon)=Acov(F,F)A^{-1}+cov(\\epsilon,\\epsilon)=AA^{-1}+D_\\epsilon$\n演算 那么如何求解因子模型中未知的A和$\\epsilon$呢？\n答案是利用协方差矩阵的矩阵分解：\n$\\Sigma=AA^{-1}+D_\\epsilon$\n而前面我们说过$\\Sigma$可以分解为$Q\\Lambda Q^T$，其中$Q=($e_1,e_2,\u0026hellip;,e_n$)，$$\\Lambda =diag(\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)$\n我们再进行小小的变换，定义$\\Lambda_2=(e_1\\sqrt{\\lambda_1},e_2\\sqrt{\\lambda_2},\u0026hellip;,e_p\\sqrt{\\lambda_p})$，\n则$\\Sigma=\\Lambda_2 \\Lambda_2$。\n当$\\Sigma$的后p-m个特征值很小的时候，我们就可以忽略掉后面的项，用$\\Lambda_2$的前m项估计A，从而$D_\\epsilon=\\Sigma-AA^{-1}$也就可以计算了。\n这就是因子分析的主成分法求解。\n主轴因子法 除此之外因子分析还有一个常用的算法是主轴因子法，推导比较复杂我就只说思路了。\n我们知道\n$\\Sigma=AA^{-1}+D_\\epsilon$\n那么如果我们先估计$D_\\epsilon$在分解也可以得到A。\n总思路是这样的，不过如果你去翻阅各种资料的话，可能还会遇到约相关阵的说法，\n也就是先把原始变量进行标准化从而$\\Sigma=原始变量的相关系数R$再定义$R^*=R-D_\\epsilon=AA^{-1}$，\n然后估计$R^*$再计算A和$D_\\epsilon$也是可以的。\n","date":"2024-11-27T12:09:07+08:00","permalink":"https://ColaBlack.github.io/p/%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/","title":"降维方法 主成分分析和因子分析"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n本期是基于我刚刚完成的SmartCanvas项目简要介绍一下如何在Windows上部署kafka。\n值得一提的是，kafka是一个大数据场景下常用的分布式基于消息订阅模型的开源流处理平台，在SmartCanvas中当做消息队列使用。\n注意看他的定位，大数据场景、分布式等词，其实意味着kafka需要依托于服务器集群环境，所以他正常的操作还是安装在linux集群上，本文在Windows上安装只是安装一个单机的开发时测试用的kafka。\n1.下载kafka安装包 前往kafka官网下载，\n本文选择的是 kafka_2.13-3.9.0.tgz，只需要下载3.9.0\nBinary downloads:\nScala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) 选择下面那个就可以了。\n这里简单说明一下\nSupported releases 支持版本\n3.9.0\nReleased November 6, 2024 发布于 2024 年 11 月 6 日\nRelease Notes 发布说明\nDocker image: apache/kafka:3.9.0. Docker 镜像：apache/kafka:3.9.0.\nDocker Native image: apache/kafka-native:3.9.0. Docker 原生镜像：apache/kafka-native:3.9.0.\nSource download: kafka-3.9.0-src.tgz (asc, sha512) 源代码下载：kafka-3.9.0-src.tgz (asc, sha512)\nBinary downloads:\n二进制下载：\nScala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.12 - kafka_2.12-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) Scala 2.13 - kafka_2.13-3.9.0.tgz (asc, sha512) We build for multiple versions of Scala. This only matters if you are using Scala and you want a version built for the same Scala version you use. Otherwise, any version should work (2.13 is recommended).\n我们为多个版本的 Scala 进行构建。这只有在您使用 Scala 并且希望使用与您使用的相同 Scala 版本构建的版本时才重要。否则，任何版本都应该可以工作（推荐使用 2.13）。\nkafka 3.9.0在官网上是的这样的，\n额，下面的中文官网是没有的，是已经翻译之后的。\nkafka提供了三种下载方式，通过docker镜像可以一键安装部署。\n通过源代码下载，你将获得kafka的源代码，你可以自行编译。\n下面的二进制下载则是打包后能直接运行的应用程序，我们这次就是选择的这个方式。\n但是你会看到二进制下载有两种，什么2.12 2.13之类的。\n这是scala的版本，kafka是基于scala构建的所以这里有不同版本的scala编译的程序。\n虽然kafka是基于scala构建的，但scala和kotlin类似也是一门jvm语言，所以你运行的话只需要准备java环境就可以了不需要下载scala。\n总结：下载kafka安装包，准备java运行环境即可。\n2.解压 额，就是字面意思，解压压缩包就可以了。\nWindows不用教了吧，下个什么7-zip，bandizip之类的解压就可以了。\nlinux命令也不难，\n1 tar -zxvf 压缩包目录 -C 解压目录 解压完我个人的习惯是把解压目录改名成kafka，这个随意不是必须做的。\n3.进行配置 我这次选择在Windows上部署kafka，主流方式是部署在linux上啦，其实都一样的。\n但是部署在linux上一般不需要进行下面的配置：\n先建一个文件夹用来存放kafka的日志。\n然后进入kafka\\config用vim或记事本打开里面的server.properties。\n找到62行\nlog.dirs=/tmp/kafka-logs\n这是日志文件的地址，很显然这不是Windows文件系统应该有的地址。\n现在换成你刚刚建的文件夹的位置。\n但是注意，要把路径的单斜杠\\重复一遍进行转义，即把\\换成 \\\\\n接下来的步骤，不管部署在Windows还是linux上都要进行处理。\n找到34行\nlisteners=PLAINTEXT://:9092\n这是是kafka的地址，改成\n1 listeners=PLAINTEXT://localhost:9092 这样kafka就会监听本地9092端口了。\n这是我配置完之后的配置文件，可以给你参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 # Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright ownership. # The ASF licenses this file to You under the Apache License, Version 2.0 # (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # This configuration file is intended for use in ZK-based mode, where Apache ZooKeeper is required. # See kafka.server.KafkaConfig for additional details and defaults # ############################# Server Basics ############################# # The id of the broker. This must be set to a unique integer for each broker. broker.id=0 ############################# Socket Server Settings ############################# # The address the socket server listens on. If not configured, the host name will be equal to the value of # java.net.InetAddress.getCanonicalHostName(), with PLAINTEXT listener name, and port 9092. # FORMAT: # listeners = listener_name://host_name:port # EXAMPLE: # listeners = PLAINTEXT://your.host.name:9092 #listeners=PLAINTEXT://:9092 listeners=PLAINTEXT://localhost:9092 # Listener name, hostname and port the broker will advertise to clients. # If not set, it uses the value for \u0026#34;listeners\u0026#34;. #advertised.listeners=PLAINTEXT://your.host.name:9092 # Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details #listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL # The number of threads that the server uses for receiving requests from the network and sending responses to the network num.network.threads=3 # The number of threads that the server uses for processing requests, which may include disk I/O num.io.threads=8 # The send buffer (SO_SNDBUF) used by the socket server socket.send.buffer.bytes=102400 # The receive buffer (SO_RCVBUF) used by the socket server socket.receive.buffer.bytes=102400 # The maximum size of a request that the socket server will accept (protection against OOM) socket.request.max.bytes=104857600 ############################# Log Basics ############################# # A comma separated list of directories under which to store log files log.dirs=D:\\\\softwareLocate\\\\kafka\\\\logs # The default number of log partitions per topic. More partitions allow greater # parallelism for consumption, but this will also result in more files across # the brokers. num.partitions=1 # The number of threads per data directory to be used for log recovery at startup and flushing at shutdown. # This value is recommended to be increased for installations with data dirs located in RAID array. num.recovery.threads.per.data.dir=1 ############################# Internal Topic Settings ############################# # The replication factor for the group metadata internal topics \u0026#34;__consumer_offsets\u0026#34; and \u0026#34;__transaction_state\u0026#34; # For anything other than development testing, a value greater than 1 is recommended to ensure availability such as 3. offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 ############################# Log Flush Policy ############################# # Messages are immediately written to the filesystem but by default we only fsync() to sync # the OS cache lazily. The following configurations control the flush of data to disk. # There are a few important trade-offs here: # 1. Durability: Unflushed data may be lost if you are not using replication. # 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush. # 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks. # The settings below allow one to configure the flush policy to flush data after a period of time or # every N messages (or both). This can be done globally and overridden on a per-topic basis. # The number of messages to accept before forcing a flush of data to disk #log.flush.interval.messages=10000 # The maximum amount of time a message can sit in a log before we force a flush #log.flush.interval.ms=1000 ############################# Log Retention Policy ############################# # The following configurations control the disposal of log segments. The policy can # be set to delete segments after a period of time, or after a given size has accumulated. # A segment will be deleted whenever *either* of these criteria are met. Deletion always happens # from the end of the log. # The minimum age of a log file to be eligible for deletion due to age log.retention.hours=168 # A size-based retention policy for logs. Segments are pruned from the log unless the remaining # segments drop below log.retention.bytes. Functions independently of log.retention.hours. #log.retention.bytes=1073741824 # The maximum size of a log segment file. When this size is reached a new log segment will be created. #log.segment.bytes=1073741824 # The interval at which log segments are checked to see if they can be deleted according # to the retention policies log.retention.check.interval.ms=300000 ############################# Zookeeper ############################# # Zookeeper connection string (see zookeeper docs for details). # This is a comma separated host:port pairs, each corresponding to a zk # server. e.g. \u0026#34;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\u0026#34;. # You can also append an optional chroot string to the urls to specify the # root directory for all kafka znodes. zookeeper.connect=localhost:2181 # Timeout in ms for connecting to zookeeper zookeeper.connection.timeout.ms=18000 ############################# Group Coordinator Settings ############################# # The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance. # The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms. # The default value for this is 3 seconds. # We override this to 0 here as it makes for a better out-of-the-box experience for development and testing. # However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup. group.initial.rebalance.delay.ms=0 4.安装zookeeper 接下来，似乎可以直接启动kafka了，但是你想得美嘞。\n再次重复一下kafka的地位，大数据场景下常用的分布式基于消息订阅模型的开源流处理平台，\n这意味着kafka需要zookeeper提供分布式协调服务，协调各个kafka集群中的机器，虽然我们只是在安装单机开发测试服务器，但是zookeeper还是少不了。\n前往zookeeper官网，下载安装包，你划到下面就可以看到\nDownload\nApache ZooKeeper 3.9.3 is our current release, and 3.8.4 our latest stable release.\nApache ZooKeeper 3.9.3\nApache ZooKeeper 3.9.3(asc, sha512)\nApache ZooKeeper 3.9.3 Source Release(asc, sha512)\n在这里，我选择下载zookeeper 3.9.3\n点击Apache ZooKeeper 3.9.3(asc, sha512)这个链接就可以了。\nWe suggest the following location for your download:\nhttps://dlcdn.apache.org/zookeeper/zookeeper-3.9.3/apache-zookeeper-3.9.3-bin.tar.gz\nAlternate download locations are suggested below.\nIt is essential that you verify the integrity of the downloaded file using the PGP signature ( .asc file) or a hash ( .md5 or .sha* file).\n然后你会看到这样的页面，点击上面的链接，https://dlcdn.apache.org/zookeeper/zookeeper-3.9.3/apache-zookeeper-3.9.3-bin.tar.gz就可以下载到zookeeper安装包了。\n然后找个地方解压就可以了。\n再对zookeeper进行配置，应该轻车熟路了。\n进入zookeeper\\conf找到zoo.cfg用vim或记事本打开，\n直接给你看我的配置文件，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=D:\\\\softwareLocate\\\\zookeeper\\\\data dataLogDir=D:\\\\softwareLocate\\\\zookeeper\\\\log # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to \u0026#34;0\u0026#34; to disable auto purge feature #autopurge.purgeInterval=1 ## Metrics Providers # # https://prometheus.io Metrics Exporter #metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider #metricsProvider.httpHost=0.0.0.0 #metricsProvider.httpPort=7000 #metricsProvider.exportJvmInfo=true 你要配置的是12和13行，配置zookeeper数据文件夹和zookeeper日志文件夹，找个地方新建出这两个文件夹然后把路径换成你自己的即可。\ndataDir=D:\\\\softwareLocate\\\\zookeeper\\\\data dataLogDir=D:\\\\softwareLocate\\\\zookeeper\\\\log\n5.启动zookeeper 接下来，我们终于可以启动zookeeper和kafka了。\n我们要先启动zookeeper。\n进入zookeeper\\bin文件夹，找到zkServer.cmd（对linux系统，找到zkServer.sh），然后打开cmd等终端。\n如果你不知道怎么打开终端的话，对linux你还能不知道也是神人了。\n对于Windows系统，你去文件资源管理器的地址栏，输入cmd回车即可。\n在终端中输入zkServer.cmd的文件名再按回车\n1 zkServer.cmd 就可以启动zookeeper了。\n6.启动kafka 然后我们来启动kafka。\n启动kafka就是启动\nkafka\\bin\\windows\\kafka-server-start.bat\n但是我们还得指定刚刚设置的配置文件，所以我的建议是你去kafka\\bin目录，打开cmd输入\n1 bin\\windows\\kafka-server-start.bat config\\server.properties 并按回车。\n解析一下这个命令，命令的前一半是指定到了当前目录下的bin目录下的windows里面的kafka-server-start.bat文件。\n后一半类似，指定了我们刚刚书写的配置文件。\n只需要稍等片刻，kafka就会启动完成了。\n7.跑一个小demo 这里我选择复用smartCanvas项目的代码，\n由于这是一个spring boot项目所以这里选择使用spring-kafka来操作kafka。\n首先安装依赖：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.kafka\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-kafka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 然后前往application.yml进行设置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 spring: kafka: bootstrap-servers: \u0026#34;kafka服务器地址\u0026#34; producer: # 消息生产者key和value序列化器，这里是字符串序列化器 key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer # 类似地，这里是消费者key和value序列化器 consumer: key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer group-id: \u0026#34;使用者组名称\u0026#34; 然后在消息生产者处注入kafkaTemplate操作kafka。\n1 2 @Resource private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; 然后将消息发送出去。\n1 kafkaTemplate.send(\u0026#34;smartCanvas_genChartByAI\u0026#34;, JSONUtil.toJsonStr(chart)); 这里的\u0026quot;smartCanvas_genChartByAI\u0026quot;是kafka中的话题（topic）的名称。\nJSONUtil.toJsonStr(chart)是一个字符串，这个就是消息生产者产生的消息。\n消息生产者代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Resource private ChartService chartService; //接口依赖的其他服务 @Resource private UserService userService; //接口依赖的其他服务 @Resource private AiService aiService; //接口依赖的其他服务 @Resource private RedissonUtils redissonUtils; //接口依赖的其他服务 @Resource private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; /** * 智能分析（异步） * * @param file 上传的文件 * @param requestDTO 智能分析请求 * @param request 请求 * @return 智能分析结果 */ @PostMapping(\u0026#34;/gen/async\u0026#34;) public BaseResponse\u0026lt;GenResultVO\u0026gt; genChartAsyncByAi(@RequestPart(\u0026#34;file\u0026#34;) MultipartFile file, GenChartByAiRequest requestDTO, HttpServletRequest request) { chartService.validGenChartParams(file, requestDTO); User user = userService.getLoginUser(request); try { redissonUtils.limitRate(\u0026#34;smartCanvas_genChartByAI_async_\u0026#34; + user.getId(), 2L); } catch (BusinessException e) { throw new BusinessException(ErrorCode.TOO_MANY_REQUESTS_ERROR, \u0026#34;请求过于频繁，请稍后再试\u0026#34;); } String data = ExcelUtils.excelToCsv(file); Chart chart = Chart.builder() .chartData(data) .chartName(requestDTO.getChartName()) .chartType(requestDTO.getChartType()) .goal(requestDTO.getGoal()) .createrId(user.getId()) .status(ChartStatusEnums.PROCESSING.getValue()) .execmsg(ChartStatusEnums.PROCESSING.getDesc()) .build(); chartService.save(chart); //提交给kafka消息队列 kafkaTemplate.send(\u0026#34;smartCanvas_genChartByAI\u0026#34;, JSONUtil.toJsonStr(chart)); return ResultUtils.success(new GenResultVO(null, \u0026#34;\u0026#34;, \u0026#34;{}\u0026#34;, ChartStatusEnums.PROCESSING.getValue(), ChartStatusEnums.PROCESSING.getDesc())); } 然后是消息的消费者，\n只需要给消息的消费者方法增加注解@KafkaListener(topics = {\u0026quot;要接受消息的topic名称\u0026quot;})即可。\n在smartCanvas中是这样实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package cn.cola.smartcanvas.service.impl; import cn.cola.smartcanvas.model.enums.ChartStatusEnums; import cn.cola.smartcanvas.model.po.Chart; import cn.cola.smartcanvas.model.vo.GenResultVO; import cn.cola.smartcanvas.service.AiService; import cn.cola.smartcanvas.service.ChartService; import cn.cola.smartcanvas.service.KafkaService; import cn.hutool.json.JSONUtil; import lombok.extern.slf4j.Slf4j; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Service; import javax.annotation.Resource; /** * 卡夫卡服务实现类 * * @author ColaBlack */ @Service @Slf4j public class KafkaServiceImpl implements KafkaService { @Resource private AiService aiService; @Resource private ChartService chartService; /** * 智能分析任务 * * @param record 消息记录 */ @Override @KafkaListener(topics = {\u0026#34;smartCanvas_genChartByAI\u0026#34;}) public void genResultTask(ConsumerRecord\u0026lt;String, String\u0026gt; record) { if (record == null || record.value() == null) { log.error(\u0026#34;kafka 中消息记录为空\u0026#34;); return; } GenResultVO resultVO; Chart chart = JSONUtil.toBean(record.value(), Chart.class); String chartData = chart.getChartData(); String goal = chart.getGoal(); String chartType = chart.getChartType(); if (chartType == null) { chartType = \u0026#34;任意统计图\u0026#34;; } try { resultVO = aiService.genResult(goal, chartType, chartData); resultVO.setId(chart.getId()); } catch (Exception e) { log.error(\u0026#34;智能分析异常\u0026#34;, e); chart.setStatus(ChartStatusEnums.FAILED.getValue()); chart.setExecmsg(ChartStatusEnums.FAILED.getDesc()); chartService.updateById(chart); return; } chart.setGeneratedChart(resultVO.getOption()); chart.setAnalyzedResult(resultVO.getResult()); chart.setStatus(ChartStatusEnums.SUCCESS.getValue()); chart.setExecmsg(ChartStatusEnums.SUCCESS.getDesc()); chartService.updateById(chart); } } @Service注解将消息消费者注册为spring bean，然后genResultTask就是真正的处理消息的方法。\nConsumerRecord\u0026lt;String, String\u0026gt; record的record的value就是消息生产者产生的消息了。\n在smartCanvas项目里，是通过将消息反序列化为java对象再进行下一步业务逻辑处理的。\n1 Chart chart = JSONUtil.toBean(record.value(), Chart.class); ","date":"2024-11-25T20:35:35+08:00","permalink":"https://ColaBlack.github.io/p/windows%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2kafka%E5%92%8Czookeeper/","title":"Windows如何部署kafka和zookeeper"},{"content":"初次发布于我的个人文档。（每次都是个人文档优先发布哦）\n在上次我们以浏览器的事件循环为例简要介绍了如何调度异步资源，这一次要来填个坑，介绍一下浏览器是如何渲染页面的。没看过上一期的话就先看一下上一期的开头，了解一下浏览器的多进程图景。\n1.解析HTML 在上一期我们讲到，浏览器的页面由渲染进程完成，在这一期你将看到渲染进程是一个包含了渲染主线程等多个线程的进程。\n当浏览器通过网络进程向服务器发送请求得到响应的HTML文本后，他要做的第一个工作就是解析收到的HTML文本。\n对于大部分标签，建立对应的DOM树。对于CSS，建立对应的CSSOM树。\n但是当解析工作遇到link的时候，按道理就需要去下载对应的css，但是我们知道网络IO是一个耗时比较长的过程，所以这个步骤也会阻塞渲染主线程。\n因此，浏览器并不是以这个方式解析的。\n而是先启动一个预解析线程，预先快速\u0026quot;浏览\u0026quot;一下HTML标签，下载HTML文本引用的外部CSS文件和JS文件。\n当渲染主线程遇到一般的标签那就解析成DOM，但是当渲染主线程遇到link引用CSS的时候，渲染主线程将不会等待，直接解析下面的其他内容。（异步）\n那么外部的CSS由谁解析呢？\n由和刚刚说的预解析线程解析。\n那外部JS呢？\nJS比较特殊，现在来讲。\n由于在JS中存在改变DOM树和CSSOM树的可能，所以JS的解析完全由渲染主线程操刀，并且当渲染主线程遇到script标签的时候，它会暂停现有的对HTML的解析（阻塞），等待预解析线程把对应的JS代码下载好，并且需要等到全局代码都被解析执行完成之后才继续解析HTML文本。\n总之，解析过程就是得到DOM和CSSOM的过程，此时的CSSOM已经是一个包含浏览器默认样式、内部样式、外部样式、行内样式的比较完整的树结构了。\n2.样式计算 之所以说是“比较完成的树”是因为此时CSSOM里还保留着em等相对值和计算属性，这一步就是将这些相对值和计算属性计算出来。\n计算之后的就是最终样式computed style了。\n非常简单，不需要多说什么其他话了。\n3.布局 第三步是根据前面的信息对页面进行布局，生成布局树。\n在这一步渲染主线程要遍历全部的DOM，计算他们的位置信息和几何信息。\n但是注意，布局树和DOM树并不完全一致。\n对于CSS为display:none的元素，由于他们不显示，所以不会在布局树中。DOM中不存在伪元素节点，但我们知道伪元素节点都有几何信息所以他们存在于布局树中。\n由于存在规定\n内容必须在行盒中\n行盒和块盒不能相邻\n所以，在布局这一步还会生成一些匿名的行盒或者块盒来使得页面满足这一规则。\n4.分层 接下来，渲染主线程会对布局树的元素进行分层。这是一个优化的方法，当将来某一层改变后就只需要对这一层的元素进行对应改变就可以了，这将提高浏览器的性能。\n5.绘制 接下来，绘制这一步就是为每一层生成对应的绘制指令，你可以理解为canvas之类的东西。\n啊，什么把画笔移动到哪里哪里，然后向哪里哪里花一条直线什么的。\n到生成绘制指令这一步，渲染主线程的任务才算结束。\n6.分块 接下来压力给到了合成线程。啊，其实也不全是。\n分块的工作要交给很多个被称为分块器的线程协作完成。\n所谓分块就是字面意思，将每一层的元素分为若干小块，以便后续步骤的分工。\n7.光栅化 一看到光栅化这个词已经有人在瑟瑟发抖了吧，其实很简单的。\n就是把前面分的每一块变成位图。\n或者说，合成线程会将每一个块的信息交给显卡（GPU）进程来绘制我们真正能看到的图像。\n当然GPU进程会开多个线程来同时绘制图像，并且它将优先计算靠近视口的块，因为用户正在看那里嘛。\n8.绘制 这一步是最后一步了。\n合成线程在拿到GPU渲染的一张张位图后，将生成指引（quad）信息，标注出每个位图应该画在屏幕的哪个位置，要不要进行选择和缩放等。\nCSS中的transform正是也只是作用于这一阶段，这也是其运行效率高的本质原因。\n当生成指引信息后，合成线程会将指引信息传递给GPU进程，然后GPU进程会产生系统调用操作显卡硬件绘制用户真正能看到的页面图像。\n9.后记 这就是浏览器渲染一个页面的全部步骤了。\n了解这个或许没有什么用，额可能吧。\n不过可以让你小心一点。\n有一些操作会影响布局树，这时浏览器会从第三步重新开始后面的全部过程了，这被称为回流/重排(reflow)，如果可以的话应该尽量避免这样的操作。\n当然，当你连续多次进行修改布局树的操作，浏览器会进行优化，自动合并这些操作，等对应的JavaScript代码全部完成后才统一进行一次reflow。\n但是这也意味着，这时JavaScript获取的布局属性可能是不准确的，为了避免这种情况，当JavaScript代码尝试获取布局属性的时候浏览器会立刻进行reflow操作而不是等待代码全部运行完成。所以这种情况也应该规避。\n而当你改变了DOM的几何信息的时候，浏览器就需要从绘制这一步重新开始，这一过程被称为重绘(repaint)。\n这个效率会比reflow高一些，因为reflow是从第三步布局开始，也会经历完repaint经历的全部过程。（也有说法称reflow会引起repaint，从结果上看两种说法没有任何区别，你怎么理解都可以）\n但是还得是transform高效啊，只影响了最后一步绘制，只有合成线程受到影响了而已，这效率高的不是一点半点啊。\n","date":"2024-11-23T16:28:26+08:00","permalink":"https://ColaBlack.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/","title":"浏览器是如何渲染页面的"},{"content":"初次发布于我的个人文档\n参考:\nchromiun官方文档\nw3c官方文档\n针对一个异步的程序应该如何对它进行资源的调度呢？本文以浏览器为典型范例进行简单介绍。\n1.查看浏览器的多进程图景 打开任意一个浏览器这里以edge为例。\n然后打开Windows的任务管理器，你看到的可能是这样：\n事实上，在edge浏览器（其他浏览器也有类似的功能）按shift+esc键能打开浏览器内部的任务管理器，可能长这样：\n不管怎么样总之，都可以看到你打开了一个浏览器实际上打开了好多个“进行中的程序”也就是进程。\n浏览器作为及其复杂的而又非常常用的程序，不得不使用多进程的方式优化。\n而正是因为浏览器使用了多进程，所以有的时候你会发现，某一个网页卡了但是浏览器没有卡死，一个页面卡死了但是另一个页面没有卡死。这是因为他们本来就“不是一个程序”。\n多进程是一种充分利用计算机硬件资源的方式，关于多进程、多线程和协程的有关概念以后有时间也许会分享。\n总而言之言而总之，浏览器是一个多进程的复杂的应用程序。\n浏览器的诸多线程里，最主要的是三个：\n浏览器进程负责浏览器界面的展示（不是网页，而是浏览器界面内的什么选项卡啊按钮啊什么的）、用户交互、子进程管理等等\n网络进程负责启动多个线程来执行网络任务，也就是收发各种网络请求。\n渲染进程才是负责网页渲染的，有时间也会展开说说浏览器是如何渲染网页的。 渲染进程是浏览器最重要也是最繁忙的进程，说他重要是因为我打开浏览器最主要的就是想看页面啊，没渲染进程怎么能行？说他繁忙，可以等以后展开。\n2.阻塞和非阻塞、同步和异步 刚刚我们说渲染进程是浏览器最重要也是最繁忙的进程，那么渲染进程是怎么组织资源调度和分配的呢？\n比如说，用户点击了一个按钮，我肯定要执行一段代码，但是与此同时可能有一个计时器也刚好到时间了，也想执行一段代码，那怎么办呢？\n进一步的，我怎么知道用户点击了一个按钮呢？是不是我得一直监听用户输入啊，那我岂不是要开一个任务一直运行着，那我渲染进程岂不是还得等用户点击按钮用户有输入了才能继续执行？\n这种现象被称为阻塞。\n也就是这个任务会卡着某一个线程，这个线程要等这个任务完成才能继续执行代码。\n我们写的一般的代码是不会卡着线程的，比如什么i++啊之类的，一下子就完成了所以不会阻塞。\n那如果我想做一些网络交互啊，磁盘输入输出（input/output,IO)之类的，那时间就长了，主线程就得等这些任务完成才能继续执行了，这就是阻塞了。\n再比如，下面的Python代码\n1 2 3 a = \u0026#34;hello World\u0026#34; input(\u0026#34;请输入\u0026#34;) print(a) 第二行在等待用户输入，如果用户一直不输入那么程序不会停止也不会运行第三个语句，而是会一直等待用户输入，用术语来讲就是阻塞。\n像这种，每个任务都按顺序完成的情况我们称之为同步。\n根据刚刚举的例子可以发现，同步的代码可能发生阻塞也可能不发生，我们分别称这两种情况为同步阻塞、同步非阻塞。\n结论：同步不一定阻塞\n不过比起这个结论更重要的是理解刚刚说的分析的过程。\n对于浏览器来说，他确实想执行监听用户的任务，但是又不想阻塞主线程不然用户看到的网页就一卡一卡的。\n那该怎么办呢？\n那就要使用异步的方式。\n这是一个简单的用java(python由于全局解释器锁的存在不太适合当例子了，JavaScript则是运行在浏览器的渲染主线程上也不太适合)实现的异步调用demo。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class CallbackThreadExample { // 定义一个回调接口 interface Callback { void onFinish(String result); } // 实现Runnable接口的类 static class Task implements Runnable { private final Callback callback; public Task(Callback callback) { this.callback = callback; } @Override public void run() { // 执行一些任务 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } // 任务完成，调用回调函数 if (callback != null) { callback.onFinish(\u0026#34;任务完成\u0026#34;); } } } public static void main(String[] args) { // 创建一个回调对象 Callback callback = result -\u0026gt; System.out.println(\u0026#34;回调函数被调用，结果：\u0026#34; + result); // 创建并启动新线程 Thread thread = new Thread(new Task(callback)); thread.start(); // 主线程可以继续执行其他任务 System.out.println(\u0026#34;主线程继续执行...\u0026#34;); } } callback被称为回调函数，简单说就是“回头再调用\u0026quot;。\nmain函数里定义了回调函数 Callback callback = result -\u0026gt; System.out.println(\u0026quot;回调函数被调用，结果：\u0026quot; + result);\n就是说等时机成熟，你给我调用这句输出语句。\ntask类定义了一个任务，叫线程睡眠2秒，然后再调用回调函数。（你看，回调函数是不是“回头再调用了”）\n很显然，task任务会阻塞主线程2秒，我们不希望这件事发生。所以新开了另一个线程来执行这个任务，这样主线程就可以继续执行了，也就不会阻塞了。\n这就是异步非阻塞。\n创建新线程执行原本会阻塞的任务，利用回调函数给予反馈是异步的一种实现方式。前面我们说同步的程序所有任务会按顺序完成，但这里异步的任务会和主线程同时完成，这就是异步和同步的区别。\n3.消息队列 那么浏览器是怎么处理纷繁复杂的异步任务的呢？\n熟悉JavaScript的话你会发现，像网络IO，交互，计时器等都是也只能按异步+回调的方式调用。那浏览器会在什么时候执行回调呢？\n如果网络IO完成的同时，计时器时间也到了应该先完成哪个？\n很快你会发现，这是一个任务生产的速率大于任务消费的速率的情况，这种模型我们一般可以通过排队的方式解决。\n你们俩同时想我启用某个任务了是吧，一个任务正在进行另外两个任务也想启动是吧，排队！\n队列这种数据结构就是现实里的排队，讲究的是先到先得。\n在我们这种情况下，用面向对象的术语来说就是需要一个消息队列，当一个任务想执行了，先往消息队列里发一个消息，我想执行某某任务，然后渲染主线程会先服务队首也就是排在最前面的人。\n4.事件循环 在浏览器具体实现的时候，又有一些细节需要注意。\n我们以谷歌chromiun内核为例，观察chromiun的源码，你会发现在chromiun渲染进程中存在一个死循环（这个循环被W3C称为事件循环在chromiun源码中被称为消息循环)，它不断地从消息队列中取任务，当消息队列为空时会休眠，只要队列里有任务就执行队首的任务，是吗？\n是也不完全是。\n对于一般的简单程序来说也许这样就足够了，但是对浏览器这个复杂的应用程序来说，完全不够！\n浏览器中有事件交互、网络IO等诸多异步任务，很显然事件交互的优先级要高一些，也就是当用户点击按钮啊什么的你浏览器必须尽快给出响应，不要让用户觉得卡顿。\n但是这样的话就破坏了消息队列“先进先出，先到先得”的特性，又该怎么办呢？\n5.微队列和宏队列 动动你的脑瓜子想想，虽然队列里的成员不能有优先级，只能先到先得，但是消息队列不是可以有优先级吗？\n我开好几个不同优先级的消息队列不就得了。\n如果你看过很多早期的教程或者早期w3c规范，你可能会听说过微队列和宏队列的说法，但是随着浏览器执行任务的复杂，w3c已经不再使用宏队列的说法了。（微队列仍在使用）光靠微队列和宏队列已经不足以支撑现代浏览器的资源调度了。\n现代浏览器有微队列、交互队列、延时队列等诸多消息队列。\n按照w3c最新的规范，微队列是优先级最高的队列，当渲染主进程完成手头现有的工作后只要微队列有任务在等着，那么他就会执行微队列的任务。这是因为微队列里都是一些支撑浏览器运行的重要任务。交互队列由于和用户体验息息相关所以优先级也比较高。像延时队列这种只关乎计时器的消息队列优先级就比较低，如果微队列的任务和交互队列的任务没有完成，那即使计时器到了，计时器的回调函数也不会被执行。这也是为什么计时器其实不能严格准确精准无误地按照程序员设定的时间执行任务。\n前面我们说“微队列里都是一些支撑浏览器运行的重要任务”其实也并不完全吧，我们还是有办法把一个函数添加到微队列的，可以通过以下代码\n1 Promise.resolve().then(函数) 将函数包装成任务，塞到微队列。\n翻看chromiun内核源码你会知道，这些消息队列里存放的不是函数句柄（或者说指向函数的指针）而是一个被包装起来的结构体，所以这里要用“包装成任务”的说法。\n","date":"2024-11-15T21:07:57+08:00","permalink":"https://ColaBlack.github.io/p/%E5%BC%82%E6%AD%A5%E4%B8%8E%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6-%E4%BB%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%BA%E4%BE%8B/","title":"异步与资源调度 以浏览器事件循环为例"},{"content":"初次发布于我的个人文档\n1.安装 使用如下的命令之一就可以获取工程费的phaser项目。\n1 2 3 4 5 npm create @phaserjs/game@latest npx @phaserjs/create-game@latest yarn create @phaserjs/game pnpm create @phaserjs/game@latest bun create @phaserjs/game@latest 或者使用\n1 npm install phaser 安装npm包在其他项目使用。\n也可以使用\n1 2 3 4 \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.86.0/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.86.0/phaser.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这些方式从cdn获取源码。\n或者，按照本文的方式，从github直接下载源码在本地使用。\n前往其github仓库下载dist目录下的phaser.js然后导入自己的项目中。\n例如\n1 \u0026lt;script src=\u0026#34;js/phaser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2.预加载资源 接下来以本人模仿的玩具项目google-dinosaur为例介绍如何使用phaser.js制作简单的小游戏。\n首先需要先创建一个游戏场景类，在构造函数中声明场景的名称。\n1 2 3 4 5 export default class PreLoad extends Phaser.Scene { constructor() { super(\u0026#34;preLoadScene\u0026#34;); } } 当进入场景时phaser.js会先调用场景的preload方法。\n在preload方法中调用以下两个函数就可以预加载音乐和图片资源。\n1 2 this.load.audio(\u0026#34;音乐名称\u0026#34;, \u0026#34;音乐地址\u0026#34;); this.load.image(\u0026#34;图片名称\u0026#34;, \u0026#34;图片地址\u0026#34;); 而对于动画，我们只需要提供几个关键帧的图片，phaser.js会自动绘制动画，这种我们称之为精灵表单对象。使用这样的方法载入：\n1 2 3 4 5 this.load.spritesheet( \u0026#34;关键帧的名称\u0026#34;, \u0026#34;关键帧的地址\u0026#34;, {关键帧信息，如关键帧的大小等} ); 接下来phaser.js会调用create方法创建场景，在google-dinosaur项目中，create方法用于跳转到gameScene场景。\n1 this.scene.start(\u0026#34;gameScene\u0026#34;); 最后，给一下第一个场景的完整代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * 在游戏开始前预加载资源 */ export default class PreLoad extends Phaser.Scene { constructor() { super(\u0026#34;preLoadScene\u0026#34;); } preload() { // 加载背景音乐 // 死亡音效 this.load.audio(\u0026#34;dead\u0026#34;, \u0026#34;./assets/audio/Dead.wav\u0026#34;); // 跳跃音效 this.load.audio(\u0026#34;jump\u0026#34;, \u0026#34;./assets/audio/Jump.wav\u0026#34;); // 得分音效 this.load.audio(\u0026#34;score\u0026#34;, \u0026#34;./assets/audio/Score.wav\u0026#34;); // 加载图片资源 for (let i = 1; i \u0026lt;= 5; i++) { // 5张仙人掌图片 this.load.image(`cactus-${i}`, `./assets/images/Cactus-${i}.png`); } // 地面图片 this.load.image(\u0026#34;ground\u0026#34;, \u0026#34;./assets/images/Ground.png\u0026#34;); // 游戏结束文字图片 this.load.image(\u0026#34;gameover_text\u0026#34;, \u0026#34;./assets/images/Gameover_text.png\u0026#34;); // 再玩一次按钮图片 this.load.image(\u0026#34;replay_button\u0026#34;, \u0026#34;./assets/images/Replay_button.png\u0026#34;); for (let i = 1; i \u0026lt;= 4; i++) { // 4张小恐龙图片 this.load.spritesheet( `dinosaur-${i}`, `./assets/images/Dinosaur-${i}.png`, { frameWidth: 88, frameHeight: 94 } ); } } create() { // 切换到游戏场景 this.scene.start(\u0026#34;gameScene\u0026#34;); } } 3.创建场景 在介绍如何创建场景前，我们先写gameScene场景的代码框架，也就是\n1 2 3 4 5 export default class GameScene extends Phaser.Scene { constructor() { super(\u0026#34;gameScene\u0026#34;); } } 由于资源已经在前面预加载完了所以这里不需要预加载资源，我们直接写create方法即可。\n3.1创建游戏对象 在创建场景的时候主要的代码是创建游戏需要的对象，以google-dinosaur项目为例，需要创建地面、小恐龙、仙人掌等对象。\n地面的宽度和游戏画布的宽度一样，高度则位与中间，这意味着我们要先获取画布的高度和宽度。\n1 2 3 // 获取游戏画布的宽度和高度 this.width = this.sys.game.config.width; this.height = this.sys.game.config.height; 地面是静态不动的，对于这种静态的对象要用this.physics.add.staticGroup()方法先创建静态对象组。\n然后创建对象\n1 2 3 4 this.ground .create(this.width / 2, this.height - 13, \u0026#34;ground\u0026#34;) .setScale(2) .refreshBody(); create方法的前两个参数是对象的坐标，在phaser.js中默认的坐标系是从左上角开始,越往右x越大，越往下y越大。（当然，这个是可以自己改的）而这里的坐标默认是以对象的左上角为标准的。(左上角也被称为原点，也是可以自己改动的)\n例如你想把一个图片的左上角放到(0,0)，那就直接在create里输入0,0就可以了。\n\u0026ldquo;ground\u0026quot;是刚刚预加载的图片对象的名字，有这个参数phaser.js才知道刚刚创建的地面对象的贴图是ground。\nsetScale(2)则是将地面放大了2倍,refreshBody()要求phaser.js重新计算刷新地面对象的物理属性。\n对于会运动且有物理碰撞效果的一般的对象，可以用this.physics.add.group()为他们创造组。\n针对精灵表单和其他的一般对象可以用这样的方式创建\n1 2 3 this.dinosaur = this.physics.add .sprite(50, this.height / 2, \u0026#34;dinosaur-1\u0026#34;) .setOrigin(0, 1); dinosaur-1是动画的第一帧或者是对象的贴图。setOrigin则将该对象的原点设置到了x为0%，y为100%也就是对象的左下角了。\n如果要加入碰撞效果呢，就可以用这样的方法\n1 2 // 让小恐龙与地面发生碰撞，防止小恐龙掉落 this.physics.add.collider(this.dinosaur, this.ground); 3.2初始化动画 参考google-dinosaur的代码，\n1 2 3 4 5 6 7 8 9 10 11 12 // 定义恐龙奔跑的动画 this.dinosaur.anims.create({ key: \u0026#34;run\u0026#34;, frames: [ { key: \u0026#34;dinosaur-1\u0026#34; }, { key: \u0026#34;dinosaur-2\u0026#34; }, { key: \u0026#34;dinosaur-3\u0026#34; }, { key: \u0026#34;dinosaur-4\u0026#34; }, ], frameRate: 10, repeat: -1, }); 精灵表单的anims.create方法可以初始化动画，key则给了动画一个名字，叫做run。frames数组则列举了动画需要的关键帧的名字。frameRate是帧速率，repeat则说明了动画需要重复几次，-1表示动画要一直重复。\n3.3初始化音乐 初始化音乐就更简单了。使用this.sound.add(\u0026quot;音乐名称\u0026quot;)就可以了。\n以google-dinosaur为例只要这样就能初始化三个音乐了。\n1 2 3 this.deadSound = this.sound.add(\u0026#34;dead\u0026#34;); this.jumpSound = this.sound.add(\u0026#34;jump\u0026#34;); this.scoreSound = this.sound.add(\u0026#34;score\u0026#34;); 3.4监听用户输入 这里以监听用户键盘输入为例，使用\n1 this.input.keyboard.on(\u0026#34;keydown\u0026#34;, this.handleJump.bind(this), this); keydown表示监听用户的任意键盘输入，也就是用户按任意键就调用handleJump方法。\nhandleJump方法的代码很简单，就不说了。\n1 2 3 4 5 6 7 8 9 10 11 handleJump() { // 如果小恐龙不在地面上，则不执行跳跃以避免用户进行二段跳 if (!this.dinosaur.body.onFloor()) { return; } // 跳跃，设置y的速度为-1500像素每秒(负速度的方向向上) this.dinosaur.setVelocityY(-1500); // 播放跳跃音效 this.jumpSound.play(); } 4.编写每一帧的处理 接下来phaser.js会在游戏的每一帧都调用update函数\n这个部分只有播放精灵表单的动画是通用的。\n1 2 // 播放奔跑动画 this.dinosaur.anims.play(\u0026#34;run\u0026#34;, true); 这个语句就可以播放刚刚初始化的小恐龙奔跑动画。\n其他的语句都不是通用的，我就直接放google-dinosaur的源码给各位参考了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 update(time, delta) { // 播放奔跑动画 this.dinosaur.anims.play(\u0026#34;run\u0026#34;, true); // 检测小恐龙是否跳过仙人掌 this.cactusGroup.getChildren().forEach((cactus) =\u0026gt; { // 如果仙人掌的x坐标小于50且未被计分 if (cactus.x \u0026lt; 50 \u0026amp;\u0026amp; !cactus.getData(\u0026#34;scored\u0026#34;)) { // 标记仙人掌为已计分，避免重复计分 cactus.setData(\u0026#34;scored\u0026#34;, true); // 播放得分音效 this.scoreSound.play(); } }); // 定义计时器，每隔1-5秒生成一个仙人掌 this.timer = this.timer || time; const cactusInterval = Phaser.Math.Clamp( 2000 - this.speed * 100, 500, 2000 ); // 最小间隔为500ms，最大间隔为2000ms if (time - this.timer \u0026gt; cactusInterval) { this.summonCactus(); this.timer = time; } } 5.定义对象交互逻辑 接下来需要游戏其实就已经开始进行了，但是我们还没有定义对象之间的关系和结束游戏的方法。\n例如，在google-dinosaur项目中，当小恐龙和仙人掌碰撞的时候应该停止游戏。\n不过这个你可能得回去修改刚刚写的代码，例如修改增加小恐龙和仙人掌碰撞的代码为\n1 2 3 4 5 6 7 8 // 添加小恐龙与仙人掌组之间的碰撞检测 this.physics.add.collider( this.dinosaur, this.cactusGroup, this.handleDinoCactusCollision, null, this ); 这个代码既增加了二者的碰撞，又定义了当二者碰撞的时候调用handleDinoCactusCollision函数。\n这部分其实也没有通用的代码。\n大致上也就这三个代码比较常用\n1 2 3 4 5 6 7 8 // 播放死亡音效 this.deadSound.play(); // 停止物理模拟 this.physics.pause(); // 停止所有动画 this.anims.pauseAll(); 为了处理google-dinosaur的特殊需求，在该项目里这个函数其实是这样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 handleDinoCactusCollision(dinosaur, cactus) { // 播放死亡音效 this.deadSound.play(); // 停止物理模拟 this.physics.pause(); // 停止所有动画 this.anims.pauseAll(); this.speed = 1; this.score = 0; // 游戏结束时停止得分增加 if (this.scoreEvent) { this.scoreEvent.remove(false); } this.handleGameOver(); } handleGameOver() { // 显示游戏结束文字 const gameOverText = this.add .image(this.width / 2, this.height / 2 - 100, \u0026#34;gameover_text\u0026#34;) .setScale(2); // 显示再玩一次按钮 const replayButton = this.add .image(this.width / 2, this.height / 2 + 100, \u0026#34;replay_button\u0026#34;) .setInteractive() .setScale(2); // 为再玩一次按钮添加点击事件监听器 replayButton.on(\u0026#34;pointerdown\u0026#34;, () =\u0026gt; { this.scene.restart(); // 重新开始当前场景 }); } 6.配置并启动游戏 通过前面的步骤你已经完成了绝大部分代码。接下来只需要配置一下然后就可以启动游戏啦。\n前面的代码就只是定义了两个类，除了一堆定义之外其实没有代码被执行。\n如果想真正地启动游戏，只需要一句话：\n1 2 // 创建游戏实例 const game = new Phaser.Game(config); config是游戏的配置对象，这里以google-dinosaur项目的配置为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 游戏配置 const config = { type: Phaser.AUTO, // 游戏渲染器类型 width: 800,// 游戏画布宽度 height: 300,// 游戏画布高度 backgroundColor: \u0026#34;#ffffff\u0026#34;, //修改背景色为白色 parent: \u0026#34;game\u0026#34;, // 游戏绑定的父标签的id scene: [PreLoad, GameScene], // 游戏场景列表，会先进入第一个场景 physics: { default: \u0026#34;arcade\u0026#34;, // 默认物理引擎 arcade: { gravity: { y: 5000 }, // 重力设置 debug: false, // 调试模式，开发时使用 }, }, }; 每一个配置项我都写了注释，应该可以直接看懂了。\n在这里，游戏渲染器类型你可能不知道是什么意思，其实就是调整游戏是用webGL渲染还是canvas渲染。一般选自动就可以了。\n","date":"2024-11-14T18:59:45+08:00","permalink":"https://ColaBlack.github.io/p/phaser%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E7%9A%842d%E5%B0%8F%E6%B8%B8%E6%88%8Fdemo/","title":"Phaser开发简单的2d小游戏demo"},{"content":"初次发布于我的个人文档\n本文简要介绍一下如何实现一个简化版的类vue的响应式。\n1.假装不知道响应式 如果我们不知道vue等响应式框架，那么又该如何手动实现类似的功能呢？\n先来看这么一个简单的页面\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Program\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;data1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p id=\u0026#34;data2\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;data3\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 现在，如果这里的三个data需要变动，与此同时我们还希望页面进行所谓的“重新渲染”即让页面也跟着数据的变动变化应该怎么做呢？\n首先，要写js代码让这几个标签有内容对吗？\n只需要封装这三个函数即可\n1 2 3 4 5 6 7 8 9 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; 对于旧数据，只需要调用函数传入即可，例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { data1: \u0026#34;Hello World!\u0026#34;, data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; showData1(data); showData2(data); showData3(data); 但是接下来如果要更改data1，你会发现页面并不会变化，除非你重新调用showData1。\n例如，这段代码就实现了3秒后变化data1并使得页面发生变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { data1: \u0026#34;Hello World!\u0026#34;, data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; showData1(data); showData2(data); showData3(data); setTimeout(() =\u0026gt; { data1 = \u0026#34;Welcome to my program.\u0026#34;; showData1(data1); }, 3000); 2.针对特殊变量实现响应式 所以手动实现响应式的关键，就是在改变变量的时候再次调用showData函数。\n然而每次都手动去调用肯定是很麻烦而且不优雅的。\n很容易想到，只要重载对应变量的set方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const showData1 = (data) =\u0026gt; { document.getElementById(\u0026#34;data1\u0026#34;).innerHTML = data.data1; }; const showData2 = (data) =\u0026gt; { document.getElementById(\u0026#34;data2\u0026#34;).innerHTML = data.data2; }; const showData3 = (data) =\u0026gt; { document.getElementById(\u0026#34;data3\u0026#34;).innerHTML = data.data3; }; const data = { _data1: \u0026#34;Hello World!\u0026#34;, // 使用一个下划线前缀来存储data1实际的值 data2: \u0026#34;This is a paragraph.\u0026#34;, data3: \u0026#34;This is another paragraph.\u0026#34;, }; Object.defineProperty(data, \u0026#34;data1\u0026#34;, { get: function () { return this._data1; // 使用存储的实际值 }, set: function (value) { this._data1 = value; // 更新存储的实际值 showData1(value); // 调用showData1来更新页面上的内容 }, }); showData1(data); showData2(data); showData3(data); setTimeout(() =\u0026gt; { data.data1 = \u0026#34;Welcome to my program.\u0026#34;; // 使用新设置的setter }, 3000); 这样就完成了对data1的封装。\n类似地，可以自己手动完成对data2 data3的封装。\n然而，这并不是什么好的选择，自己动手还是太累了。\n3.尝试封装为一般化工具 所以我们要来尝试封装成一般化的工具！\n我们来手写一个封装或者说观察函数，来观察这个对象，为这个对象的所有字段都重写get和set方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; Object.defineProperty(obj, key, { get: function () { return innerValue; }, set: function (value) { innerValue = value; }, }); } } 也就是这样。\n但是接下来你会发现，我们不知道应该调用哪些函数了。\n不妨回过头想想，手动实现的时候你是怎么知道要调用showData1这个函数的。\n我们为什么不把三个showData函数全部调用一遍呢？\n是不是因为showData1这个函数使用了data1这个变量啊，或者说就是这个函数调用了data1的get方法。\n所以，我们应该先重写get方法，记录哪个函数使用了get方法。\n那我怎么知道是哪个函数正在使用get方法呢？\n解决方案是，让这个函数使用get方法前手动在全局变量上记录自己，然后get函数访问全局变量获取信息。\n原本我们的调用是\n1 showData1(data); 现在改为\n1 showData1(data); 接着，data1的get方法只需要访问全局变量window.__func就知道谁正在调用get方法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; let funcs = []; Object.defineProperty(obj, key, { get: function () { if (window.__func \u0026amp;\u0026amp;!funcs.includes(window.__func)) { funcs.push(window.__func); } return innerValue; }, set: function (value) { innerValue = value; }, }); } } 这就实现了依赖收集。\n然后呢，在有函数调用set方法的时候，只需要调用funcs里面的所有函数即可，也就是派发更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function watch(obj) { for (const key in obj) { let innerValue = obj[key]; let funcs = []; Object.defineProperty(obj, key, { get: function () { if (window.__func \u0026amp;\u0026amp;!funcs.includes(window.__func)) { funcs.push(window.__func); } return innerValue; }, set: function (value) { for (let i = 0; i \u0026lt; funcs.length; i++) { funcs[i](); } innerValue = value; }, }); } } 4.设计代理 但是，每次在调用get方法前还要自己手动设置全局变量还是太麻烦。如何把这个过程也自动化呢？\n其实我们就是想加强调用了属性get方法的函数的功能，而由于我们做的是通用组件又不好直接修改函数本身。\n这时，可以建一个新的对象或者函数，由它代理，或者说替代我们访问旧的函数或对象。\n例如\n1 2 3 4 5 function runFunc(func) { window.__func = func; func(); window.__func = null; } 以后，用户想调用func就使用runFunc代理，由runFunc替用户访问func。现在只要用户用这个函数访问func并且设置了被watch的对象，那么就实现了响应式了。\n","date":"2024-11-13T20:05:21+08:00","permalink":"https://ColaBlack.github.io/p/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%AE%80%E5%8C%96/","title":"响应式原理（简化）"},{"content":"初次发布于我的个人文档\n参考：\n1.1Panel 官方文档\n本文介绍一下如何利用1panel部署一个简单的前后端分离项目。\n1,拥有一个Liunx服务器 第一步是购买一个Linux服务器，可以买一台线下真实的机器+公网IP或买一个阿里云、腾讯云、京东云、华为云服务器。\n2.安装1panel 参考1panel官方文档，安装1panel。\n在这里以Ubuntu系统为例，只需运行\n1 curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh \u0026amp;\u0026amp; sudo bash quick_start.sh 即可安装，安装完成后终端上有写1panel的URL和账号名密码。\n3.安装运行环境 在虚拟机中安装java等运行环境。\n然后，可以在1panel中安装项目需要的中间件，如MySQL、minio、redis等。\n4.打包后端项目 先介绍一下如何打包maven项目。\n需要注意的是，你可能会发现在idea的maven菜单里，已经有一个package选项了，然而默认情况下这样打的包是不带项目依赖的。所以这样的jar包不能独立运行。\n但是如果你用的是spring boot项目，则pom.xml中可能已经安装了插件spring-boot-maven-plugin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 如果pom.xml有这样的代码则说明maven有插件spring-boot-maven-plugin。\n这时直接在idea的maven菜单运行package选项就得到带依赖的jar包了，可以直接java -jar运行。\n以部署笔者的teaai项目为例，打包后你会在target文件夹下看到teaai-backend-0.0.1-SNAPSHOT.jar，这就是打包后的jar文件，直接运行即可启动后端服务。\n对于非spring boot项目又该如何打包呢？\n需要安装maven-assembly-plugin插件，方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\u0026lt;!-- 插件版本号 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;edu.zafu.teaai.MainApplication\u0026lt;/mainClass\u0026gt; \u0026lt;!-- 替换为你的主类的完整类名 --\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 然后再运行package即可。\n对于gradle项目，没有什么太大的区别。\n这里只介绍一般的gradle项目如何打带依赖的jar包。\ngradle依赖打包需要安装shadow插件，在build.gradle.kts中的plugins，增加这样的代码：\n1 2 3 plugins { id(\u0026#34;com.gradleup.shadow\u0026#34;) version \u0026#34;8.3.3\u0026#34; } 然后增加shadow任务，同样还是在build.gradle.kts中增加一下代码：\n1 2 3 4 5 6 7 8 9 tasks { shadowJar { archiveBaseName.set(\u0026#34;nocrud\u0026#34;) archiveVersion.set(\u0026#34;\u0026#34;) manifest { attributes[\u0026#34;Main-Class\u0026#34;] = \u0026#34;cn.cola.nocrud.MainKt\u0026#34; } } } 这段代码以笔者的nocrud项目为例，在上面的代码中nocrud是你项目的名称，attributes[\u0026quot;Main-Class\u0026quot;] = \u0026quot;cn.cola.nocrud.MainKt\u0026quot;则规定了主类。\n需要注意的是，如果你的主类是一个kotlin代码，则需要再原本的类名后面加上Kt，这是因为kotlin是一个jvm语言，编译后你会发现kotlin编译器会在所有的kotlin类名称后面加上Kt。\n完成了这些，刷新一下项目，你会发现idea的gradle菜单中新增了一个shadow任务，双击shadowJar命令执行即可打包。\n打包完的jar包在build/libs目录内。\n5.启动后端项目 在1panel-主机-文件中上传打包后的jar包。\n然后到网站-运行环境-java中运行后端项目。\n当然如果你的后端是go语言或php或nodejs那么就去对应的页面。\n本文以java项目为例，选择创建运行环境，设置名称和java sdk版本，将运行目录设置为jar包的上传目录。\n在启动命令一栏输入完整的启动命令，如\n1 java -jar ./teaai-backend-0.0.1-SNAPSHOT.jar 然后注意，1panel和宝塔面板有所不同，1panel的后端项目也是基于容器化部署的，需要填写应用在容器内的访问端口和容器外的端口。\n然后打开端口外部访问并设置容器名称。\n点击确定即可。\n最后提醒一下，因为1panel是容器化部署，而在容器内localhost指向的是容器内部的地址，如果想访问容器网外的本机的其他容器请使用本机的真实内网IP。\n6.部署其他中间件 这里需要根据中间件的不同进行部署，如关系型数据库需要建表等。\n7.打包前端项目 这里以打包teaai项目为例，teaai是一个vue项目。\n用WebStrom打开teaai前端项目，一般而言当你利用vue-cli创建项目时，在package.json中有这样的命令。\n1 \u0026#34;build\u0026#34;: \u0026#34;run-p type-check \\\u0026#34;build-only {@}\\\u0026#34; --\u0026#34;, 你可以直接点击WebStorm左边的运行按钮运行，也可以在终端中输入\n1 npm run build 打包项目。\n当然，如果你用pnpm或yarn等运行这个命令也一样。\n打包后你将在dist目录下看到打包后的结果。\n8.启动前端项目 进入1panel-网站-运行环境-php创建一个php运行环境，拓展模版选择“默认”即可。\n然后去你的DNS服务商配置域名解析（这个因服务商而不同，在此无法演示）。\n接下来进入1panel面板-网站-网站，如果你没有安装OpenResty（你可以理解为nginx增强版）则1panel会提示你安装。\n在网站页面选择创建网站-运行环境-选择刚刚创建的php运行环境\n（如果你的网站是静态网站也可以不创建php运行环境而直接选静态网站）\n输入网站的域名和需要访问的端口号,点击确定。\n你会看到1panel页面的表格中多了一条记录，点击其中的网站目录下的文件夹图标，进入文件界面上传前端打包的dist目录的内容。\n接着。如果要设置代理和https服务的话，回到刚刚的1panel-网站-网站页面，点击网站记录右边的配置，在这里可以对网站进行限流、反向代理、配置HTTPS服务等操作。\n如果开启了https服务，记得在防火墙打开443端口！\n","date":"2024-11-08T19:39:09+08:00","permalink":"https://ColaBlack.github.io/p/%E5%88%A9%E7%94%A81panel%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE-java%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85/","title":"利用1panel部署前后端分离项目 Java代码打包 前端打包"},{"content":"初次发布于我的个人文档\n参考:智谱ai官方文档\n1.安装依赖 在maven 的pom.xml中输入\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.bigmodel.openapi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oapi-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;release-V4-2.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.编写通用AI调用工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package edu.zafu.teaai.utils; import com.zhipu.oapi.ClientV4; import com.zhipu.oapi.Constants; import com.zhipu.oapi.service.v4.model.*; import edu.zafu.teaai.constant.AiConfig; import io.reactivex.Flowable; import java.util.ArrayList; import java.util.List; /** * AI调用模块 * * @author ColaBlack */ public class AiUtils { /** * 业务ID模版 */ private static final String REQUEST_ID_TEMPLATE = \u0026#34;teaAI-request-%s\u0026#34;; /** * AI调用客户端 */ private static final ClientV4 CLIENT = new ClientV4.Builder(AiConfig.API_KEY).build(); /** * 调用AI接口(同步) * * @param prompt 提示词 * @return AI返回的答案 */ public static String aiCaller(String prompt) { List\u0026lt;ChatMessage\u0026gt; messages = new ArrayList\u0026lt;\u0026gt;(); ChatMessage chatMessage = new ChatMessage(ChatMessageRole.USER.value(), prompt); messages.add(chatMessage); String requestId = String.format(REQUEST_ID_TEMPLATE, System.currentTimeMillis()); ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder() .model(AiConfig.MODEL_NAME) .stream(Boolean.FALSE) .invokeMethod(Constants.invokeMethod) .messages(messages) .requestId(requestId) .build(); ModelApiResponse invokeModelApiResp = CLIENT.invokeModelApi(chatCompletionRequest); return invokeModelApiResp.getData().getChoices().get(0).getMessage().getContent().toString(); } /** * 调用AI接口(SSE) * * @author ColaBlack */ public static Flowable\u0026lt;ModelData\u0026gt; aiCallerFlow(String prompt) { List\u0026lt;ChatMessage\u0026gt; messages = new ArrayList\u0026lt;\u0026gt;(); ChatMessage chatMessage = new ChatMessage(ChatMessageRole.USER.value(), prompt); messages.add(chatMessage); String requestId = String.format(REQUEST_ID_TEMPLATE, System.currentTimeMillis()); ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder() .model(AiConfig.MODEL_NAME). stream(Boolean.TRUE). invokeMethod(Constants.invokeMethod) .messages(messages) .requestId(requestId) .build(); ModelApiResponse invokeModelApiResp = CLIENT.invokeModelApi(chatCompletionRequest); return invokeModelApiResp.getFlowable(); } } 3.配置信息 将代码中的AiConfig.MODEL_NAME替换为要使用的模型名称，AiConfig.API_KEY替换为你的API_KEY\n4.调用AI 如果要同步调用AI，那就直接将全部的提示词传入aiCaller方法，耐心等待即可返回结果。\n这里消息的生产速度往往大于消费速度，因此可以考虑介入消息队列MQ。\n同步调用如果一直让用户长时间等待用户体验不好，可以使用流式调用。\n将全部的提示词传入aiCallerFlow方法得到一个Flowable对象。\n为了将AI响应的结果传给前端，可以采用轮询、SSE、WebSocket等方式。这里选择使用SSE将响应由服务端推送给前端。\n这里的代码是传入全部的提示词，返回一个SseEmitter对象给前端，方便前端使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public SseEmitter generateQuestionSSE(String prompt) { // 建立 SSE 连接对象，0 表示不超时 SseEmitter emitter = new SseEmitter(0L); // AI 生成的流式响应结果 Flowable\u0026lt;ModelData\u0026gt; modelDataFlowable = AiUtils.aiCallerFlow(prompt); modelDataFlowable // 指定观察者的线程池 .observeOn(Schedulers.io()) // 从智谱的响应中获取数据 .map(chunk -\u0026gt; chunk.getChoices().get(0).getDelta().getContent()) // 去掉响应中多余的空格 .map(message -\u0026gt; message.replaceAll(\u0026#34;\\\\s\u0026#34;, \u0026#34;\u0026#34;)) // 去掉为空字符串的响应 .filter(StringUtils::isNotBlank) .flatMap(message -\u0026gt; { // 将字符串转换为字符数组以便后续业务处理 List\u0026lt;Character\u0026gt; charList = new ArrayList\u0026lt;\u0026gt;(); for (char c : message.toCharArray()) { charList.add(c); } return Flowable.fromIterable(charList); }) .doOnNext(c -\u0026gt; { // 进行业务处理 // 然后发送结果，这里为了演示直接不进行处理将给一个字符c都全部如实发送 emitter.send(c); }) //当AI响应完毕时关闭SSE .doOnComplete(emitter::complete) // 订阅AI响应流 .subscribe(); return emitter; } 4.前端接受SSE消息\n这里选择使用原生的方式接收。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const handleSSE = async () =\u0026gt; { // 发送sse请求 const eventSource = new EventSource(REQUEST_URL) //传入请求地址 // 按项目给予用户生产中提示 alert(\u0026#39;生成中，请稍后\u0026#39;) // 开始监听sse消息 eventSource.onmessage = (event) =\u0026gt; { //解析后端推送的消息，这里以后端传JSON字符串为例 const res = JSON.parse(event.data) //进行处理，以追加到form.test为例 form.value.test = [...(form.value.test || []), res] } //处理报错和停止接受 eventSource.onerror = (event) =\u0026gt; { //正常停止接收 if (event.eventPhase === EventSource.CLOSED) { eventSource.close() alert(\u0026#39;生成结束\u0026#39;) } else { //报错记录日志 eventSource.close() console.error(\u0026#39;生成失败\u0026#39;) } } } ","date":"2024-11-04T19:35:19+08:00","permalink":"https://ColaBlack.github.io/p/%E6%99%BA%E8%B0%B1ai-java-sdk%E8%B0%83%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E6%93%8D%E4%BD%9C/","title":"智谱AI java SDK调用（前后端操作）"},{"content":"初次发布于我的个人文档\n参考资料 [FreeMarker官方文档（英文）](Apache FreeMarker Manual)\nFreeMarker 中文官方参考手册\nPicocli官方文档（英文）\npicocli-中文博客\n1.安装依赖 1 2 3 4 // https://mvnrepository.com/artifact/org.freemarker/freemarker implementation(\u0026#34;org.freemarker:freemarker:2.3.33\u0026#34;) // https://mvnrepository.com/artifact/info.picocli/picocli implementation(\u0026#34;info.picocli:picocli:4.7.6\u0026#34;) 2.编写Freemarker demo 参考官方文档，编写一个简单Freemarker的demo，生成一个Java文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import freemarker.template.Configuration import freemarker.template.TemplateExceptionHandler import java.io.File import java.io.OutputStreamWriter fun main() { // 创建配置对象 val config = Configuration(Configuration.VERSION_2_3_33) // 设置模板文件存放的目录 config.setDirectoryForTemplateLoading(File(\u0026#34;src/main/resources/templates\u0026#34;)) // 设置默认的编码格式 config.defaultEncoding = \u0026#34;UTF-8\u0026#34; // 设置异常处理器 config.templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER /* 利用HashMap创建数据模型 { \u0026#34;user\u0026#34;: \u0026#34;Big Joe\u0026#34;, \u0026#34;latestProduct\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/ColaBlack\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;No CRUD\u0026#34; } */ val hashMap = HashMap\u0026lt;String, Any\u0026gt;() hashMap[\u0026#34;user\u0026#34;] = \u0026#34;ColaBlack\u0026#34; val latest: MutableMap\u0026lt;String, Any\u0026gt; = HashMap() hashMap[\u0026#34;latestProduct\u0026#34;] = latest latest[\u0026#34;url\u0026#34;] = \u0026#34;https://github.com/ColaBlack\u0026#34; latest[\u0026#34;name\u0026#34;] = \u0026#34;No CRUD\u0026#34; // 获取模板文件 val template = config.getTemplate(\u0026#34;demo.ftl\u0026#34;) val out = OutputStreamWriter(File(\u0026#34;src/main/java/edu/zafu/generated/demo.java\u0026#34;).outputStream()) // 输出渲染后的内容 template.process(hashMap, out) // 关闭输出流 out.close() } 对应的模版文件demo.ftl如下：\n1 2 3 4 5 6 7 8 9 package edu.zafu.generated; public class demo { public static void main(String[] args) { System.out.println(\u0026#34;Hello ${user}\u0026#34;); System.out.println(\u0026#34;The latest product is ${latestProduct.name}\u0026#34;); System.out.println(\u0026#34;You can find it at ${latestProduct.url}\u0026#34;); } } 将模版文件放入src/main/resources/templates目录下，运行main 函数，将生成的Java文件输出到src/main/java/edu/zafu/generated/demo.java文件中。\n3.编写命令行picocli demo 参考官方文档，编写一个命令行demo，实现一个简单的ls命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import picocli.CommandLine import picocli.CommandLine.* import java.io.File import kotlin.system.exitProcess /** * ls命令demo * * @author ColaBlack */ // 定义一个dir命令，name为ls，description为该命令的描述信息，mixinStandardHelpOptions为true，表示该命令需要自动生成help选项 @Command(name = \u0026#34;dir\u0026#34;, description = [\u0026#34;列出当前目录的目录结构\u0026#34;], mixinStandardHelpOptions = true) // 定义一个dir类，继承Runnable接口，实现run方法，用于执行ls命令，其中Callable的泛型int表示call方法的返回值类型 class Dir : Runnable { // 该参数在命令行中指定，索引为0，description为描述信息 @Parameters(index = \u0026#34;0\u0026#34;, description = [\u0026#34;要列出的目录路径\u0026#34;]) var path: String? = null // 定义一个path变量，用于接收命令行参数 // 该选项缩写为-a，全称为--all，description为描述信息 @Option(names = [\u0026#34;-a\u0026#34;, \u0026#34;--all\u0026#34;], description = [\u0026#34;显示所有文件，包括隐藏文件\u0026#34;]) var showHidden = false // 定义一个showHidden变量，用于接收-a选项，是否显示隐藏文件 // 用户执行命令时，会调用run方法 override fun run() { if (path == null) { println(\u0026#34;文件路径不能为空\u0026#34;) return } val file = File(path!!) if (!file.exists()) { // 判断目录是否存在 println(\u0026#34;文件路径不存在: $path\u0026#34;) return } if (!file.isDirectory) { // 判断是否为目录 println(\u0026#34;$path 不是一个目录\u0026#34;) return } val files = file.listFiles() if (files == null) { // 判断目录是否为空 println(\u0026#34;目录为空\u0026#34;) return } for (item in files) { if (showHidden || !item.name.startsWith(\u0026#34;.\u0026#34;)) { println(item.name) } } } } fun main(args: Array\u0026lt;String\u0026gt;) { val exitCode = CommandLine(Dir()).execute(*args) // 执行命令 exitProcess(exitCode) // 退出程序 } 运行main函数并设置参数就可以使用CLI\n4.编写需要制作成模版的代码 编写需要制作成模版的代码，例如本项目的controller代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 package $cn.cola.controller; import cn.cola.model.dto.user.UserUpdateRequest; import cn.cola.model.dto.user.UserQueryRequest; import cn.cola.model.dto.user.UserAddRequest; import cn.cola.common.constant.UserConstant; import cn.cola.common.exception.ThrowUtils; import cn.cola.common.DeleteRequest; import cn.cola.common.BaseResponse; import cn.cola.common.ResultUtils; import cn.cola.common.AuthCheck; import cn.cola.common.ErrorCode; import cn.cola.model.po.User; import cn.cola.model.vo.UserVO; import cn.cola.service.UserService; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.web.bind.annotation.*; import org.springframework.beans.BeanUtils; import lombok.extern.slf4j.Slf4j; import javax.annotation.Resource; import java.util.List; /** * 用户接口 * * @author ColaBlack */ @RestController @RequestMapping(\u0026#34;/user\u0026#34;) @Slf4j public class UserController { @Resource private UserService userService; // region 增删改查 /** * 插入用户（仅管理员） * * @param userAddRequest 用户添加请求体 * @return 新增的用户ID */ @PostMapping(\u0026#34;/insert\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Long\u0026gt; insertUser(@RequestBody UserAddRequest userAddRequest) { ThrowUtils.throwIf(userAddRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userAddRequest.getUserAccount() == null || userAddRequest.getUserAccount().isEmpty(), ErrorCode.PARAMS_ERROR, \u0026#34;账号不能为空\u0026#34;); User user = new User(); BeanUtils.copyProperties(userAddRequest, user); int res = userService.getBaseMapper().insert(user); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，增加用户失败\u0026#34;); return ResultUtils.success(user.getId()); } /** * 删除用户(仅管理员) * * @param deleteRequest 删除请求体 * @return 删除的记录数 */ @PostMapping(\u0026#34;/delete\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; deleteUser(@RequestBody DeleteRequest deleteRequest) { ThrowUtils.throwIf(deleteRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(deleteRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); int res = userService.getBaseMapper().deleteById(deleteRequest.getId()); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，删除用户失败\u0026#34;); return ResultUtils.success(res); } /** * 修改用户(仅管理员) * * @param userUpdateRequest 用户更新请求体 * @return 更新的记录数 */ @PostMapping(\u0026#34;/update\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; updateUser(@RequestBody UserUpdateRequest userUpdateRequest) { ThrowUtils.throwIf(userUpdateRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userUpdateRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = new User(); BeanUtils.copyProperties(userUpdateRequest, user); int res = userService.getBaseMapper().updateById(user); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR); return ResultUtils.success(res); } /** * 分页查询用户列表（仅管理员） * * @param userQueryRequest 条件查询请求体 * @return 用户列表 */ @PostMapping(\u0026#34;/select/page\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Page\u0026lt;User\u0026gt;\u0026gt; selectUserByPage(@RequestBody UserQueryRequest userQueryRequest) { long current = userQueryRequest.getCurrent(); long size = userQueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 100, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;User\u0026gt; queryWrapper = userService.getQueryWrapper(userQueryRequest); Page\u0026lt;User\u0026gt; res = userService.getBaseMapper().selectPage(page, queryWrapper); return ResultUtils.success(res); } /** * 根据ID查询用户信息（仅管理员） * * @param userQueryRequest 条件查询请求体 * @return 用户信息 */ @PostMapping(\u0026#34;/select/id\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;User\u0026gt; selectUserById(@RequestBody UserQueryRequest userQueryRequest) { ThrowUtils.throwIf(userQueryRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(userQueryRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = userService.getBaseMapper().selectById(userQueryRequest.getId()); return ResultUtils.success(user); } /** * 根据ID查询用户信息（全体用户） */ @GetMapping(\u0026#34;/get/id\u0026#34;) public BaseResponse\u0026lt;UserVO\u0026gt; getUserById(@RequestParam(\u0026#34;id\u0026#34;) long id) { ThrowUtils.throwIf(id \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); User user = userService.getBaseMapper().selectById(id); UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); return ResultUtils.success(userVO); } /** * 分页查询用户信息（全体用户） */ @PostMapping(\u0026#34;/get/page\u0026#34;) public BaseResponse\u0026lt;Page\u0026lt;UserVO\u0026gt;\u0026gt; getUserByPage(@RequestBody UserQueryRequest userQueryRequest) { long current = userQueryRequest.getCurrent(); long size = userQueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 20, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;User\u0026gt; queryWrapper = userService.getQueryWrapper(userQueryRequest); Page\u0026lt;User\u0026gt; res = userService.getBaseMapper().selectPage(page, queryWrapper); Page\u0026lt;UserVO\u0026gt; userVoPage = new Page\u0026lt;\u0026gt;(); BeanUtils.copyProperties(res, userVoPage); List\u0026lt;UserVO\u0026gt; records = userVoPage.getRecords(); records.clear(); for (User user : res.getRecords()) { UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); records.add(userVO); } return ResultUtils.success(userVoPage); } // endregion // region 其他接口 // todo: 此处补充其他接口 // endregion } 这个文档最先是在我的另一个个人文档网站的，但是在文档迁移的时候这个文件出了问题，里面的内容是我手工复原的，这段模版代码可能有问题，但是这不影响这篇文章的内容。\n5.编写FreeMarker模版 将原代码中可以被参数化的部分用${}包裹起来就得到了模版，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 package ${packageName}.controller; import ${packageName}.model.dto.${key}.${upperKey}UpdateRequest; import ${packageName}.model.dto.${key}.${upperKey}QueryRequest; import ${packageName}.model.dto.${key}.${upperKey}AddRequest; import ${packageName}.common.constant.${upperKey}Constant; import ${packageName}.common.exception.ThrowUtils; import ${packageName}.common.DeleteRequest; import ${packageName}.common.BaseResponse; import ${packageName}.common.ResultUtils; import ${packageName}.common.AuthCheck; import ${packageName}.common.ErrorCode; import ${packageName}.model.po.${upperKey}; import ${packageName}.model.vo.${upperKey}VO; import ${packageName}.service.${upperKey}Service; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.web.bind.annotation.*; import org.springframework.beans.BeanUtils; import lombok.extern.slf4j.Slf4j; import javax.annotation.Resource; import java.util.List; /** * ${name}接口 * * @author ${author} */ @RestController @RequestMapping(\u0026#34;/${key}\u0026#34;) @Slf4j public class ${upperKey}Controller { @Resource private ${upperKey}Service ${key}Service; // region 增删改查 /** * 插入${name}（仅管理员） * * @param ${key}AddRequest ${name}添加请求体 * @return 新增的${name}ID */ @PostMapping(\u0026#34;/insert\u0026#34;) @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Long\u0026gt; insert${upperKey}(@RequestBody ${upperKey}AddRequest ${key}AddRequest) { ThrowUtils.throwIf(${key}AddRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}AddRequest.get${upperKey}Account() == null || ${key}AddRequest.get${upperKey}Account().isEmpty(), ErrorCode.PARAMS_ERROR, \u0026#34;账号不能为空\u0026#34;); ${upperKey} ${key} = new ${upperKey}(); BeanUtils.copyProperties(${key}AddRequest, ${key}); int res = ${key}Service.getBaseMapper().insert(${key}); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，增加${name}失败\u0026#34;); return ResultUtils.success(${key}.getId()); } /** * 删除${name}(仅管理员) * * @param deleteRequest 删除请求体 * @return 删除的记录数 */ @PostMapping(\u0026#34;/delete\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; delete${upperKey}(@RequestBody DeleteRequest deleteRequest) { ThrowUtils.throwIf(deleteRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(deleteRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); int res = ${key}Service.getBaseMapper().deleteById(deleteRequest.getId()); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR, \u0026#34;数据库异常，删除${name}失败\u0026#34;); return ResultUtils.success(res); } /** * 修改${name}(仅管理员) * * @param ${key}UpdateRequest ${name}更新请求体 * @return 更新的记录数 */ @PostMapping(\u0026#34;/update\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Integer\u0026gt; update${upperKey}(@RequestBody ${upperKey}UpdateRequest ${key}UpdateRequest) { ThrowUtils.throwIf(${key}UpdateRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}UpdateRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = new ${upperKey}(); BeanUtils.copyProperties(${key}UpdateRequest, ${key}); int res = ${key}Service.getBaseMapper().updateById(${key}); ThrowUtils.throwIf(res \u0026lt;= 0, ErrorCode.OPERATION_ERROR); return ResultUtils.success(res); } /** * 分页查询${name}列表（仅管理员） * * @param ${key}QueryRequest 条件查询请求体 * @return ${name}列表 */ @PostMapping(\u0026#34;/select/page\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;Page\u0026lt;${upperKey}\u0026gt;\u0026gt; select${upperKey}ByPage(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { long current = ${key}QueryRequest.getCurrent(); long size = ${key}QueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 100, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;${upperKey}\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;${upperKey}\u0026gt; queryWrapper = ${key}Service.getQueryWrapper(${key}QueryRequest); Page\u0026lt;${upperKey}\u0026gt; res = ${key}Service.getBaseMapper().selectPage(page, queryWrapper); return ResultUtils.success(res); } /** * 根据ID查询${name}信息（仅管理员） * * @param ${key}QueryRequest 条件查询请求体 * @return ${name}信息 */ @PostMapping(\u0026#34;/select/id\u0026#34;) @AuthCheck(mustRole = $UserConstant.ADMIN_ROLE) public BaseResponse\u0026lt;${upperKey}\u0026gt; select${upperKey}ById(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { ThrowUtils.throwIf(${key}QueryRequest == null, ErrorCode.PARAMS_ERROR, \u0026#34;参数不能为空\u0026#34;); ThrowUtils.throwIf(${key}QueryRequest.getId() \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = ${key}Service.getBaseMapper().selectById(${key}QueryRequest.getId()); return ResultUtils.success(${key}); } /** * 根据ID查询${name}信息（全体用户） */ @GetMapping(\u0026#34;/get/id\u0026#34;) public BaseResponse\u0026lt;${upperKey}VO\u0026gt; get${upperKey}ById(@RequestParam(\u0026#34;id\u0026#34;) long id) { ThrowUtils.throwIf(id \u0026lt;= 0, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); ${upperKey} ${key} = ${key}Service.getBaseMapper().selectById(id); ${upperKey}VO ${key}VO = new ${upperKey}VO(); BeanUtils.copyProperties(${key}, ${key}VO); return ResultUtils.success(${key}VO); } /** * 分页查询${name}信息（全体用户） */ @PostMapping(\u0026#34;/get/page\u0026#34;) public BaseResponse\u0026lt;Page\u0026lt;${upperKey}VO\u0026gt;\u0026gt; get${upperKey}ByPage(@RequestBody ${upperKey}QueryRequest ${key}QueryRequest) { long current = ${key}QueryRequest.getCurrent(); long size = ${key}QueryRequest.getPageSize(); ThrowUtils.throwIf(current \u0026lt;= 0 || size \u0026lt;= 0 || size \u0026gt; 20, ErrorCode.PARAMS_ERROR, \u0026#34;参数错误\u0026#34;); Page\u0026lt;${upperKey}\u0026gt; page = new Page\u0026lt;\u0026gt;(current, size); QueryWrapper\u0026lt;${upperKey}\u0026gt; queryWrapper = ${key}Service.getQueryWrapper(${key}QueryRequest); Page\u0026lt;${upperKey}\u0026gt; res = ${key}Service.getBaseMapper().selectPage(page, queryWrapper); Page\u0026lt;${upperKey}VO\u0026gt; ${key}VoPage = new Page\u0026lt;\u0026gt;(); BeanUtils.copyProperties(res, ${key}VoPage); List\u0026lt;${upperKey}VO\u0026gt; records = ${key}VoPage.getRecords(); records.clear(); for (${upperKey} ${key} : res.getRecords()) { ${upperKey}VO ${key}VO = new ${upperKey}VO(); BeanUtils.copyProperties(${key}, ${key}VO); records.add(${key}VO); } return ResultUtils.success(${key}VoPage); } // endregion // region 其他接口 // todo: 此处补充其他接口 // endregion } 6.制作CLI工具 完整代码参考：No CRUD项目\n","date":"2024-10-29T19:35:19+08:00","permalink":"https://ColaBlack.github.io/p/%E7%B1%BBnocrud%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8Efreemarker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%B6%E4%BD%9C%E5%99%A8picocli/","title":"类NoCRUD项目开发手册 模版引擎FreeMarker 命令行制作器Picocli"},{"content":"初次发布于我的个人文档\n本文收集了一些常用的配置类，便于后续查询使用。\n后端常用配置 1.全局跨域配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package edu.zafu.teaai.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 全局跨域配置 * * @author ColaBlack */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 覆盖所有请求 registry.addMapping(\u0026#34;/**\u0026#34;) // 允许发送 Cookie .allowCredentials(true) // 放行哪些域名（必须修改为你实际的域名，否则 * 会和 allowCredentials 冲突） .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .exposedHeaders(\u0026#34;*\u0026#34;); } } 注意：放行的域名，allowedOriginPatterns()必须修改为前端的域名，否则会冲突。\n2.避免Long转json时的精度丢失 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package edu.zafu.teaai.config; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import org.springframework.boot.jackson.JsonComponent; import org.springframework.context.annotation.Bean; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * 配置如何处理Json文本 * * @author ColaBlack */ @JsonComponent public class JsonConfig { /** * 添加 Long 转 json 精度丢失的配置 */ @Bean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); SimpleModule module = new SimpleModule(); module.addSerializer(Long.class, ToStringSerializer.instance); module.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(module); return objectMapper; } } 在Java中Long类型是64位有符号整数，‌范围从-9,223,372,036,854,775,808到9,223,372,036,854,775,807，然而在JavaScript中整数最长只有15位，所以需要在Long类型对象进行序列化时将Long类型转化为字符串避免精度丢失。\n此时，如果传递一个Long类型的ID则前端收到的是一个字符串，就不会有精度问题。\n3.开启MyBatis分页功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package edu.zafu.teaai.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * MyBatis Plus 配置 * * @author ColaBlack */ @Configuration @MapperScan(\u0026#34;edu.zafu.teaai.mapper\u0026#34;) public class MyBatisPlusConfig { /** * 拦截器配置 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } Mybatis的分页功能需要以上配置才能开启。\n4.开启MyBatis下划线转驼峰、逻辑删除功能 1 2 3 4 5 6 7 8 9 mybatis-plus: configuration: map-underscore-to-camel-case: true # 驼峰命名 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: logic-delete-field: is_delete # 全局逻辑删除的实体字段名 logic-delete-value: 1 # 逻辑已删除值（默认为 1） logic-not-delete-value: 0 # 逻辑未删除值（默认为 0） 需要在application.yml中增加以上配置。\n前端常用配置 1.前端为开发服务器开启代理解决跨域问题 1 2 3 4 5 6 7 8 9 server: { port: 1222, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:1221\u0026#39;, changeOrigin: true } } }, 在vite.config.ts的defineConfig函数传入的实参对象中增加这样的配置即可。\n其意义是，将前端开发服务器开在1222端口，将所有/api开头的请求代理到后端http://localhost:1221。\n以后只需要向前端服务器http://localhost:1222发请求即可。\n增加完之后你的配置文件可能长这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { fileURLToPath, URL } from \u0026#39;node:url\u0026#39; import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ server: { port: 3000, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:1221\u0026#39;, changeOrigin: true } } }, plugins: [ vue() ], resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) } } }) 对于这个配置，官方文档是这样说明的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 export default defineConfig({ server: { proxy: { // 字符串简写写法：http://localhost:5173/foo -\u0026gt; http://localhost:4567/foo \u0026#39;/foo\u0026#39;: \u0026#39;http://localhost:4567\u0026#39;, // 带选项写法：http://localhost:5173/api/bar -\u0026gt; http://jsonplaceholder.typicode.com/bar \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;), }, // 正则表达式写法：http://localhost:5173/fallback/ -\u0026gt; http://jsonplaceholder.typicode.com/ \u0026#39;^/fallback/.*\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/fallback/, \u0026#39;\u0026#39;), }, // 使用 proxy 实例 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, configure: (proxy, options) =\u0026gt; { // proxy 是 \u0026#39;http-proxy\u0026#39; 的实例 } }, // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u0026gt; ws://localhost:5174/socket.io // 在使用 `rewriteWsOrigin` 时要特别谨慎，因为这可能会让代理服务器暴露在 CSRF 攻击之下 \u0026#39;/socket.io\u0026#39;: { target: \u0026#39;ws://localhost:5174\u0026#39;, ws: true, rewriteWsOrigin: true, }, }, }, }) 官方文档链接：开发服务器选项 | Vite 官方中文文档\n2.配置axios请求 在src/config下创建request.ts用于配置axios。\n配置内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import axios from \u0026#39;axios\u0026#39; export const BASE_URL = \u0026#39;http://localhost:1222\u0026#39; const request = axios.create({ baseURL: BASE_URL, timeout: 60000, withCredentials: true }) // 请求拦截器 request.interceptors.request.use( function (config) { // Do something before request is sent return config }, function (error) { // Do something with request error return Promise.reject(error) } ) // 响应拦截器 request.interceptors.response.use( function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data const { data } = response // 未登录 if (data.code === 40100) { // 不是获取用户信息接口，并且不是登录页面，则跳转到登录页面并保存当前页面的路径 if ( !response.request.responseURL.includes(\u0026#39;user/get/login\u0026#39;) \u0026amp;\u0026amp; !window.location.pathname.includes(\u0026#39;/user/login\u0026#39;) ) { window.location.href = `/user/login?redirect=${window.location.href}` } } return response }, function (error) { // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error return Promise.reject(error) } ) export default request BASE_URL务必换成自己后端的地址（如果前端开了代理则为前端的地址），真实上线时请修改为真实的请求地址！\nwithCredentials: true请务必开启，否则cookie会有问题。\n3. Umijs/openapi 在有些时候，我们可能已经有了一份openapi格式的接口文档。（如：后端已经开发完成则可以使用swagger或knife4j自动生成接口文档）\n这时可以使用umijs/openapi自动生成请求代码。\n需要在src/config下新建openapi.config.js配置如下：\n1 2 3 4 5 6 7 import { generateService } from \u0026#39;@umijs/openapi\u0026#39; generateService({ requestLibPath: \u0026#34;import request from \u0026#39;@/config/request\u0026#39;\u0026#34;, schemaPath: \u0026#39;http://localhost:1221/api/v2/api-docs\u0026#39;, serversPath: \u0026#39;./src\u0026#39; }) 然后在package.json中增加如下运行脚本\n1 \u0026#34;openapi\u0026#34;: \u0026#34;node src/config/openapi.config.js\u0026#34; 4.Pinia存储用户登录态样例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { defineStore } from \u0026#39;pinia\u0026#39; import type { Ref } from \u0026#39;vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; import { getLoginUserUsingGet } from \u0026#39;@/api/userController\u0026#39; import type { AxiosResponse } from \u0026#39;axios\u0026#39; import roleEnums from \u0026#39;@/access/roleEnums\u0026#39; export const useUserStore = defineStore(\u0026#39;USER_LOGIN_STATE\u0026#39;, () =\u0026gt; { const loginUser: Ref\u0026lt;API.LoginUserVO\u0026gt; = ref({ userName: \u0026#39;未登录\u0026#39; }) async function fetchLoginUser() { const res: AxiosResponse\u0026lt;API.BaseResponseLoginUserVO_\u0026gt; = await getLoginUserUsingGet() if (res.data.code === 200 \u0026amp;\u0026amp; res.data.data) { loginUser.value = res.data.data } else { loginUser.value = { userName: \u0026#39;未登录\u0026#39;, userRole: roleEnums.PUBLIC } } } function setLoginUser(newUser: API.LoginUserVO) { loginUser.value = newUser } return { loginUser, fetchLoginUser, setLoginUser } }) ","date":"2024-10-28T19:39:49+08:00","permalink":"https://ColaBlack.github.io/p/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/","title":"常用配置类"},{"content":"初次发布于我的个人文档\n参考：\n1,MINIO在java中的使用\n2.MinIO Linux官方文档\n1.利用1panel安装minio 图片上传等服务依赖于对象存储服务，本文就以开源对象储存minio为例简单介绍。\n推荐使用linux版本的minio，只需在1panel应用商城傻瓜式安装即可。\n记得记好你的root账户用户名和密码，另外minio不支持弱密码弱用户名！\n1panel基于容器部署，记得开启外部访问权限。\n2.安装java sdk 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/io.minio/minio --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.minio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;minio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 或\n1 2 // https://mvnrepository.com/artifact/io.minio/minio implementation(\u0026#34;io.minio:minio:8.5.13\u0026#34;) 3.配置minio连接 在applicantion.yml添加如下配置。\n1 2 3 4 minio: endpoint: http://你的minio主机:9000 accesskey: 你的ak secretkwy: 你的sk 注意，minio默认9000端口是上传文件的端口，9001是其web控制台端口，ak‘和sk都可以在那里获取。\n然后新增配置类：\n先配置如何在applicantion.yml中读取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package edu.zafu.teaai.config; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * 获取minio的配置信息 * * @author ColaBlack */ @Data @Component @ConfigurationProperties(prefix = \u0026#34;minio\u0026#34;) // 此处说明了要读取minio.*的配置信息 public class MinioProps { /** * minio的url */ private String endpoint; /** * minio的ak */ private String accesskey; /** * minio的sk */ private String secretkwy; } 然后是真正着手配置minio\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package edu.zafu.teaai.config; import io.minio.MinioClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.annotation.Resource; /** * minio配置类 * * @author ColaBlack */ @Configuration public class MinioConfig { @Resource private MinioProps props; /** * 获取 Minio客户端对象 * * @return MinioClient */ @Bean public MinioClient minioClient() { return MinioClient.builder() .endpoint(props.getEndpoint()) .credentials(props.getAccesskey(), props.getSecretkwy()) .build(); } } 最后是在minio上传文件的工具类。\n这也是重点中的重点。\n对象存储以存储桶为基本单位，你可以粗略得认为存储桶就是一个“数据库”，下面来介绍一下如何创建存储桶。\n当然，事实上这个存储桶应该由管理员在minio web界面上创建而不是用java程序创建。不过无妨，这里也讲讲。\n我们要通过刚刚配置的minio客户端对minio进行操作，所以要先通过依赖注入获取客户端。\n1 2 @Resource private MinioClient client; 然后再写一个方法创建指定名称的存储桶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 创建桶 * * @param bucketName 桶名称 */ public void createBucket(String bucketName) { boolean found = client.bucketExists( BucketExistsArgs.builder(). bucket(bucketName) .build() ); if (!found) { client.makeBucket( MakeBucketArgs.builder() .bucket(bucketName) .build()); } } 第一段代码是通过客户端的bucketExists方法判断指定名称的存储桶是否存在。\n但是我们还得给他传一个查询参数才行，这就是括号里面传的参数了。\n通过\n1 BucketExistsArgs.builder().bucket(bucketName).build() 即可得到一个查询桶名称为字符串bucketName内容的桶。\n如果存在这样的桶则found=true，反之为false。\n下一段则是说，如果桶不存在，那就通过client.makeBucket创建桶。\n当然，你可能会发现idea报error说方法可能抛出两个异常，你可以通过try catch手动捕获异常进行处理，也可以加上lombok的@SneakyThrows交由lombok自动处理。\n最后上传文件的工具方法就变成了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Resource private MinioClient client; /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } 删除桶啊什么的自己看文档吧，实际上暂时只有上传文件和获取文件的URL会用到。\n上传文件则需要文件的输入流stream等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 * @param type 文件类型 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize, String type) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .contentType(type) .build()); } 需要注意的是，一般而言文件类型minio可以自己根据后缀名自己识别，在这里可以不给出。\n常见的文件类型\ntext/plain: 文本文件（.txt） text/html: HTML文件（.html, .htm） application/json: JSON文件（.json） application/xml: XML文件（.xml） image/jpeg: JPEG图片（.jpg, .jpeg） image/png: PNG图片（.png） image/gif: GIF图片（.gif） application/pdf: PDF文件（.pdf） application/zip: ZIP文件（.zip） 所以最简单的上传方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } 还有一个需要的是获取文件的外链，也就是外部可以访问的URL信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 获取文件在minio在服务器上的外链 * * @param bucketName 桶名称 * @param objectName 文件名 * @return 外链 */ @SneakyThrows public String getObjectUrl(String bucketName, String objectName) { return client.getPresignedObjectUrl( GetPresignedObjectUrlArgs.builder() .method(Method.GET) .bucket(bucketName) .object(objectName) .build()); } 其他的方法可以自己查询文档获取，使用率并不高。\n最终整个工具类的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package edu.zafu.teaai.utils; import io.minio.GetPresignedObjectUrlArgs; import io.minio.MinioClient; import io.minio.PutObjectArgs; import io.minio.http.Method; import lombok.SneakyThrows; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.io.InputStream; /** * minio操作类 * * @author ColaBlack */ @Component public class MinioUtils { @Resource private MinioClient client; /** * 上传文件 * * @param bucketName 桶名称 * @param objectName 文件名 * @param stream 输入流 * @param fileSize 文件大小 */ @SneakyThrows public void putObject(String bucketName, String objectName, InputStream stream, Long fileSize) { client.putObject( PutObjectArgs.builder() .bucket(bucketName) .object(objectName) .stream(stream, fileSize, -1) .build()); } /** * 获取文件在minio在服务器上的外链 * * @param bucketName 桶名称 * @param objectName 文件名 * @return 外链 */ @SneakyThrows public String getObjectUrl(String bucketName, String objectName) { return client.getPresignedObjectUrl( GetPresignedObjectUrlArgs.builder() .method(Method.GET) .bucket(bucketName) .object(objectName) .build()); } } 4.编写工具类和service层代码 本文以头像上传为例进行简介。\n首先编写service层接口代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package edu.zafu.teaai.service; import edu.zafu.teaai.model.dto.file.UploadFileRequest; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; /** * minio文件服务接口 * * @author ColaBlack */ public interface MinioService { /** * 上传文件 * * @param file 上传的文件 * @param uploadFileRequest 上传文件请求 * @param request 请求对象 * @return 上传结果 */ String uploadImage( MultipartFile file, UploadFileRequest uploadFileRequest, HttpServletRequest request); /** * 验证文件 * * @param file 文件 */ void validFile(MultipartFile file); } 接着在编写实现类时会遇到几个常量， 在此提前给出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 文件上传相关常量 * * @author ColaBlack */ public interface FileConstant { /** * 上传文件最大大小1MB */ int MAX_FILE_SIZE = 1048576; /** * 允许上传的图片类型 */ List\u0026lt;String\u0026gt; ALLOW_IMAGE_TYPES = Arrays.asList(\u0026#34;jpg\u0026#34;, \u0026#34;jpeg\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;svg\u0026#34;, \u0026#34;webp\u0026#34;, \u0026#34;bmp\u0026#34;); } 这两个常量都是用于验证头像信息的。\n然后是编写实现类，首先是验证图片信息的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 校验文件 * * @param file 文件 */ @Override public void validFile(MultipartFile file) { ThrowUtils.throwIf(ObjectUtils.isEmpty(file), ErrorCode.PARAMS_ERROR, \u0026#34;文件不能为空\u0026#34;); // 文件大小 long fileSize = file.getSize(); if (fileSize \u0026gt; FileConstant.MAX_FILE_SIZE) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件大小不能超过 1M\u0026#34;); } // 文件后缀 String fileSuffix = FileUtil.getSuffix(file.getOriginalFilename()); if (!FileConstant.ALLOW_IMAGE_TYPES.contains(fileSuffix)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件类型错误\u0026#34;); } } 主要是对文件大小和文件类型进行了限制。\n然后是重头戏，操作minio上传文件。\n在上传文件前需要根据业务进行一些检查，例如只有已登录用户才能上传头像等等，在此只调用刚刚写的validFile方法。\n1 2 // 校验文件 validFile(file); 然后是对用户上传的头像进行重命名，避免两个不同的用户上传了同一名字的图片导致异常覆盖。\n本文以：业务名_当前时间戳_随机uuid_文件原始名称为重命名模版。\n1 2 3 //重命名文件 FileUploadBizEnum fileUploadBizEnum = FileUploadBizEnum.getEnumByValue(biz); String fileName = biz + \u0026#34;_\u0026#34; + System.currentTimeMillis() + \u0026#34;_\u0026#34; + UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); 然后调用minioUtils的方法上传文件即可。\n1 2 3 4 //使用minio上传文件 minioUtils.putObject(FileConstant.BUCKET_NAME, fileName, file.getInputStream(), file.getSize()); //获取外链 return minioUtils.getObjectUrl(FileConstant.BUCKET_NAME, fileName); 最后minio服务实现类的代码就是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package edu.zafu.teaai.service.impl; import cn.hutool.core.io.FileUtil; import edu.zafu.teaai.common.ErrorCode; import edu.zafu.teaai.common.exception.BusinessException; import edu.zafu.teaai.common.exception.ThrowUtils; import edu.zafu.teaai.constant.FileConstant; import edu.zafu.teaai.constant.UserConstant; import edu.zafu.teaai.service.MinioService; import edu.zafu.teaai.utils.MinioUtils; import lombok.SneakyThrows; import org.apache.commons.lang3.ObjectUtils; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.UUID; /** * Minio文件服务实现类 * * @author ColaBlack */ @Service public class MinioServiceImpl implements MinioService { @Resource private MinioUtils minioUtils; /** * 上传文件 * * @param file 上传的文件 * @param biz 业务类型 * @param request 请求对象 * @return 上传结果 */ @SneakyThrows @Override public String uploadImage(MultipartFile file, String biz, HttpServletRequest request) { // 校验文件 validFile(file); //登录用户才能上传文件 Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE); ThrowUtils.throwIf(ObjectUtils.isEmpty(attribute), ErrorCode.NOT_LOGIN_ERROR, \u0026#34;用户未登录\u0026#34;); //重命名文件 String fileName = biz + \u0026#34;_\u0026#34; + System.currentTimeMillis() + \u0026#34;_\u0026#34; + UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); //使用minio上传文件 minioUtils.putObject(FileConstant.BUCKET_NAME, fileName, file.getInputStream(), file.getSize()); //获取外链 return minioUtils.getObjectUrl(FileConstant.BUCKET_NAME, fileName); } /** * 校验文件 * * @param file 文件 */ @Override public void validFile(MultipartFile file) { ThrowUtils.throwIf(ObjectUtils.isEmpty(file), ErrorCode.PARAMS_ERROR, \u0026#34;文件不能为空\u0026#34;); // 文件大小 long fileSize = file.getSize(); if (fileSize \u0026gt; FileConstant.MAX_FILE_SIZE) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件大小不能超过 1M\u0026#34;); } // 文件后缀 String fileSuffix = FileUtil.getSuffix(file.getOriginalFilename()); if (!FileConstant.ALLOW_IMAGE_TYPES.contains(fileSuffix)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, \u0026#34;文件类型错误\u0026#34;); } } } 最后提醒一下，别忘了service层实现类要有Service注解。\n5.编写controller层代码 在编写前需要先针对项目的业务编写枚举类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package edu.zafu.teaai.model.enums; import lombok.AllArgsConstructor; import lombok.Getter; import org.apache.commons.lang3.ObjectUtils; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; /** * 文件上传业务类型枚举 * * @author ColaBlack */ @Getter @AllArgsConstructor public enum FileUploadBizEnum { /** * 用户头像上传 */ USER_AVATAR(\u0026#34;用户头像\u0026#34;, \u0026#34;user_avatar\u0026#34;), /** * 业务类型名称 */ private final String text; /** * 业务类型值 */ private final String value; /** * 获取值列表 */ public static List\u0026lt;String\u0026gt; getValues() { return Arrays.stream(values()).map(item -\u0026gt; item.value).collect(Collectors.toList()); } /** * 根据 value 获取枚举 */ public static FileUploadBizEnum getEnumByValue(String value) { if (ObjectUtils.isEmpty(value)) { return null; } for (FileUploadBizEnum anEnum : FileUploadBizEnum.values()) { if (anEnum.value.equals(value)) { return anEnum; } } return null; } } 在controller层，先注入minioService，然后进行简单的校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Resource private MinioService minioService; @PostMapping(\u0026#34;/upload/avatar\u0026#34;) public BaseResponse\u0026lt;String\u0026gt; uploadAvatar(@RequestPart(\u0026#34;file\u0026#34;) MultipartFile file, UploadFileRequest uploadFileRequest, HttpServletRequest request) { //登录用户才能上传文件 Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE); ThrowUtils.throwIf(ObjectUtils.isEmpty(attribute), ErrorCode.NOT_LOGIN_ERROR, \u0026#34;用户未登录\u0026#34;); // 校验业务类型 String biz = uploadFileRequest.getBiz(); FileUploadBizEnum fileUploadBizEnum = FileUploadBizEnum.getEnumByValue(biz); ThrowUtils.throwIf(!Objects.equals(fileUploadBizEnum, FileUploadBizEnum.USER_AVATAR), ErrorCode.PARAMS_ERROR, \u0026#34;上传业务类型不正确\u0026#34;); // 上传文件 String res = minioService.uploadImage(file, biz, request); return ResultUtils.success(res); } 然后调用service层代码即可。\n","date":"2024-10-27T19:40:47+08:00","permalink":"https://ColaBlack.github.io/p/minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-%E5%9B%BE%E7%89%87-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E5%A4%B4%E5%83%8F/","title":"Minio对象存储 图片 图片上传 头像"},{"content":"初次发布于我的个人文档\n参考：缓存雪崩，缓存击穿，缓存穿透 Caffeine本地缓存\n在一些场景下可以引入缓存加速，利用redis实现缓存通常是一个不错的选择，但有时为了避免系统变得复杂可以使用本地缓存。 Caffeine就是一个高效的本地缓存组件。使用方式如下：\n1.安装依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.创建用于缓存的key-value键值对 1 2 3 4 5 6 Cache\u0026lt;String, String\u0026gt; answerCacheMap = Caffeine.newBuilder() //初始化缓存键值对容量 .initialCapacity(1024) // 设置缓存有效期为一天 .expireAfterAccess(1L, TimeUnit.DAYS) .build(); 利用缓存是为了提高速度，但是缓存的数据并不会及时更新，所以需要设置有效期，即 超时是为了保证数据的有效。缓存有效期需要根据业务的不同自行设置。\n3.新增和读取缓存 1 2 3 4 5 6 7 8 9 // 从刚刚的缓存键值对中读取缓存的cacheKey对应的数据 String cache = answerCacheMap.getIfPresent(cacheKey); // 如果没有命中缓存，则取出的cache字符串为空 if (StringUtils.isEmpty(cache)) { // 未命中缓存，走正常的业务逻辑 cache = work(); // 缓存结果 answerCacheMap.put(cacheKey, json); } 4.缓存的问题 无论用什么方式实现缓存都需要注意以下几个问题：\n缓存击穿 缓存击穿指在某一个时间有大量同一个key对应的缓存键值对过期或redis、caffeine等缓存中间件故障，与此同时客户端直接向业务系统（如数据库）发起请求，从而导致业务系统接着崩溃。\n解决方法有： 预防性缓存更新：在热点数据即将过期时，提前异步刷新缓存。通过检测热点数据的访问频率，当即将过期时触发自动更新操作，避免过期瞬间的击穿问题。 双缓存机制：可以采用双层缓存策略：一个主要缓存层负责缓存大部分数据，另一个次缓存层保存上次的缓存数据。在主要缓存失效时，可以直接从次缓存层读取数据，避免直接打到业务系统。 加锁保证同时只有少量请求能够构建缓存和访问业务系统\n缓存雪崩 缓存雪崩指在某一个时间有大量不同的key对应的缓存键值对过期或redis、caffeine等缓存中间件故障，与此同时客户端直接向业务系统（如数据库）发起请求，从而导致业务系统接着崩溃。\n解决方法有： 将过期时间进行一定范围内的随机化 使用多级缓存 加锁保证同时只有少量请求能够构建缓存和访问业务系统 使用redis高可用集群等确保缓存尽量少得故障。\n缓存穿透 缓存穿透指用户恶意查询业务系统中本不可能存在的key导致每次请求都直接穿过缓存机制访问业务系统，如果恶意用户进行大量这样的查询则会导致业务系统因压力过大而崩溃。 解决方法： 缓存空结果：如果查询的某个键在业务系统中不应该存在，则将该键的查询结果（如 null 或空值）缓存起来，并设定一个较短的过期时间，防止该键反复查询打到业务系统。 阻止非法请求（使用黑名单机制）：在查询请求进入业务系统前，进行严格的参数校验和过滤，避免不合法的请求查询业务系统（避免黑名单内的请求进入）。 使用白名单机制：使用布隆过滤器对所有可能存在的数据进行标记（设为白名单），所有请求先经过布隆过滤器进行校验，只有布隆过滤器认为存在的数据（白名单的数据），才会去查询缓存或数据库。这样可以有效拦截掉绝大多数不存在的请求，防止这些请求绕过缓存直接打到数据库。\n","date":"2024-10-23T19:43:38+08:00","permalink":"https://ColaBlack.github.io/p/caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/","title":"Caffeine本地缓存和缓存雪崩 缓存击穿 缓存穿透"},{"content":"初次发布于我的个人文档\n参考:java操作163邮箱\n本文以163邮箱为例，介绍如何用java发送邮箱。\n1.获取邮箱授权码 进入163邮箱-设置-POP3/SMTP/IMAP-开启POP3/SMTP服务\n记录得到的授权码\n2.安装依赖 1 2 3 4 // https://mvnrepository.com/artifact/jakarta.activation/jakarta.activation-api implementation(\u0026#34;jakarta.activation:jakarta.activation-api:2.1.3\u0026#34;) // https://mvnrepository.com/artifact/org.apache.commons/commons-email implementation(\u0026#34;org.apache.commons:commons-email:1.6.0\u0026#34;) 注意，参考文章年代有些久远，有几个库已经合并更新换了新的名字。\n3.编写通用邮件发送工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package edu.zafu; import org.apache.commons.mail.EmailException; import org.apache.commons.mail.SimpleEmail; /** * 邮件工具类 * * @author ColaBlack */ public class MailUtils { /** * 发送邮件 * * @param targetEmail 目标用户邮箱 * @param header 邮件的标题 * @param message 要发送的消息 */ public static void sendEmail(String targetEmail, String header, String message) { try { // 创建邮箱对象 SimpleEmail mail = new SimpleEmail(); // 设置发送邮件的服务器，以163邮箱为例 mail.setHostName(\u0026#34;smtp.163.com\u0026#34;); // 输入发送邮件的邮箱号+授权码 mail.setAuthentication(\u0026#34;用于发送的邮箱号\u0026#34;, \u0026#34;授权码\u0026#34;); // 注意：一个邮箱账号可能有多个邮箱，要注意这个区分。 // 如QQ邮箱就支持同一个邮箱账号持有@qq.com @foxmail.com两个邮箱 // 发送邮件 \u0026#34;你的邮箱号\u0026#34;+\u0026#34;发送时用的昵称\u0026#34; mail.setFrom(\u0026#34;用于发送邮箱的邮箱号\u0026#34;, \u0026#34;昵称\u0026#34;); // 使用SSL安全链接 mail.setSSLOnConnect(true); // 接收用户的邮箱 mail.addTo(targetEmail); // 邮件的主题(标题) mail.setSubject(header); // 邮件的内容 mail.setMsg(message); // 发送 mail.send(); } catch (EmailException e) { // 邮件发送失败，记录日志(此处应该换成项目统一的日志记录方式) System.out.println(\u0026#34;邮件发送失败：\u0026#34; + e.getMessage()); } } } 4.调用工具类——以发验证码为例 编写发送验证码工具类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package edu.zafu; import java.util.Random; /** * 发送验证码工具类 * * @author ColaBlack */ public class SendCode { /** * 发送验证码 * * @param targetEmail 目标邮箱 */ public static void send(String targetEmail) { // 生成验证码 int code = new Random().nextInt(899999) + 100000; // 发送验证码 MailUtils.sendEmail(targetEmail, \u0026#34;验证码\u0026#34;, \u0026#34;您的验证码为:\u0026#34; + code + \u0026#34;(1分钟内有效)\u0026#34;); } } 可以使用如下代码测试\n1 2 3 4 5 6 7 8 9 10 11 12 package edu.zafu; /** * 测试邮箱发送 * * @author ColaBlack */ public class TestMail { public static void main(String[] args) { SendCode.send(\u0026#34;你的第二个邮箱\u0026#34;); } } 5.引入缓存机制 上面的验证码用户可以通过疯狂发送请求而恶意消耗邮箱发送资源，我们也没有让验证码及时过期。\n可以引入缓存机制解决，在上文Caffeine本地缓存和缓存雪崩，缓存击穿，缓存穿透中我们介绍了如何利用caffeine实现本地缓存，本文就选择用 Redis 实现分布式缓存。\n6.安装Redisson 为了在java中操作redis需要安装依赖\n1 2 // https://mvnrepository.com/artifact/org.redisson/redisson implementation(\u0026#34;org.redisson:redisson:3.37.0\u0026#34;) 7.调整验证码工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package edu.zafu; import org.redisson.Redisson; import org.redisson.api.RMapCache; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import java.util.Random; import java.util.concurrent.TimeUnit; /** * 发送验证码工具类 * * @author ColaBlack */ public class SendCode { /** * 发送验证码 * * @param targetEmail 目标邮箱 */ public static void send(String targetEmail) { Config config = new Config(); config.useSingleServer() // 使用单机模式 // 设置要连接的数据库 .setDatabase(0) // 设置redis服务器地址 .setAddress(\u0026#34;redis://127.0.0.1:6379\u0026#34;) // 设置redis密码 .setPassword(\u0026#34;password\u0026#34;); // 创建Redisson客户端 RedissonClient redisson = Redisson.create(config); // 获取缓存的map RMapCache\u0026lt;Object, Object\u0026gt; codeCache = redisson.getMapCache(\u0026#34;code\u0026#34;); // 判断目标邮箱是否已存在验证码 if (codeCache.containsKey(targetEmail)) { // 验证码已存在，直接返回 return; } // 验证码不存在，生成验证码并存入缓存 // 生成验证码 int code = new Random().nextInt(899999) + 100000; // 存入缓存,设置1分钟过期 codeCache.put(targetEmail, code, 1, TimeUnit.MINUTES); // 发送验证码 MailUtils.sendEmail(targetEmail, \u0026#34;验证码\u0026#34;, \u0026#34;您的验证码为:\u0026#34; + code + \u0026#34;(1分钟内有效)\u0026#34;); // 校验验证码是否正确时也从redis中拿去对应邮箱的验证码，这样就能实现验证码的超时过期 } } 关于使用缓存机制可能引发的缓存击穿、缓存雪崩、缓存穿透的问题请参考上文Caffeine本地缓存和缓存雪崩，缓存击穿，缓存穿透\n","date":"2024-10-23T19:41:34+08:00","permalink":"https://ColaBlack.github.io/p/java%E6%93%8D%E4%BD%9C%E9%82%AE%E7%AE%B1-%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81-redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-redisson%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/","title":"Java操作邮箱 邮箱发送验证码 Redis分布式缓存 Redisson分布式缓存"}]
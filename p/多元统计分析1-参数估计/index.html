<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。\n在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。\n">
<title>多元统计分析(1) 参数估计</title>

<link rel='canonical' href='https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%901-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="多元统计分析(1) 参数估计">
<meta property='og:description' content="上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。\n在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。\n">
<meta property='og:url' content='https://ColaBlack.github.io/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%901-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/'>
<meta property='og:site_name' content='ColaBlack个人文档'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-12-22T16:31:40&#43;08:00'/><meta property='article:modified_time' content='2024-12-22T16:31:40&#43;08:00'/>
<meta name="twitter:title" content="多元统计分析(1) 参数估计">
<meta name="twitter:description" content="上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。\n在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu8408018346616742451.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">😜</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">ColaBlack个人文档</a></h1>
            <h2 class="site-description">一个文档，记录我用得上的一些信息。也算不上是什么博客了啦。</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://gitee.com/colablack'
                        target="_blank"
                        title="gitee"
                        rel="me"
                    >
                        
                        
                            <svg t="1731323057361" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4248" width="200" height="200"><path d="M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z" fill="#707070" p-id="4249"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/ColaBlack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#多元统计的参量">多元统计的参量</a></li>
        <li><a href="#多元正态分布">多元正态分布</a></li>
        <li><a href="#格式点离散化方法">格式点离散化方法</a></li>
        <li><a href="#矩估计">矩估计</a></li>
        <li><a href="#极大似然估计">极大似然估计</a></li>
        <li><a href="#矩阵和向量的导数">矩阵和向量的导数</a></li>
        <li><a href="#多元正态分布的极大似然估计">多元正态分布的极大似然估计</a></li>
        <li><a href="#牛顿法求数值解">牛顿法求数值解</a></li>
        <li><a href="#r语言实现">R语言实现</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%901-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/">多元统计分析(1) 参数估计</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-12-22</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>上一次玩数值计算方法，唠到矩阵分解说唠不动了，换换口味。那这不就来了。</p>
<p>在小学初中高中乃至大学，概率统计都是有部分分量的。但是哪怕是大学考研的课程《概率论与数理统计》都鲜少涉及多元特别是二元以上的统计方法。</p>
<p>本系列就专门针对这种多元以上的情况进行分析。</p>
<p>第一个部分就是对《概率论与数理统计》的拓展，在这门课里最常见的统计方法就是参数估计以及各种假设检验，还有什么方差分析啊云云。</p>
<p>第一期就从参数估计开始。</p>
<p>那要唠参数估计的话首先就得有参数吧。</p>
<p>这个的话直接把一元的扩展出来就可以了。</p>
<h3 id="多元统计的参量">多元统计的参量
</h3><p>在多元情况呢，随机变量的维数就不是简单的一维了，所以我们不能用数字来表示随机变量而是要把随机变量化为随机向量。</p>
<p>一般地，n维随机变量就要用一个n维向量表示即$X=\begin{pmatrix}
x_1 \
x_2 \
&hellip;\x_n
\end{pmatrix}$。</p>
<p>而我们对某一个随机向量进行m次观测后就会得到m个向量值，我们可以把他拼成一个n行m列的矩阵，称为样本的资料矩阵。</p>
<p>对于多元随机变量，我们还是用累计分布函数、密度函数等式子来表达其概率分布，并且也只是在定义上进行简单的推广。</p>
<p>例如，</p>
<p>对随机变量$X=\begin{pmatrix}
x_1 \
x_2 \
&hellip;\x_n
\end{pmatrix}$，他的累积分布函数就是$F(X)=P(\vec{x}\le X)$</p>
<p>而密度函数f(X)的定义只是把1维随机变量密度函数中的定积分变成n重积分而已。</p>
<p>而在二维随机变量的时候有所谓的边缘分布，在n维的情况也是一样的。</p>
<p>我们讨论多元统计，只需要着重于不同点就可以了，相同点只需要以此类推即可。</p>
<p>至于多元统计的参量，也还是什么均值啊，方差啊之类的。</p>
<p>对n维随机变量$X=\begin{pmatrix}
x_1 \
x_2 \
&hellip;\x_n
\end{pmatrix}$所谓的均值$E(X)=\begin{pmatrix}
E(x_1) \
E(x_2) \
&hellip;\E(x_n)
\end{pmatrix}$</p>
<p>方差啊什么的定义则完全没变，只是变成了矩阵运算。</p>
<p>$D(X)=E[(X-E(X))(X-E(X))^T]$</p>
<p>协方差</p>
<p>$cov(X)=E[(X-E(X))(Y-E(Y))^T]$</p>
<p>需要注意的是，现在方差与协方差是一个矩阵，并且实际上在这样的定义下，方差阵和协方差阵的（i，j）就是对应的一个或两个分量的方差/协方差。</p>
<p>性质的话，仍然和一维随机变量一致，但是要注意的是，现在要用对等的矩阵表达。</p>
<p>例如，期望的线性性质$E(AX+BY)=AE(X)+BE(Y)$</p>
<p>$cov(X,X)=D(X)$</p>
<p>$COV(AX,BY)=Acov(X,Y)B^T$</p>
<p>但是样本的期望阵有一个新的性质！</p>
<p>我们设$\mu=E(X),\Sigma=D(X)$而A是常数矩阵</p>
<p><strong>则有$E(X^TAX)=tr(A\Sigma)+\mu^TA\mu$</strong></p>
<p>这个性质因为是一维所不具备的所以需要特别注意。</p>
<p>他的证明倒是非常简单，在两边的x上加上然后减掉$\mu$就可以了。</p>
<p>$E(X^TAX)=E((X-\mu+\mu)^TA(X-\mu+\mu))$</p>
<p>然后展开里面的乘法。</p>
<p>原式$=E((X-\mu)^TA(X-\mu)+(X-\mu)^TA\mu+\mu^TA(X-\mu)+\mu^TA\mu)$</p>
<p>中间两项的和是0，而两边的就是结论了，这样就证完了。</p>
<p>有的时候啊，为了偷懒，我可能还是会用这里定义的$\Sigma$这一个符号来表示某一个变量的方差$\mu$来表示均值，需要注意。</p>
<p>有了协方差，我们知道，协方差矩阵可以看做内积结构，从而可以通过两个向量在协方差这个内积结构下定义（线性）相关系数。</p>
<p>但是对于多元的情况，我们是比较难写出计算相关系数的矩阵形式的。</p>
<p>但是我们仍然可以仿照前面的定义，要求变量X,Y相关系数矩阵R的（i，j）元是$X_i,Y_j$的相关系数，从而拼出一个相关系数矩阵。</p>
<p>虽然我们没有写出相关系数矩阵的矩阵表达，但这样的相关系数矩阵仍然具备一维相关系数的良好性质。</p>
<p>例如，一个经过标准化（减去均值向量再除以方差即乘以方差的逆）后的数据的协方差矩阵就是原数据的相关系数矩阵。</p>
<p>前面都是针对随机向量的统计量，那针对经过实验得到的样本，我们还是用同样的方法扩展样本的统计量。</p>
<p>比如样本的均值/方差/协方差/相关系数/离差矩阵等，他们的（i，j）元仍然是对应两个一元变量的均值/方差/协方差/相关系数/离差矩阵。</p>
<h3 id="多元正态分布">多元正态分布
</h3><p>有了这些统计量，接下来自然是介绍随机变量的分布。在这里，我们只取一个最典型的正态分布的多元情况。</p>
<p>至于一元的什么卡方分布啊、t分布啊之类的，你在后面就会知道他们的多元版本了。</p>
<p>这里介绍多元正态分布，只是因为只有多元正态分布的密度函数比较简洁，而且在后续也会使用到。</p>
<p>我们以均值向量为$\mu$,方差为$\sigma$的p维正态分布$N_p(\mu,\sigma)$为例，他的密度函数是</p>
$$f(\vec x)=\frac{e^{-\frac{(x-\mu)^T\Sigma^{-1}(x-\mu)}{2}}}{{(2\pi)}^{\frac{p}{2}}|\Sigma|^\frac{1}{2}}$$<p>注意：$|\Sigma|$中的两个竖线是行列式！！！</p>
<p>额，这已经是多元分布里密度函数比较简洁漂亮的了。。。。</p>
<p>并且多元正态分布的性质非常好，不仅延续了一元正态分布独立等价于不相关、线性变换后仍是正态分布等性质，并且多元正态分布的边缘分布以及条件分布都是多元正态分布。</p>
<p>而且你从多元正态分布里取任意几个分量，把他们拼成一个新的随机向量（这叫随机变量的剖分），他也是正态分布。</p>
<p>这里还要注意一下，既然多元正态分布经过线性变换后还是正态分布，那么正态分布的均值它不就是把原来的几个变换施以线性变换后得来的统计量吗？</p>
<p>所以如果X服从$N_p(\mu,\Sigma)$，则$E(X)$服从$N_p(\mu,\frac{1}{n}\Sigma)$。</p>
<p>更进一步，样本离差阵$S=\sum_{i=1}^n(X_i-E(X))(X_i-E(X))^T$里，括号里的$X_i-E(X)$就也服从正态分布，从而S就可以表达为$S=\sum_{i=1}^nZ_iZ_i^T$，其中Z服从正态分布。这式子你不觉得和卡方分布很像吗？我们如果将$ZZ^T$看做一种“Z的平方”，那这就是p维正态分布的平方和了。（数学上应该是倒过来，实际上一维情况下的所谓正态分布的平方和，应当是$ZZ^T$的特殊情况）</p>
<p>是的，1928年威沙特就提出了卡方分布的升级版——<strong>威沙特分布</strong>。</p>
<p>如果$X_{(a)}=(X_{a1},X_{a2},&hellip;,X_{ap})^T$服从$N_p(\mu_a,\Sigma)$且相互独立，那么由$X(a)$拼成的随机矩阵</p>
$$W_{p\times p}=\sum_{a=1}^nX_{(a)}X_{(a)}^T$$<p>就服从非中心威沙特分布$W_p(n,\Sigma,Z)$，其中$Z=\sum_{a=1}^n\mu_a\mu_a^T$，$\mu_a$被称为非中心参数。</p>
<p>特比的，当$\mu_a=0$时，这个非中心威沙特分布就退化成了中心威沙特分布，记作$W_p(n,\Sigma)$。</p>
<p>这个威沙特分布的密度函数非常“简洁”啊，我就不打了，打起来太麻烦了，反正你看了也记不住。</p>
<p>总之，这个威沙特分布是卡方分布在p维正态分布情况下的推广，所以他也兼容了卡方分布的性质，例如</p>
<p>威沙特分布的和还是威沙特分布，进一步威沙特分布的二次型还是威沙特分布。</p>
<p>当然，我们这里引入威沙特分布是为了给样本离差阵找个家，样本离差阵应当服从$W_p(n-1,\Sigma)$，至于这里自由度为什么是n-1我想一维情况就应该已经说过了才对。是因为离差阵里有均值，而由均值和n-1个$X_i$就能推出剩下的那一个$X_i$了。</p>
<p>另外，参考其他文献可以知道p维正态分布的均值和样本离差阵独立。</p>
<p>这些的证明都超级麻烦的，在这里就没法证明了。</p>
<p>如果你想要使用其他分布的密度函数等信息，其实没必要手算。</p>
<p>实际上，对于多元统计分析，由于我们的数据都是多元的而且多元分布的密度函数啊计算啊都比较复杂，所以我们其实也不会去手算这些东西的，他本来就应当使用计算机了。</p>
<p>在统计学里，常用的统计软件是SPSS和R以及Python。</p>
<p>SPSS使用非常简单，只需要点点点就可以了，我觉得没有太多的好说的地方。</p>
<p>Python的话，虽然现在也非常火热，但是讲的人很多不缺我一个。</p>
<p>R语言的话在统计上使用率其实不低，但是讲的人比较少，所以来唠唠这个吧，挑战一下。</p>
<p>R语言是一款专门为统计而生的软件或者也算是编程语言。</p>
<p>正因为他是为统计而生的，所以他内置了很多统计学需要使用的工具。</p>
<p>例如在我们这里，如果你想得到一个分布的密度函数（<strong>d</strong>ensity function），累积分布函数（distribution function，抱歉这个我实在找不到p这个字母），随机（ <strong>r</strong>andom ）数，下$\alpha$分位数（ <strong>q</strong>uantile function ），只需要使用d/p/r/q+对应分布名称就可以得到了。</p>
<p>例如在R语言中使用<code>?dnorm</code>命令可以查看dnorm的帮助文档。</p>
<p><img src="https://27ed0b40.cloudflare-imgbed-bo7.pages.dev/file/1735177606720_dnorm%e6%96%87%e6%a1%a3.png"
	
	
	
	loading="lazy"
	
		alt="dnorm文档.png"
	
	
></p>
<p>你将看到这四个函数。</p>
<p>d是密度函数的意思，p是累积分布函数，q是下$\alpha$分位点，r是随机数。而norm是正态分布的意思。</p>
<p>dnorm的第一个参数的密度函数的自变量，mean是正态分布的均值（默认为0），sd是<strong>标准差</strong>（默认为1），参数log或log.p是要不要给概率取对数的意思，默认是不取对数的。</p>
<p>pnorm是累积分布函数，第一个参数q是分布函数的自变量。lower.tail是指要不要“反转”。我们知道分布函数是从-∞积分到x，如果你把lower.tail改成FALSE（或者F），那R语言给你的分布函数就是从x积分到+∞。</p>
<p>qnorm其实是分位点，他的第一个参数p是自变量，lower.tail如果是默认的TRUE（或者T）那么R语言会给你下$\alpha$分位点，反之给你上$\alpha$分位点。</p>
<p>rnorm则是随机数，n表示你要几个随机数。</p>
<p>在R语言中内置了超级多分布，我随便举几个例子（并不完整，想看完整的请查阅文档）</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: left">分布名称</th>
          <th style="text-align: left">R语言函数（密度函数）</th>
          <th style="text-align: left">R语言函数（分布函数）</th>
          <th style="text-align: left">R语言函数（分位数函数）</th>
          <th style="text-align: left">R语言函数（随机数生成）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">正态分布</td>
          <td style="text-align: left">dnorm</td>
          <td style="text-align: left">pnorm</td>
          <td style="text-align: left">qnorm</td>
          <td style="text-align: left">rnorm</td>
      </tr>
      <tr>
          <td style="text-align: left">二项分布</td>
          <td style="text-align: left">dbinom</td>
          <td style="text-align: left">pbinom</td>
          <td style="text-align: left">qbinom</td>
          <td style="text-align: left">rbinom</td>
      </tr>
      <tr>
          <td style="text-align: left">泊松分布</td>
          <td style="text-align: left">dpois</td>
          <td style="text-align: left">ppois</td>
          <td style="text-align: left">qpois</td>
          <td style="text-align: left">rpois</td>
      </tr>
      <tr>
          <td style="text-align: left">指数分布</td>
          <td style="text-align: left">dexp</td>
          <td style="text-align: left">pexp</td>
          <td style="text-align: left">qexp</td>
          <td style="text-align: left">rexp</td>
      </tr>
      <tr>
          <td style="text-align: left">卡方分布</td>
          <td style="text-align: left">dchisq</td>
          <td style="text-align: left">pchisq</td>
          <td style="text-align: left">qchisq</td>
          <td style="text-align: left">rchisq</td>
      </tr>
      <tr>
          <td style="text-align: left">F分布</td>
          <td style="text-align: left">df</td>
          <td style="text-align: left">pf</td>
          <td style="text-align: left">qf</td>
          <td style="text-align: left">rf</td>
      </tr>
      <tr>
          <td style="text-align: left">t分布</td>
          <td style="text-align: left">dt</td>
          <td style="text-align: left">pt</td>
          <td style="text-align: left">qt</td>
          <td style="text-align: left">rt</td>
      </tr>
      <tr>
          <td style="text-align: left">Beta分布</td>
          <td style="text-align: left">dbeta</td>
          <td style="text-align: left">pbeta</td>
          <td style="text-align: left">qbeta</td>
          <td style="text-align: left">rbeta</td>
      </tr>
      <tr>
          <td style="text-align: left">Gamma分布</td>
          <td style="text-align: left">dgamma</td>
          <td style="text-align: left">pgamma</td>
          <td style="text-align: left">qgamma</td>
          <td style="text-align: left">rgamma</td>
      </tr>
      <tr>
          <td style="text-align: left">Weibull分布</td>
          <td style="text-align: left">dweibull</td>
          <td style="text-align: left">pweibull</td>
          <td style="text-align: left">qweibull</td>
          <td style="text-align: left">rweibull</td>
      </tr>
      <tr>
          <td style="text-align: left">Logistic分布</td>
          <td style="text-align: left">dlogis</td>
          <td style="text-align: left">plogis</td>
          <td style="text-align: left">qlogis</td>
          <td style="text-align: left">rlogis</td>
      </tr>
      <tr>
          <td style="text-align: left">对数正态分布</td>
          <td style="text-align: left">dlnorm</td>
          <td style="text-align: left">plnorm</td>
          <td style="text-align: left">qlnorm</td>
          <td style="text-align: left">rlnorm</td>
      </tr>
      <tr>
          <td style="text-align: left">威沙特分布</td>
          <td style="text-align: left">dwish</td>
          <td style="text-align: left">pwish</td>
          <td style="text-align: left">qwish</td>
          <td style="text-align: left">rwish</td>
      </tr>
  </tbody>
</table></div>
<p>但是对于某些分布，R语言可能确实没有自带的。</p>
<p>这时你可以通过命令<code>install.packages(包名)</code>安装第三方扩展库。</p>
<p>也可以自己书写或采样。</p>
<p>例如我曾经在B站介绍了<a class="link" href="https://www.bilibili.com/opus/823005107895402761"  target="_blank" rel="noopener"
    >逆变换采样法</a>。网址：https://www.bilibili.com/opus/823005107895402761</p>
<p>今天多送你一个。</p>
<h3 id="格式点离散化方法">格式点离散化方法
</h3><p>通过格式点离散化方法利用随机变量的密度函数p(x)抽样。</p>
<p>方法非常简单，分为4步。</p>
<ul>
<li>在密度函数p(x)的有效取值范围取N个等距节点</li>
<li>计算$p(x_i)$</li>
<li>正则化$p(x_i)$，即给每一个$p(x_i)$除以$\sum_{i=1}^np(x_i)$</li>
<li>将正则化后的函数看做离散型随机变量的分布律，再有放回地抽样n个数</li>
</ul>
<p>这样得到的n个数就是n个服从概率密度为p(x)的随机数了。</p>
<p>我们以标准正态分布为例进行R语言实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 设置节点数量</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span> <span class="o">&lt;-</span> <span class="m">1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 生成节点，这里以标准正态分布为例，取值范围大致在[-5, 5]</span>
</span></span><span class="line"><span class="cl"><span class="n">nodes</span> <span class="o">&lt;-</span> <span class="nf">seq</span><span class="p">(</span><span class="m">-5</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="n">length.out</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算每个节点的概率密度</span>
</span></span><span class="line"><span class="cl"><span class="n">densities</span> <span class="o">&lt;-</span> <span class="nf">dnorm</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 正则化概率密度</span>
</span></span><span class="line"><span class="cl"><span class="n">normalized_densities</span> <span class="o">&lt;-</span> <span class="n">densities</span> <span class="o">/</span> <span class="nf">sum</span><span class="p">(</span><span class="n">densities</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 抽样，生成随机数</span>
</span></span><span class="line"><span class="cl"><span class="n">n_samples</span> <span class="o">&lt;-</span> <span class="m">1000</span>
</span></span><span class="line"><span class="cl"><span class="n">samples</span> <span class="o">&lt;-</span> <span class="nf">sample</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">normalized_densities</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用rnorm函数生成随机数进行比较</span>
</span></span><span class="line"><span class="cl"><span class="n">rnorm_samples</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 绘制直方图进行比较</span>
</span></span><span class="line"><span class="cl"><span class="nf">par</span><span class="p">(</span><span class="n">mfrow</span> <span class="o">=</span> <span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span>  <span class="c1"># 设置绘图区域为1行2列</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 绘制格式点离散化方法的样本直方图</span>
</span></span><span class="line"><span class="cl"><span class="nf">hist</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">breaks</span> <span class="o">=</span> <span class="m">30</span><span class="p">,</span> <span class="n">main</span> <span class="o">=</span> <span class="s">&#34;格式点离散化方法样本&#34;</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="s">&#34;值&#34;</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="s">&#34;blue&#34;</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">curve</span><span class="p">(</span><span class="nf">dnorm</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">add</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="s">&#34;red&#34;</span><span class="p">,</span> <span class="n">lwd</span> <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 绘制rnorm函数生成的样本直方图</span>
</span></span><span class="line"><span class="cl"><span class="nf">hist</span><span class="p">(</span><span class="n">rnorm_samples</span><span class="p">,</span> <span class="n">breaks</span> <span class="o">=</span> <span class="m">30</span><span class="p">,</span> <span class="n">main</span> <span class="o">=</span> <span class="s">&#34;rnorm函数样本&#34;</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="s">&#34;值&#34;</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="s">&#34;blue&#34;</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">curve</span><span class="p">(</span><span class="nf">dnorm</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">add</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="s">&#34;red&#34;</span><span class="p">,</span> <span class="n">lwd</span> <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们来解析一下上面的代码。</p>
<p>其实也都加了注释了的。</p>
<p>在R语言中等号=和箭头&lt;-都可以用来赋值。我们这里先把1000赋值给了N，然后<code>seq(-5, 5, length.out = N)</code>表示在-5到+5生成N个等距节点。</p>
<p>再用<code>densities &lt;- dnorm(nodes)</code>生成节点处的密度函数取值。</p>
<p><code>sum(densities)</code>计算了密度函数取值的和。</p>
<p><code>normalized_densities &lt;- densities / sum(densities)</code>就将正则化后的结果赋给了变量normalized_densities。</p>
<p>接下来我们看最重点的<code>samples &lt;- sample(nodes, n_samples, prob = normalized_densities, replace = TRUE)</code>。</p>
<p>观察sample的文档。</p>
<p><img src="https://27ed0b40.cloudflare-imgbed-bo7.pages.dev/file/1735179354016_sample%e6%96%87%e6%a1%a3.png"
	
	
	
	loading="lazy"
	
		alt="sample文档.png"
	
	
></p>
<p>可以看到，sample是用于采样的函数。</p>
<p><code>samples &lt;- sample(nodes, n_samples, prob = normalized_densities, replace = TRUE)</code>中nodes是从哪里采样，在格式点离散化方法中是从等距节点中采样。第二个参数n_samples是要取几个采样点。prob是各采样点出现的概率。replace=TRUE表示要进行有放回采样。</p>
<p>后面的代码只是绘图并且与R语言自带的rnorm进行比较罢了。</p>
<p><img src="https://27ed0b40.cloudflare-imgbed-bo7.pages.dev/file/1735179719780_image.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>这是最后的绘图，可以看到我们用格式点离散化方法得到的随机数和R语言自带的rnorm非常接近，其频率直方图也和标准正态分布的密度函数（红线）很接近。</p>
<h3 id="矩估计">矩估计
</h3><p>好了好了，有了一个具体的分布，我们重要可以开始正题了。</p>
<p>还记得标题吗？</p>
<p>标题是参数估计。</p>
<p>我们从最简单的矩估计开始。</p>
<p>矩估计的统计依据是大数定律。</p>
<p>简单说就是样本的矩依概率收敛于样本的矩。</p>
<p>这么说肯定听不懂啊哈哈。</p>
<p>一个随机变量X的q阶矩，指的是$E(X^q)$。</p>
<p>而更多的时候我们会对随机变量进行中心化（也就是减去均值），从而得到中心矩$E((X-E(x))^q)$。</p>
<p>显然，随机变量的1阶矩就是均值，而2阶中心矩就是方差，这刚好就是他们的定义嘛。</p>
<p>所以我们最常用的就是这两个。</p>
<p>例如，你要估计样本均值为$\mu$，样本方差为S的p维正态分布的均值和方差，按照矩估计的原理直接就得到了，随机变量的均值=样本的均值=$\mu$，随机变量的方差=样本的二阶中心矩=样本的方差=S。</p>
<p>这就是矩估计了。</p>
<h3 id="极大似然估计">极大似然估计
</h3><p>下一个常见的估计方法是极大似然估计。</p>
<p>极大似然估计的统计思想是，一件事情如果发生了我应该往哪里估呢？应该往概率最大的地方估。</p>
<p>例如，X服从$N_p(\mu,\Sigma)$，你通过观测得到他的样本资料矩阵为X=($X_1$,$X_2$,&hellip;,$X_n$)。</p>
<p>那么为什么你观察到的资料阵是X呢？</p>
<p>因为这个事件（第一次观测$X=X_1$，然后$X=X_2,X=X_3,&hellip;$）出现的概率最大嘛。</p>
<p>而各个观测是独立的，所以上述事件发生的概率就是各概率的乘积即上述事件发生的概率是$L=\prod_{i=1}^nP(X=X_i)$。</p>
<p>那我们要估计的参数$\mu,\Sigma$就是使得L最大的参数。</p>
<p>在这里L被称为似然函数，但是实际上似然函数是一堆连乘处理起来很麻烦，所以我们常用的是对数似然函数，也就是两边取自然对数得到</p>
$$\ln(L)=\sum_{i=1}^n\ln(P=(X=X_i))$$<p>现在我们以多元正态分布$N_p(\mu,\Sigma)$进行演算。</p>
<p>先求似然函数，$L=\prod_{i=1}^nP(X=X_i)=\prod_{i=1}^n\frac{e^{-\frac{1}{2}(X_i-\mu)^T\Sigma^{-1}(X_i-\mu)}}{(2\pi)^{\frac{p}{2}}|\Sigma|^{\frac{1}{2}}}$</p>
<p>然后开始计算，分母都是常数，连乘n次就变成n次方。</p>
<p>分子是e指数，指数相乘底数不变指数相加。</p>
<p>$L=\frac{e^{-\frac{1}{2}\sum_{i=1}^n(X_i-\mu)^T\Sigma^{-1}(X_i-\mu)}}{(2\pi)^{\frac{np}{2}}|\Sigma|^{\frac{n}{2}}}$</p>
<p>然后计算对数似然函数$\ln(L)=-\frac{1}{2}\sum_{i=1}^n(X_i-\mu)^T\Sigma^{-1}(X_i-\mu)-\frac{np}{2}\ln(2\pi)-\frac{n}{2}\ln|\Sigma|$</p>
<p>接着只需要求参数$\mu,\Sigma$使得ln(L)最大就可以了。</p>
<p>那只需要验证KKT点即可，对于这种无约束极值就是找偏导数为0的点即驻点。</p>
<p>但是问题来了，这里的参数都是矩阵欸，你会对矩阵求导吗？</p>
<h3 id="矩阵和向量的导数">矩阵和向量的导数
</h3><p>所以现在还得倒过来补补基础了。</p>
<p>最基础的情况是一个多元函数对向量的导数。</p>
<p>然而，这里有两种写法。一种被称为分母布局，一种被称为分子布局，两种差一个转置。</p>
<p>对于多元函数$f(x_1,x_2,&hellip;,x_n)$和n维向量$X=(x_1,x_2,x_3,&hellip;,x_n)^T$，</p>
<p>分母布局的结果是$\frac{\partial f}{\partial X}=(\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\frac{\partial f}{\partial x_3},&hellip;,\frac{\partial f}{\partial x_n})^T$</p>
<p>这也就是所谓的f的梯度$\nabla f(X)$。</p>
<p>也就是多元函数的一阶导和梯度等同。</p>
<p>分子布局就是他的转置，以后我也不再说明，因为我都会使用分母布局。</p>
<p>而如果f也是一个向量，那情况会麻烦一些。</p>
<p>我们设$F=(f_1(X),f_2(X),&hellip;,f_m(X))^T=(f_1(x_1,x_2,&hellip;,x_n),f_2(x_1,&hellip;,x_n),&hellip;,f_m(x_1,&hellip;,x_n))^T$</p>
<p>那么理想的情况是：</p>
<p>$\frac{\partial F}{\partial X}=(\frac{\partial f_1}{\partial X},..,\frac{\partial f_n}{\partial X})^T$</p>
<p>然而，这时候$\frac{\partial f_1}{\partial X}$却是一个列向量，上面这玩意根本就不是个矩阵，炸裂！</p>
<p>所以这时候我们会再进行一个转置，即</p>
<p>$\frac{\partial F}{\partial X}=((\frac{\partial f_1}{\partial X})^T,..,(\frac{\partial f_n}{\partial X})^T)^T$</p>
<p>然后再写开，这样就得到了一个矩阵：</p>
<p>$\frac{\partial F}{\partial X} =
\begin{pmatrix}
\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_1}{\partial x_n} \
\frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_2}{\partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial f_m}{\partial x_1} &amp; \frac{\partial f_m}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_n}
\end{pmatrix}$</p>
<p>而这个矩阵呢，有一个名字叫做<strong>雅可比矩阵</strong>，有时记作J。（注意，你看到的文献也许和这个差一个转置，这是因为他采用的是分子布局）</p>
<p>在多元统计的公式里，多元向量函数的一阶导和雅可比矩阵等同。</p>
<p>而与多元向量函数的二阶导等同的是<strong>黑塞矩阵</strong>，但是多元向量函数F（X）的黑塞矩阵是三维的$H =
\begin{pmatrix}
\frac{\partial^2 f_1}{\partial x_1^2} &amp; \frac{\partial^2 f_1}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_1}{\partial x_1 \partial x_n} \
\frac{\partial^2 f_1}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f_1}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f_1}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f_1}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f_1}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_1}{\partial x_n^2}
\end{pmatrix},
\begin{pmatrix}
\frac{\partial^2 f_2}{\partial x_1^2} &amp; \frac{\partial^2 f_2}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_2}{\partial x_1 \partial x_n} \
\frac{\partial^2 f_2}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f_2}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f_2}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f_2}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f_2}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_2}{\partial x_n^2}
\end{pmatrix},
\ldots,
\begin{pmatrix}
\frac{\partial^2 f_m}{\partial x_1^2} &amp; \frac{\partial^2 f_m}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_m}{\partial x_1 \partial x_n} \
\frac{\partial^2 f_m}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f_m}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f_m}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f_m}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f_m}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f_m}{\partial x_n^2}
\end{pmatrix}$</p>
<p>非常炸裂。</p>
<p>所以你只需要知道普通的多元函数f(X)的黑塞矩阵就可以了。</p>
<p>$H =
\begin{pmatrix}
\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \
\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
\end{pmatrix}$</p>
<p>H的（i，j）元就是对应的二阶混合偏导嘛，也不难的。</p>
<p>我们也可以来推导看看，他为什么和f(X)的二阶导等同。</p>
<p>我们设$f=f(X)=f(x_1,x_2,&hellip;,x_n)$</p>
<p>那么，前面我们说过：</p>
<p>$\frac{\partial f}{\partial X}=(\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\frac{\partial f}{\partial x_3},&hellip;,\frac{\partial f}{\partial x_n})^T$这是一个列向量。</p>
<p>接着我们再进行一次求导，这就是对列向量进行求导，得到：</p>
<p>$\frac{\partial ^2f}{\partial X^2}=(\frac{\partial }{\partial X}(\frac{\partial f}{\partial x_1})^T,..,\frac{\partial f_n}{\partial X}(\frac{\partial f}{\partial x_n})^T)^T$</p>
<p>也就是</p>
<p>$\begin{pmatrix}
\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \
\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
\end{pmatrix}=H$</p>
<p>所以</p>
<p>$\frac{\partial ^2f}{\partial X^2}=\begin{pmatrix}
\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \
\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
\end{pmatrix}=H$</p>
<p>这也是为什么我们说，对普通的一元函数来说，它的黑塞矩阵和二阶导等同。</p>
<p>如果接下来，你要对f求三阶导，那就是对黑塞矩阵求导，自然你会得到一个三维矩阵，也非常炸裂，就不多说了。</p>
<p>雅可比矩阵和黑塞矩阵在这个系列中只会出现在理论推导里，而实际运算的时候不会涉及到。</p>
<p>在实际计算的时候我们更多地会遇见下面几个公式，可以自己用上面的定义推导一下，都不难。</p>
<p>$\frac{\partial (AX)}{\partial X}=A^T$（如果是分子布局则不用转置）</p>
<p>$\frac{X^TAX}{\partial X}=AX+A^TX$，特别的当A为对称阵的时候我们知道$X^TAX$为二次型，此时$\frac{X^TAX}{\partial X}=AX+A^TX=2AX$</p>
<p>$\frac{\partial (X^TAX)}{\partial A}=X^TX$</p>
<p>$\frac{\ln|A|}{\partial A}=A^{-1}$</p>
<p>至于求导法则，都是兼容的。</p>
<p>但是有一个要注意的，就是链式法则。</p>
<p>在一元情况下我们说$\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$，这个式子看着特别漂亮，似乎可以把du约掉一样，但是在多元的时候情况就不一样了。</p>
<p>$\frac{\partial y}{\partial x}=\frac{\partial u}{\partial x}\frac{\partial y}{\partial u}$</p>
<p>这看起来只是把式子右边两个导数换了一下位置，其实不是这样的。</p>
<p>在多元情况下，你也看到了，求导的结果是一个矩阵，矩阵乘法是不满足交换律的。实际上链式法则就应该是我们下面给出的这个形式而不是一元的那个漂亮的形式。那个形式反而是用一元情况下数的交换律交换出来的。这也是为什么前面反复强调，求导这里你不能把$\frac{dy}{dx}$简单地看做微分dy除以微分dx，这只是形式上的结果而已。同样你也不能认为链式法则里我们只是在分式上约掉了du，这也只是一元链式法则在形式上的结果而已。</p>
<h3 id="多元正态分布的极大似然估计">多元正态分布的极大似然估计
</h3><p>好了，现在我们继续推导多元正态分布的极大似然估计吧。</p>
<p>前面我们已经推导到，多元正态分布的极大似然估计只需要找到$\mu,\Sigma$使得下面这个对数似然函数最大即可。</p>
<p>$\ln(L)=-\frac{1}{2}\sum_{i=1}^n(X_i-\mu)^T\Sigma^{-1}(X_i-\mu)-\frac{np}{2}\ln(2\pi)-\frac{n}{2}\ln|\Sigma|$</p>
<p>那么我们要做的是求对数似然函数的驻点，就是要解方程$\frac{\partial \ln(L)}{\partial \mu}=0$和$\frac{\partial \ln(L)}{\partial \Sigma}=0$</p>
<p>我们先来算$\frac{\partial \ln(L)}{\partial \mu}$，和$\mu$有关的只有$-\frac{1}{2}\sum_{i=1}^n(X_i-\mu)^T\Sigma^{-1}(X_i-\mu)$这一项，而这一项里求和号可以和求导交换位置，求和号内部则是一个二次型的导数，利用前面的公式$\frac{X^TAX}{\partial X}=AX+A^TX=2AX$即可。</p>
<p>所以$\frac{\partial \ln(L)}{\partial \mu}=-\frac{\partial \ln(L)}{\partial (X_i-\mu)}=\sum_{i=1}^n\Sigma^{-1}(X_i-\mu)=0$</p>
<p>同理$\frac{\partial \ln(L)}{\partial \Sigma}=\frac{1}{2}\sum_{i=1}^n(X_i-\mu)(X_i-\mu)^T(\Sigma^{-1})^2-\frac{n}{2}\Sigma^{-1}=0$</p>
<p>然后解方程就可以了，解得$\mu=\frac{1}{n}\sum_{i=1}^nX_i=E(X),\Sigma=\frac{1}{n}\sum_{i=1}^n(X_i-E(X))(X_i-E(X))^T=\frac{1}{n}S$</p>
<p>上面的解里，第一个等式是直接求解的结果，第二个等式则是将结果用我们前面说的样本的统计量替换了。</p>
<p>我们可以看到，多元正态分布均值的极大似然估计就是样本均值向量，而方差则是$\frac{1}{n}$乘以样本离差阵。</p>
<p>需要注意的是，我们前面定义的样本协方差阵是$\frac{1}{n-1}S$而不是这里的$\frac{1}{n}S$（当然也有教材直接把$\frac{1}{n}$定义为样本协方差阵的）。</p>
<p>但是我们更要注意的是，只有$\frac{1}{n-1}S$才是方差的无偏估计，这里我们用极大似然估计推导出来的$\frac{1}{n}S$只是方差的一致估计（即当n趋于无穷大时结果和无偏估计一致）。</p>
<h3 id="牛顿法求数值解">牛顿法求数值解
</h3><p>在上面的过程中我们可以看到，无论是用矩估计还是极大似然估计，其核心都是求解方程组，然而大多数多元分布的密度函数都超级复杂，从而你根本解不动方程。我们在上个系列（数值计算方法中）已经介绍过如何用迭代法求解一维非线性方程组的数值解了，在这里简单地推广一下。</p>
<p>一维情况下方程f(x)=0有牛顿迭代格式$x_{k+1}=x_k-\frac{f(x_k)}{f&rsquo;(x_k)}$，而到了多元情况我们会得到n个方程即</p>
<p>$f_1(X)=0,f_2(X)=0,&hellip;,f_n(X)=0$</p>
<p>我们知道，可以用同一个向量$F(X)=0$表达，这时的情况就和一元的f(x)=0在形式上差不多了。</p>
<p>迭代格式的话也是一样的，也就是直观上不严谨地说$X_{k+1}=X_k-\frac{F(X_k)}{F&rsquo;(X_k)}$。</p>
<p>但是前面我们已经说过，对向量函数对另一个向量X的所谓导数$\frac{\partial F}{\partial X} =
\begin{pmatrix}
\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_1}{\partial x_n} \
\frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_2}{\partial x_n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
\frac{\partial f_m}{\partial x_1} &amp; \frac{\partial f_m}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_n}
\end{pmatrix}$是雅可比矩阵J(X)。</p>
<p>那么就炸裂了，式子里所谓的除以F（X)的“导数”到底是左乘J的逆还是右乘？</p>
<p>答案是左乘。</p>
<p>$X_{k+1}=X_{k}-J^{-1}(X_k)F(X_k)$</p>
<p>而如果是极大似然估计，我们最终是要求导函数的零点，也就是F（X）本身就是一阶导了，那么再代入迭代格式就是要用所谓的一阶导替代f（x）用所谓的二阶导替代f&rsquo;（x）。</p>
<p>我们知道，一元情况的一阶导和雅可比矩阵等同，一元情况的二阶导和黑塞矩阵等同。</p>
<p>所以如果我想直接用牛顿法求普通的多元函数f(X)的极值点的话，前面我们说过对多元函数f(X)和一阶导等同的是梯度$\nabla f(X)$，和二阶导等同的是黑塞矩阵H（X）。</p>
<p>从而求普通多元函数f(X)的极值点，就是解方程$\nabla f(X)=0$</p>
<p>再用牛顿法求数值解就得用迭代格式：</p>
<p>$X_{k+1}=X_k-H^{-1}(X_k)\nabla f(X)$</p>
<h3 id="r语言实现">R语言实现
</h3><p>可以看到，无论是矩估计还是极大似然估计，其本身并没有难点，最后的落脚点都是如何求解一个非线性方程的数值解。</p>
<p>这时候你可以MATLAB启动，也可以继续用R语言。</p>
$$ \begin{cases} x_1^2 + x_2^2 - 5 = 0, \\ (x_1 + 1)x_2 - (3x_1 + 1) = 0. \end{cases} $$<p>要用牛顿迭代法实现，就得先求其一阶导也就是雅可比矩阵。</p>
$$J(x) = \begin{pmatrix} 2x_1 & 2x_2 \\ x_2 - 3 & x_1 + 1 \end{pmatrix}$$<p>然后就可以写代码了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 定义一个函数fun，用于计算非线性方程组的函数值和雅可比矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">fun</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 计算非线性方程组的函数值</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">x[1]^2</span> <span class="o">+</span> <span class="n">x[2]^2</span> <span class="o">-</span> <span class="m">5</span><span class="p">,</span> <span class="c1"># 第一个方程</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">x[1]</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x[2]</span> <span class="o">-</span> <span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">x[1]</span> <span class="o">+</span> <span class="m">1</span><span class="p">))</span> <span class="c1"># 第二个方程</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 计算非线性方程组的雅可比矩阵</span>
</span></span><span class="line"><span class="cl">  <span class="n">J</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">x[1]</span><span class="p">,</span> <span class="m">2</span> <span class="o">*</span> <span class="n">x[2]</span><span class="p">,</span> <span class="c1"># 第一行的梯度</span>
</span></span><span class="line"><span class="cl">                <span class="n">x[2]</span> <span class="o">-</span> <span class="m">3</span><span class="p">,</span> <span class="n">x[1]</span> <span class="o">+</span> <span class="m">1</span><span class="p">),</span> <span class="c1"># 第二行的梯度</span>
</span></span><span class="line"><span class="cl">              <span class="n">nrow</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">byrow</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span> <span class="c1"># 确定矩阵的行数，并按行填充</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 返回函数值和雅可比矩阵的列表</span>
</span></span><span class="line"><span class="cl">  <span class="nf">list</span><span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个函数newton，用于实现牛顿法求解非线性方程组</span>
</span></span><span class="line"><span class="cl"><span class="n">newton</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="m">1e-5</span><span class="p">,</span> <span class="n">max.iter</span> <span class="o">=</span> <span class="m">100</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># fun是待求解的非线性方程组，x是初始点，eps是判断迭代收敛的条件，这里认为两次迭代的根的差小于1e-5为收敛</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># max.iter为最大迭代次数，如果超过这个迭代次数都没有收敛则认为牛顿法求解失败。</span>
</span></span><span class="line"><span class="cl">  <span class="n">iter</span> <span class="o">&lt;-</span> <span class="m">0</span> <span class="c1"># 初始化迭代次数</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span> <span class="o">&lt;-</span> <span class="m">0</span> <span class="c1"># 初始化收敛标志为不收敛0</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 开始迭代，直到达到最大迭代次数</span>
</span></span><span class="line"><span class="cl">  <span class="kr">while</span><span class="p">(</span><span class="n">iter</span> <span class="o">&lt;</span> <span class="n">max.iter</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">x</span> <span class="c1"># 保存当前迭代点</span>
</span></span><span class="line"><span class="cl">    <span class="n">obj</span> <span class="o">&lt;-</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># 计算当前点的函数值和Jacobi矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 更新x值，使用当前的函数值和Jacobi矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x</span> <span class="o">-</span> <span class="nf">solve</span><span class="p">(</span><span class="n">obj</span><span class="o">$</span><span class="n">J</span><span class="p">,</span> <span class="n">obj</span><span class="o">$</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查是否收敛，即新x值与旧x值的2范数是否小于阈值eps</span>
</span></span><span class="line"><span class="cl">    <span class="kr">if</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">flag</span> <span class="o">&lt;-</span> <span class="m">1</span> <span class="c1"># 设置收敛标志为收敛1</span>
</span></span><span class="line"><span class="cl">      <span class="kr">break</span> <span class="c1"># 如果收敛，则跳出循环</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">&lt;-</span> <span class="n">iter</span> <span class="o">+</span> <span class="m">1</span> <span class="c1"># 增加迭代次数</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 返回结果列表，包括根、迭代次数、收敛标志和最终的函数值</span>
</span></span><span class="line"><span class="cl">  <span class="nf">list</span><span class="p">(</span><span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">$</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用牛顿法求解非线性方程组，初始点为c(0,1)</span>
</span></span><span class="line"><span class="cl"><span class="nf">newton</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码注释已经很详细了。</p>
<p>你需要注意的是，在这里雅可比矩阵是我们手动求解的。</p>
<p>然后<code>x &lt;- x - solve(obj$J, obj$f)</code>，这里的solve函数其实是用来解线性方程组AX=B的。</p>
<p>我们知道AX=B的解就是$A^{-1}B$，所以这里可以用solve来求$J^{-1}F$。</p>
<p><code>norm(x1 - x, &quot;2&quot;)</code>这里的norm用于求解矩阵或向量的范数，后面的2表明求解的是2-范数。范数的概念已经在上一个系列（数值计算方法）说明了，这里就不再废话了。</p>
<p>虽然用上面的方法可以求解非线性方程组的根，但是每次都这么计算一通非常麻烦。</p>
<p>我们可以调用R语言自带的包直接求解。</p>
<p>针对一元非线性方程，直接使用uniroot函数即可求解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="n">f</span><span class="o">&lt;-</span><span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x^3</span><span class="o">-</span><span class="n">x</span><span class="m">-1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">uniroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行结果的话是这样的。</p>
<p><img src="https://27ed0b40.cloudflare-imgbed-bo7.pages.dev/file/1735181061120_%e4%b8%80%e5%85%83%e6%96%b9%e7%a8%8b%e6%b1%82%e8%a7%a3.png"
	
	
	
	loading="lazy"
	
		alt="一元方程求解.png"
	
	
></p>
<p>这里函数f是$x^3-x-1$，就表明我们要求解$x^3-x-1=0$的根。</p>
<p>我们向uniroot传入的第二个参数是零点可能存在的区间[1,2]。</p>
<p>然后我们得到的结果是一个列表，包含以下元素：</p>
<ul>
<li><code>root</code>: 这是函数 <code>f</code> 的根，即在区间 <code>[1, 2]</code> 内使得 <code>f(x) = 0</code> 的 <code>x</code> 值。在这个例子中，根的值是 <code>1.324718</code>。</li>
<li><code>f.root</code>: 这是函数 <code>f</code> 在找到的根处的函数值。理论上，这个值应该接近于零，因为根就是函数值为零的点。在这个例子中，函数值是 <code>-5.634261e-07</code>，这是一个非常接近于零的数，表明找到了一个很好的近似根。</li>
<li><code>iter</code>: 这是 <code>uniroot</code> 函数找到根所需的迭代次数。在这个例子中，进行了7次迭代。</li>
<li><code>init.it</code>: 这是初始迭代次数，但在您的结果中显示为 <code>NA</code>，这可能是因为 <code>uniroot</code> 函数没有提供这个信息。</li>
<li><code>estim.prec</code>: 这是估计的精度，即函数值在根处的绝对误差的上界。在这个例子中，估计精度是 <code>6.103516e-05</code>，这意味着函数值在根处的误差不会超过这个值。</li>
</ul>
<p>总结来说，<code>uniroot</code> 函数在区间 <code>[1, 2]</code> 内找到了函数 <code>f(x) = x^3 - x - 1</code> 的一个根，大约在 <code>x = 1.324718</code>，并且在这个点处函数值非常接近于零，表明找到了一个有效的根。</p>
<p>(感谢智谱chatglm的回答，帮我省了几秒钟的打字时间，要是他能学会解数学题就好了啊哈哈，那我直接天天用ai发文啊哈哈哈哈哈哈哈）</p>
<p>如果你想求解多元非线性方程组，那只能借助第三方库了。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 安装rootSolve库，如果尚未安装的话</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">require</span><span class="p">(</span><span class="n">rootSolve</span><span class="p">,</span> <span class="n">quietly</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">install.packages</span><span class="p">(</span><span class="s">&#34;rootSolve&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加载rootSolve库</span>
</span></span><span class="line"><span class="cl"><span class="nf">library</span><span class="p">(</span><span class="n">rootSolve</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个函数fun2，用于计算非线性方程组的函数值</span>
</span></span><span class="line"><span class="cl"><span class="n">fun2</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 方程组由两个方程组成</span>
</span></span><span class="line"><span class="cl">  <span class="nf">c</span><span class="p">(</span><span class="n">x[1]^2</span> <span class="o">+</span> <span class="n">x[2]^2</span> <span class="o">-</span> <span class="m">5</span><span class="p">,</span>     <span class="c1"># 第一个方程：x1^2 + x2^2 = 5</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">x[1]</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x[2]</span> <span class="o">-</span> <span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">x[1]</span> <span class="o">+</span> <span class="m">1</span><span class="p">))</span> <span class="c1"># 第二个方程：(x1 + 1) * x2 = 3 * x1 + 1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用multiroot函数求解非线性方程组，初始点为c(0,1)</span>
</span></span><span class="line"><span class="cl"><span class="nf">multiroot</span><span class="p">(</span><span class="n">fun2</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 结果解释：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $root</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 1 2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示找到的方程组的根是 x1 = 1, x2 = 2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $f.root</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 5.713896e-07 1.923389e-07</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示在找到的根处，方程组的函数值非常接近于零，分别是 5.713896e-07 和 1.923389e-07</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $iter</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 6</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示找到根所需的迭代次数是6次</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $estim.precis</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 3.818642e-07</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示估计的精度，即函数值在根处的绝对误差的上界是 3.818642e-07</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>AI直接生成了这么完备的解释，我也只能闭嘴了。</p>
<p>但是我们其实还可以更懒。</p>
<p>上面的代码只对矩估计比较方便，但是对极大似然估计，我们还得自己来求解一阶导，非常麻烦。</p>
<p>所以我们应该直接使用R语言提供的优化问题的函数。</p>
<p>一元情况直接调用R语言提供的optimize函数，不过他默认求的是最小值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 定义一个函数f，该函数计算cos(x^2)</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cos</span><span class="p">(</span><span class="n">x^2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用optimize函数寻找函数f在区间[0, 2]内的最小值</span>
</span></span><span class="line"><span class="cl"><span class="n">result_min</span> <span class="o">&lt;-</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 结果解释：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $minimum</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 1.772453</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示函数f在区间[0, 2]内的最小值点大约在x = 1.772453</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $objective</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] -1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示在最小值点处，函数f的值为-1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用optimize函数寻找函数f在区间[0, 2]内的最大值，设置maximum=TRUE</span>
</span></span><span class="line"><span class="cl"><span class="n">result_max</span> <span class="o">&lt;-</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 结果解释：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $maximum</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 7.8628e-05</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示函数f在区间[0, 2]内的最大值点大约在x = 7.8628e-05</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $objective</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示在最大值点处，函数f的值为1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是找普通的多元函数的极小值就可以借助nlm函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 定义一个函数fr，该函数接受一个向量x，并计算一个关于x的代价函数</span>
</span></span><span class="line"><span class="cl"><span class="n">fr</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">x[1]</span>  <span class="c1"># 提取x的第一个元素</span>
</span></span><span class="line"><span class="cl">  <span class="n">x2</span> <span class="o">&lt;-</span> <span class="n">x[2]</span>  <span class="c1"># 提取x的第二个元素</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 计算并返回代价函数的值</span>
</span></span><span class="line"><span class="cl">  <span class="m">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用nlm函数找到函数fr的最小值，初始猜测为c(-1.2, 1)</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">&lt;-</span> <span class="nf">nlm</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="m">-1.2</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 结果解释：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $minimum</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 3.973766e-12</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示函数fr在找到的最小值点处的函数值，非常接近于0，说明找到了一个很好的最小值点</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $estimate</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 0.999998 0.999996</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示函数fr的最小值点估计，即x1约为0.999998，x2约为0.999996</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $gradient</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] -6.539320e-07 3.336018e-07</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示在最小值点处的梯度，梯度接近于0，说明该点可能是局部最小值点</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $code</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示nlm函数的退出代码，1表示收敛</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $iterations</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1] 23</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这表示找到最小值所需的迭代次数，这里进行了23次迭代</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，你如果还是想用刚刚介绍的牛顿法手搓也是可以的。</p>
<p>第一步还是定义要求解的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 定义fr函数，它接受一个向量x作为输入</span>
</span></span><span class="line"><span class="cl"><span class="n">fr</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">x[1]</span>  <span class="c1"># 提取x的第一个元素，赋值给x1</span>
</span></span><span class="line"><span class="cl">  <span class="n">x2</span> <span class="o">&lt;-</span> <span class="n">x[2]</span>  <span class="c1"># 提取x的第二个元素，赋值给x2</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 计算并返回fr函数的值</span>
</span></span><span class="line"><span class="cl">  <span class="m">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后参考迭代格式：</p>
<p>$X_{k+1}=X_k-H^{-1}(X_k)\nabla f(X)$</p>
<p>我们得先求f的梯度，你可以自己手动求解，也可以用我们在前一个系列数值计算方法里的数值微分方法求解。</p>
<p>我们这里就用最简单的差分法求解了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 定义一个非常小的数delta，用于数值微分</span>
</span></span><span class="line"><span class="cl"><span class="n">delta</span> <span class="o">&lt;-</span> <span class="m">1e-5</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 定义初始点x0</span>
</span></span><span class="line"><span class="cl"><span class="n">x0</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="m">1.5</span><span class="p">,</span> <span class="m">1.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用差分法计算梯度向量的第一个分量（关于x1的偏导数）</span>
</span></span><span class="line"><span class="cl"><span class="n">grd.x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="nf">fr</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1.5</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="m">1.5</span><span class="p">))</span> <span class="o">-</span> <span class="nf">fr</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span> <span class="o">/</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用差分法计算梯度向量的第二个分量（关于x2的偏导数）</span>
</span></span><span class="line"><span class="cl"><span class="n">grd.y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="nf">fr</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1.5</span><span class="p">,</span> <span class="m">1.5</span> <span class="o">+</span> <span class="n">delta</span><span class="p">))</span> <span class="o">-</span> <span class="nf">fr</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span> <span class="o">/</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 将计算得到的梯度分量组合成一个向量</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">grd</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">grd.x</span><span class="p">,</span> <span class="n">grd.y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">## [1] 451.0105 -149.9990</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样地，你也可以使用第三方库直接计算梯度和黑塞矩阵。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 加载numDeriv包以使用其函数来计算梯度向量和黑塞矩阵</span>
</span></span><span class="line"><span class="cl"><span class="nf">library</span><span class="p">(</span><span class="n">numDeriv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用numDeriv包中的grad函数计算梯度向量</span>
</span></span><span class="line"><span class="cl"><span class="n">grad_val</span> <span class="o">&lt;-</span> <span class="nf">grad</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="m">1.5</span><span class="p">,</span> <span class="m">1.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用numDeriv包中的hessian函数计算黑塞矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">hess_val</span> <span class="o">&lt;-</span> <span class="nf">hessian</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="m">1.5</span><span class="p">,</span> <span class="m">1.5</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些代码还是比较简单的。</p>
<p>我们这里给一个利用numDeriv包求解梯度和黑塞矩阵再用牛顿法求解的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-R" data-lang="R"><span class="line"><span class="cl"><span class="c1"># 加载numDeriv包，用于计算梯度向量和黑塞矩阵</span>
</span></span><span class="line"><span class="cl"><span class="nf">library</span><span class="p">(</span><span class="n">numDeriv</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义牛顿法函数</span>
</span></span><span class="line"><span class="cl"><span class="n">newton</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="m">1e-5</span><span class="p">,</span> <span class="n">n.max</span><span class="o">=</span><span class="m">100</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x0</span>  <span class="c1"># 初始化x为初始猜测值x0</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">&lt;-</span> <span class="m">0</span>  <span class="c1"># 初始化迭代次数计数器</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1"># 开始迭代过程</span>
</span></span><span class="line"><span class="cl">  <span class="kr">while</span><span class="p">(</span> <span class="nf">max</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n.max</span> <span class="p">){</span>  <span class="c1"># 当梯度向量的最大绝对值大于阈值eps时继续迭代</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算梯度向量</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span> <span class="o">&lt;-</span> <span class="nf">grad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算黑塞矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">&lt;-</span> <span class="nf">hessian</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 更新x值，使用黑塞矩阵的逆乘以梯度向量</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x</span> <span class="o">-</span> <span class="nf">solve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 更新迭代次数</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">&lt;-</span> <span class="n">n</span> <span class="o">+</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1"># 如果达到最大迭代次数，则输出警告信息</span>
</span></span><span class="line"><span class="cl">  <span class="kr">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n.max</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cat</span><span class="p">(</span><span class="s">&#39;牛顿法求解失败&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1"># 返回牛顿法的结果，包括根、迭代次数和函数在根处的值</span>
</span></span><span class="line"><span class="cl">  <span class="nf">list</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">iter</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义函数fr</span>
</span></span><span class="line"><span class="cl"><span class="n">fr</span> <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">x[1]</span>  <span class="c1"># 提取x的第一个元素</span>
</span></span><span class="line"><span class="cl">  <span class="n">x2</span> <span class="o">&lt;-</span> <span class="n">x[2]</span>  <span class="c1"># 提取x的第二个元素</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 计算并返回函数fr的值</span>
</span></span><span class="line"><span class="cl">  <span class="m">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="n">^2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用牛顿法求解函数fr的根，初始猜测为c(2, -2)</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">&lt;-</span> <span class="nf">newton</span><span class="p">(</span><span class="n">func</span> <span class="o">=</span> <span class="n">fr</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">-2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    

    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 ColaBlack
    </section>
    
    <section class="powerby">
        
            一个小网站，用于文档查阅 <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

<script>
  
  const cssPath = "https://ColaBlack.github.io/waifu/waifu.css"
  const tipsJsonPath = "https://ColaBlack.github.io/waifu/waifu-tips.json"
  
  const live2d_path = "https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/";

  
  function loadExternalResource(url, type) {
      return new Promise((resolve, reject) => {
          let tag;
          if (type === "css") {
              tag = document.createElement("link");
              tag.rel = "stylesheet";
              tag.href = url;
          }
          else if (type === "js") {
              tag = document.createElement("script");
              tag.src = url;
          }
          if (tag) {
              tag.onload = () => resolve(url);
              tag.onerror = () => reject(url);
              document.head.appendChild(tag);
          }
      });
  }

  
  if (screen.width >= 768) {
      Promise.all([
          loadExternalResource(cssPath, "css"),
          loadExternalResource(live2d_path + "live2d.min.js", "js"),
          loadExternalResource(live2d_path + "waifu-tips.js", "js")
      ]).then(() => {
          
          initWidget({
              waifuPath: tipsJsonPath,
              cdnPath: "https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/",
              tools: ["hitokoto", "asteroids", "switch-model", "switch-texture", "photo", "info", "quit"]
          });
      });
  }
</script>

    </body>
</html>
